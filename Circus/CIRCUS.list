# file opened: l:\vz-dis-games\Circus\CIRCUS.asm
   1  0000              ;***********************************************************************************************
   2  0000              ;
   3  0000              ; 	Circus
   4  0000              ;   Disect by Casper 08.01.2020
   5  0000              ;
   6  0000              ;	Verified with SjASMPlus Z80 Cross-Assembler v1.14.3 (https://github.com/z00m128/sjasmplus)
   7  0000              ;-----------------------------------------------------------------------------------------------
   8  0000
   9  0000
  10  0000              	MACRO	FNAME 	filename
  11  0000 ~            .beg		defb 	filename
  12  0000 ~            			block 	16-$+.beg
  13  0000 ~            			defb	0
  14  0000              	ENDM
  15  0000
  16  0000
  17  0000              ; org 7AD1
  18  0000              ;***********************************************************************
  19  0000              ; File Header Block
  20  0000 56 5A 46 30  	defb 	"VZF0"                  			; [0000] Magic
  21  0004              	FNAME	"CIRCUS"
  21  0004 43 49 52 43 >.beg		defb 	"CIRCUS"
  21  0008 55 53       >
  21  000A 00 00 00... >			block 	16-$+.beg
  21  0014 00          >			defb	0
  22  0015 F0           	defb	$F0             					; File Type
  23  0016 E9 7A            defw    $7ae9           					; Destination/Start address
  24  0018
  25  0018              ;******* BASIC STARTUP **************************************************
  26  0018
  27  0018                      org     $7ae9
  28  7AE9
  29  7AE9              ; 10 CLS:A=0
  30  7AE9              BASIC_10
  31  7AE9 F3 7A                defw    BASIC_20        				; next basic line       		; [7ae9] f3 7a
  32  7AEB 0A 00                defw    10              				; basic line number     		; [7aeb] 00 0a
  33  7AED 84                   defb    $84             				; CLS                   		; [7aed] 84
  34  7AEE 3A                   defb    ":"             				; instruction end       		; [7aee] 3a
  35  7AEF 41 D5 30             defb    $41,$d5,$30     				; A=05                  		; [7aef] 41 d5 30
  36  7AF2 00                   defb    0               				; End of line           		; [7af2] 00
  37  7AF3
  38  7AF3              ; 20 PRINT"INPUT":PRINT"J FOR JOYSTICK":PRINT"K FOR KEYBOARD"
  39  7AF3              BASIC_20
  40  7AF3 24 7B                defw    BASIC_30        				; next basic line       		; [7af3] 24 7b
  41  7AF5 14 00                defw    20              				; basic line number     		; [7af5] 14 00
  42  7AF7 B2 22 49 4E          defb    $b2,$22,"INPUT",$22 			; PRINT"INPUT"      			; [7af7] b2 22 49 4e 50 55 54 22
  42  7AFB 50 55 54 22
  43  7AFF 3A                   defb    $3a             				; instruction end       		; [7aff] 3a
  44  7B00 B2 22 4A 20          defb    $b2,$22,"J FOR JOYSTICK",$22 	; PRINT"J FOR JOYSTICK" 		; [7b00] b2 22 4a 20 46 4f 52 20 4a 4f 59 53 54 49 43 4b 22
  44  7B04 46 4F 52 20
  44  7B08 4A 4F 59 53
  44  7B0C 54 49 43 4B
  44  7B10 22
  45  7B11 3A                   defb    $3a             				; instruction end       		; [7b11] 3a
  46  7B12 B2 22 4B 20          defb    $b2,$22,"K FOR KEYBOARD",$22 	; PRINT"K FOR KEYBOARD" 		; [7b12] b2 22 4b 20 46 4f 52 20 4b 45 59 42 4f 41 52 44 22
  46  7B16 46 4F 52 20
  46  7B1A 4B 45 59 42
  46  7B1E 4F 41 52 44
  46  7B22 22
  47  7B23 00                   defb    0               				; End of line           		; [7b23] 00
  48  7B24
  49  7B24              ; 30 INPUTA$
  50  7B24              BASIC_30
  51  7B24 2C 7B                defw    BASIC_40        				; next basic line       		; [7b24] 2c 7b
  52  7B26 1E 00                defw    30              				; basic line number     		; [7b26] 1e 00
  53  7B28 89 41 24             defb    $89,"A$"        				; INPUTA$               		; [7b28] 89 41 24
  54  7B2B 00                   defb    0               				; End of line           		; [7b2b] 00
  55  7B2C
  56  7B2C              ; 40 IFA$<>"J"ANDA$<>"K"THEN10
  57  7B2C              BASIC_40
  58  7B2C 44 7B                defw    BASIC_50        				; next basic line       		; [7b2c] 44 7b
  59  7B2E 28 00                defw    40              				; basic line number     		; [7b2e] 28 00
  60  7B30 8F 41 24 D6          defb    $8f,"A$",$d6,$d4,$22,"J",$22    ; IFA$<>"J"    		 			; [7b30] bf 41 24 d6 d4 22 4a 22
  60  7B34 D4 22 4A 22
  61  7B38 D2 41 24 D6          defb    $d2,"A$",$d6,$d4,$22,"K",$22    ; ANDA$<>"K"    				; [7b37] d2 41 24 d6 d4 22 4b 22
  61  7B3C D4 22 4B 22
  62  7B40 CA 31 30             defb    $ca,"10"        				; THEN10                		; [7b40] ca 31 30
  63  7B43 00                   defb    0               				; End of line           		; [7b43] 00
  64  7B44
  65  7B44              ; 50 IFA$="J"THENA=255
  66  7B44              BASIC_50
  67  7B44 56 7B                defw    BASIC_60       	 				; next basic line       		; [7b44] 56 7b
  68  7B46 32 00                defw    50              				; basic line number     		; [7b46] 32 00
  69  7B48 8F 41 24 D5          defb    $8f,"A$",$d5,$22,"J",$22        ; IFA$="J"      				; [7b48] bf 41 24 d5 22 4a 22
  69  7B4C 22 4A 22
  70  7B4F CA 41 D5 32          defb    $ca,"A",$d5,"255"               ; THENA=255     				; [7b4f] ca 41 d5 32 35 35
  70  7B53 35 35
  71  7B55 00                   defb    0               				; End of line           		; [7b55] 00
  72  7B56
  73  7B56              ; 60 PRINT"PRESS ANY KEY TO START"
  74  7B56              BASIC_60
  75  7B56 74 7B                defw    BASIC_70        				; next basic line       		; [7b56] 74 7b
  76  7B58 3C 00                defw    60              				; basic line number     		; [7b58] 3c 00
  77  7B5A B2 22 50 52          defb    $b2,$22,"PRESS ANY KEY TO START",$22    						; [7b5a] b2 22 50 52 45 53 53 20 41 4e 59 20 4b 45 59 54 4f 20 53 54 41 52 54 22
  77  7B5E 45 53 53 20
  77  7B62 41 4E 59 20
  77  7B66 4B 45 59 20
  77  7B6A 54 4F 20 53
  77  7B6E 54 41 52 54
  77  7B72 22
  78  7B73 00                   defb    0               				; End of line           		; [7b73] 00
  79  7B74
  80  7B74              ; 70 FORI=1TO800:NEXT
  81  7B74              BASIC_70
  82  7B74 83 7B                defw    BASIC_72        				; next basic line       		; [7b74] 83 7b
  83  7B76 46 00                defw    70              				; basic line number     		; [7b76] 46 00
  84  7B78 81 49 D5 31          defb    $81,"I",$d5,"1",$bd,"800" 		; FORI=1TO800 					; [7b78] 81 49 d5 31 bd 38 30 30
  84  7B7C BD 38 30 30
  85  7B80 3A                   defb    $3a             				; instruction end       		; [7b80] 3a
  86  7B81 87                   defb    $87             				; NEXT                  		; [7b81] 87
  87  7B82 00                   defb    0               				; End of line           		; [7b82] 00
  88  7B83
  89  7B83              ; 72 A$=INKEY$
  90  7B83              BASIC_72
  91  7B83 8C 7B                defw    BASIC_75        				; next basic line       		; [7b83] 8c 7b
  92  7B85 48 00                defw    72              				; basic line number     		; [7b85] 48 00
  93  7B87 41 24 D5 C9          defb    "A$",$d5,$c9    				; A$=INKEY$             		; [7b87] 41 24 d5 c9
  94  7B8B 00                   defb    0               				; End of line           		; [7b8b] 00
  95  7B8C
  96  7B8C              ; 75 A$=INKEY$:IFA$=""THEN75
  97  7B8C              BASIC_75
  98  7B8C 9F 7B                defw    BASIC_80        				; next bacic line       		; [7b8c] 9f 7b
  99  7B8E 4B 00                defw    75              				; basic line number     		; [7b8e] 41 00
 100  7B90 41 24 D5 C9          defb    "A$",$d5,$c9    				; A$=INKEY$             		; [7b90] 41 24 d5 c9
 101  7B94 3A                   defb    $3a             				; instruction end       		; [7b94] 3a
 102  7B95 8F 41 24 D5          defb    $8f,"A$",$d5,$22,$22,$ca,"75" 	; IFA$=""THEN75   				; [7b95] 8f 41 24 d5 22 22 ca 37 35
 102  7B99 22 22 CA 37
 102  7B9D 35
 103  7B9E 00                   defb    0               				; end of line           		; [7b9e] 00
 104  7B9F
 105  7B9F              ; 80 POKE30738,A:POKE30862,208:POKE30863,123:A=USR(X)
 106  7B9F              ; Binary Start adres = 123 * 256 + 208 = ($7b << 8) | $d0 = $7bd0
 107  7B9F              BASIC_80
 108  7B9F C9 7B                defw    BASIC_END       				; next basic line       		; [7b9f] c9 7b
 109  7BA1 50 00                defw    80              				; basic line number     		; [7ba1] 00 50
 110  7BA3 B1 33 30 37          defb    $B1,"30738,A"   				; POKE30738,A           		; [7ba3] B1 33 30 37 33 38 2c 41
 110  7BA7 33 38 2C 41
 111  7BAB 3A                   defb    $3a             				; instruction end       		; [7bab] 3a
 112  7BAC B1 33 30 38          defb    $B1,"30862,208" 				; POKE30862,208         		; [7bac] B1 33 30 38 36 32 2c 32 30 38
 112  7BB0 36 32 2C 32
 112  7BB4 30 38
 113  7BB6 3A                   defb    $3a             				; instruction end       		; [7bb6] 3a
 114  7BB7 B1 33 30 38          defb    $B1,"30863,123" 				; POKE30863,123         		; [7bb7] B1 33 30 38 36 33 2c 31 32 33
 114  7BBB 36 33 2C 31
 114  7BBF 32 33
 115  7BC1 3A                   defb    $3a             				; instruction end       		; [7bc1] 3a
 116  7BC2 41 D5 C1 28          defb    "A",$d5,$c1,"(X)"  				; A=USR(X)           			; [7bc2] 41 d5 c1 28 58 29
 116  7BC6 58 29
 117  7BC8 00                   defb    0               				; end of line           		; [7bc8] 00
 118  7BC9
 119  7BC9              BASIC_END
 120  7BC9 00 00                defw    0               				; next line 0 means end 		; [7bc9] 00 00
 121  7BCB 50 00                defw    80              				; basic line number     		; [7bcb] 50 00
 122  7BCD 00                   defb    0               				; end of line           		; [7bcd] 00
 123  7BCE
 124  7BCE 00 00                defb    $00,$00         				; end of code           		; [7bce] 00 00
 125  7BD0
 126  7BD0              ;******************************************************************************
 127  7BD0              ; SYSTEM VARIABLES
 128  7BD0              JOY_FIRE_PORT		equ		$20			; (RD) Joystick Fire button
 129  7BD0              JOY1_PORT			equ		$2e			; (RD) Joystick 1 IO Port
 130  7BD0              JOY2_PORT			equ		$2b			; (RD) Joystick 2 IO Port
 131  7BD0              KEYB_PORT       	equ     $6800       ; (RD) Keyboard adress start
 132  7BD0              IOLATCH         	equ     $6800       ; (WR) Hardware IO Latch, (RD) Keyboard all Keys
 133  7BD0              BIT_VDG_MODE    	equ     00001000b   ; VDG Mode
 134  7BD0              BIT_SPK_MINUS   	equ     00100000b   ; Speake Pin (-)
 135  7BD0              BIT_SPK_PLUS   		equ     00000001b   ; Speake Pin (-)
 136  7BD0              SPEAKER_PINS		equ		BIT_SPK_MINUS|BIT_SPK_PLUS
 137  7BD0              VRAM            	equ     $7000       ; Video RAM start address
 138  7BD0              USER_INT_PROC    	equ     $787d  		; 3 bytes - jump vector called by System on interrupt
 139  7BD0
 140  7BD0              ;******************************************************************************
 141  7BD0              ; GAME VARIABLES
 142  7BD0              CUR_SCORE       	equ     $7800   	; (word) game score in BCD format
 143  7BD0              BALOONS_RED_DIR		equ		$7802		; (byte) movement direction for Baloons Red 0 - right, $80 - left
 144  7BD0              BALOONS_YEL_DIR		equ		$7803		; (byte) movement direction for Ballons Yellow 0 - right, $80 - left
 145  7BD0              BALOONS_BLU_DIR		equ		$7804		; (byte) movement direction for Baloons Blue 0 - right, $80 - left
 146  7BD0              BALOONS_DRAW_NEXT	equ		$7805		; (byte) round robin counter for Baloon Group next to be drawn
 147  7BD0              BALOONS_RED_X_FRAC	equ		$7806		; (byte) position X for Baloons Group Red (fraction of pixel)
 148  7BD0              BALOONS_YEL_X_FRAC	equ		$7807		; (byte) position X for Baloons Group Yellow (fraction of pixel)
 149  7BD0              BALOONS_BLU_X_FRAC	equ		$7808		; (byte) position X for Baloons Group Blue (fraction of pixel)
 150  7BD0              PLAYER_POS_VADR		equ		$7809		; (word) PLAYER screen position as VRAM address
 151  7BD0              JUMPER_W_VADR		equ		$780b		; (word) JUMPER W(aiting) screen position as VRAM address
 152  7BD0              JUMPER_VADR			equ		$780d		; (word) JUMPER screen position as VRAM address
 153  7BD0              PLAYER_X_FRAC		equ		$780f		; (word) position X for PLAYER (fraction of pixel) 16 bit value with next byte
 154  7BD0              PLAYER_X_INT		equ		$7810		; (byte) position X for PLAYER in integral pixels
 155  7BD0              JUMPER_W_X_INT		equ		$7811		; (byte) position X for JUMPER W(aiting) in integral pixels
 156  7BD0              INPUT_FLAG      	equ     $7812   	; (byte) input chosen by user 255 - Joystick. 0 - Keyboard
 157  7BD0              JUMPER_W_Y_INT		equ		$7813		; (byte) position Y for JUMPER W(aiting) in lines (bottom up)
 158  7BD0              JUMPER_X_FRAC		equ		$7814		; (word) position X for JUMPER (fraction of pixel) 16 bit value with next byte
 159  7BD0              JUMPER_X_INT		equ		$7815		; (byte) position X for JUMPER in integral pixels
 160  7BD0              JUMPER_Y_FRAC		equ		$7816		; (word) position Y for JUMPER (fraction of pixel) 16 bit value with next byte
 161  7BD0              JUMPER_Y_INT		equ		$7817		; (byte) position Y for JUMPER in integral pixels
 162  7BD0              GAME_EVENT			equ		$7818		; (byte) game event variable shared with interrupt routines
 163  7BD0              BALOONS_LEFT		equ		$7819		; (byte) number of Baloons left
 164  7BD0              BAR_CLEAR_FLAG		equ		$781a		; (byte) set when player unit moved and 1px on left must be cleared
 165  7BD0              BAR_FLIP_FLAG		equ		$781b		; (byte) player unit bar flipped flag (0 not flipped)
 166  7BD0              PLAYER_X_VEL		equ		$781c		; (word) 16 bit value to add/sub player pos X when move
 167  7BD0              WORLD_GRAVITY		equ		$781e		; (word) gravity value used to subtract from Y velocity of Jumper
 168  7BD0              JUMPER_X_VEL		equ		$7820		; (word) 16 bit value to add/sub Jumper pos X when move
 169  7BD0              JUMPER_Y_VEL		equ		$7822		; (word) 16 bit value to add/sub Jumper pos Y when move
 170  7BD0              JUMPER_W_CLR_VADR	equ		$7824		; (word) VRAM address of Jumper W(aiting) used to clear sprite area plus 1 byte on left
 171  7BD0              JUMPER_W_CLR_X_INT	equ		$7826		; (byte) position X for Jumper W(aiting) in pixels used to clear sprite area plus 1 byte on left
 172  7BD0              JUMPER_CLR_VADR		equ		$7827		; (word) VRAM address of Jumper used to clear sprite area
 173  7BD0              JUMPER_CLR_X_INT	equ		$7829		; (byte) position X for Jumper in pixels used to clear sprite area
 174  7BD0              LIFE_COUNTER		equ		$782a		; (byte) player life counter
 175  7BD0              IOLATCH_SHADOW  	equ     $782b   	; (byte) custom IO Latch shadow register
 176  7BD0              SCR_DIRTY_FLAG		equ		$782c		; (byte) set to $80 if screen need cleanup, 0 - cleanup done
 177  7BD0              PLAYER_DEATH_VADR	equ		$782d		; (word) VRAM address to draw/clear player death
 178  7BD0              GAME_MODE           equ     $782f   	; (byte) 255 - Demo Mode (computer plays until key pressed), 0 - Runnin Mode
 179  7BD0              SPR_BUF_DIGIT 		equ    	$7830   	; 10 bytes buffer for sprites generated for Score digits
 180  7BD0              SPR_BUF_BALOONS_RED	equ		$7880		; 128 bytes buffer for Baloons Group Red
 181  7BD0              SPR_BUF_BALOONS_YEL	equ		$7900		; 128 bytes buffer for Baloons Group Yellow
 182  7BD0              SPR_BUF_BALOONS_BLU	equ		$7980		; 128 bytes buffer for BAloons Group Blue
 183  7BD0              RESET_VAR			equ		$7a00		; (byte) reset to 0 on new game (but no more used)
 184  7BD0              SPR_BUF_PLAYER		equ		$7a01		; 56 bytes buffer for Player Sprite
 185  7BD0              SPR_BUF_JUMPER_W	equ		$7a39		; 21 bytes buffer for Jumper W(aiting) Sprite
 186  7BD0              SPR_BUF_JUMPER		equ		$7a4e		; 21 bytes buffer for Jumper Sprite
 187  7BD0
 188  7BD0
 189  7BD0              ;******************************************************************************
 190  7BD0              ;
 191  7BD0              ;    M A I N   G A M E
 192  7BD0              ;
 193  7BD0              ;******************************************************************************
 194  7BD0              START   			org     $7bd0
 195  7BD0              ; -- disable interrupts and set Demo Mode for Game
 196  7BD0 F3           	di						; disable interrupts                        		;7bd0	f3
 197  7BD1 31 00 90     	ld sp,$9000				; set StackPointer to max RAM (6kB models)  		;7bd1	31 00 90
 198  7BD4 3E FF        	ld a,$ff				; initial value for Game Mode              			;7bd4	3e ff
 199  7BD6 32 2F 78     	ld (GAME_MODE),a		; set Demo Mode							 			;7bd6	32 2f 78
 200  7BD9
 201  7BD9              GAME_INIT:
 202  7BD9 CD 33 7D     	call INIT_GAME			; initialize Game									;7bd9	cd 33 7d
 203  7BDC 21 80 72     	ld hl,VRAM+(20*32)+0	; screen coord (0,20) px [$7280]					;7bdc	21 80 72
 204  7BDF DD 21 26 81  	ld ix,SPR_JUMPER_S0		; sprite MAN 2 (12x7)px								;7bdf	dd 21 26 81
 205  7BE3 06 07        	ld b,7					; 7 lines - sprite height							;7be3	06 07
 206  7BE5 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;7be5	0e 03
 207  7BE7 CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;7be7	cd 8c 7f
 208  7BEA CD 39 89     	call PLAY_MEL_START		; play intro melody									;7bea	cd 39 89
 209  7BED              GAME_NEW:
 210  7BED 21 10 00     	ld hl,16				; ~1/25 px - world gravity force					;7bed	21 10 00
 211  7BF0 22 1E 78     	ld (WORLD_GRAVITY),hl	; store value										;7bf0	22 1e 78
 212  7BF3 21 A0 00     	ld hl,$00a0				; init JUMPER Y velocity (7/16 px)					;7bf3	21 a0 00
 213  7BF6 22 22 78     	ld (JUMPER_Y_VEL),hl	; store JUMPER Y velocity							;7bf6	22 22 78
 214  7BF9 21 A0 00     	ld hl,$00a0				; init JUMPER X velocity (7/16 px)					;7bf9	21 ff 00
 215  7BFC 22 20 78     	ld (JUMPER_X_VEL),hl	; store JUMPER X velocity 							;7bfc	22 20 78
 216  7BFF              ; -- initial position for JUMPER
 217  7BFF 21 80 72     	ld hl,VRAM+(20*32)+0	; screen coord (0,20) px [$7280]					;7bff	21 80 72
 218  7C02 22 0D 78     	ld (JUMPER_VADR),hl		; store as current JUMPER VRAM address				;7c02	22 0d 78
 219  7C05 22 27 78     	ld (JUMPER_CLR_VADR),hl	; store VRAM address for clear routines				;7c05	22 27 78
 220  7C08 21 00 00     	ld hl,0					; init pos X (h=0 pixels, l=0 fraction)				;7c08	21 00 00
 221  7C0B 22 14 78     	ld (JUMPER_X_FRAC),hl	; store JUMPER initial X position (16 bit)			;7c0b	22 14 78
 222  7C0E 21 00 2B     	ld hl,$2b00				; init pos Y (h=43 pixels, l=0 fraction)			;7c0e	21 00 2b
 223  7C11 22 16 78     	ld (JUMPER_Y_FRAC),hl	; store JUMPER initial Y position (16 bit)			;7c11	22 16 78
 224  7C14 AF           	xor a					; init pos X 										;7c14	af
 225  7C15 32 29 78     	ld (JUMPER_CLR_X_INT),a	; store position X for clear routines				;7c15	32 29 78
 226  7C18
 227  7C18              GAME_MAIN_LOOP:
 228  7C18 AF           	xor a					; 0 - no events to handle							;7c18	af
 229  7C19 32 18 78     	ld (GAME_EVENT),a		; store to Game Event variable						;7c19	32 18 78
 230  7C1C FB           	ei						; enable interrupts									;7c1c	fb
 231  7C1D              ; -- wait for game event (key/joystick interraction)
 232  7C1D              GAME_WAIT1:
 233  7C1D 3A 18 78     	ld a,(GAME_EVENT)		; a - game event									;7c1d	3a 18 78
 234  7C20 B7           	or a					; chack if any ocourred								;7c20	b7
 235  7C21 28 FA        	jr z,GAME_WAIT1			; wait for event 									;7c21	28 fa
 236  7C23              ; -- a - event to handle
 237  7C23 F3           	di						; disable interrupts								;7c23	f3
 238  7C24 FA AB 7C     	jp m,BALOON_COLLECTED	; bit 7 = 1 - Baloon Collected							;7c24	fa ab 7c
 239  7C27
 240  7C27              ; -- bit 7 = 0 - Player Died - schedule Death drawing and wait
 241  7C27 21 41 88     	ld hl,INT_GAME_DEATH	; set interrupt proc (Death variant)				;7c27	21 41 88
 242  7C2A 22 7E 78     	ld (USER_INT_PROC+1),hl	; set system redirection							;7c2a	22 7e 78
 243  7C2D FB           	ei						; enable interrupts									;7c2d	fb
 244  7C2E              ; -- INT_GAME_DEATH proc clears Game Event variable - wait for next frame
 245  7C2E              GAME_WAIT2:
 246  7C2E 3A 18 78     	ld a,(GAME_EVENT)		; a - Game Event									;7c2e	3a 18 78
 247  7C31 B7           	or a					; check if already handled							;7c31	b7
 248  7C32 20 FA        	jr nz,GAME_WAIT2		; wait for screen update							;7c32	20 fa
 249  7C34              ; -- disable interrupts, decrement Life Counter and End Game or Start next Play
 250  7C34 F3           	di						; disable interrupts								;7c34	f3
 251  7C35 CD 2D 87     	call PLAY_SND_HIGH		; play high beep sound								;7c35	cd 2d 87
 252  7C38 3A 2A 78     	ld a,(LIFE_COUNTER)		; a - number of lives left for player				;7c38	3a 2a 78
 253  7C3B 3D           	dec a					; dec counter										;7c3b	3d
 254  7C3C 32 2A 78     	ld (LIFE_COUNTER),a		; store new value									;7c3c	32 2a 78
 255  7C3F CA FE 7C     	jp z,GAME_OVER			; jump if End of Game (no lives left)				;7c3f	ca fe 7c
 256  7C42              ; -- more Lives left - continue
 257  7C42 3A 2F 78     	ld a,(GAME_MODE)		; a - Game Mode										;7c42	3a 2f 78
 258  7C45 B7           	or a					; check if Demo Mode								;7c45	b7
 259  7C46 C2 28 7D     	jp nz,DEMO_GAMEPLAY_END	; yes - shorter delay than in game					;7c46	c2 28 7d
 260  7C49              ;-- Game Running - longer wait delay [counter dbc = $3ffff]
 261  7C49 16 03        	ld d,3					; delay high dword value							;7c49	16 03
 262  7C4B              G_WAIT_DBC:
 263  7C4B 01 FF FF     	ld bc,$ffff				; delay low dword value								;7c4b	01 ff ff
 264  7C4E              G_WAIT_BC:
 265  7C4E 0B           	dec bc					; dec delay countr									;7c4e	0b
 266  7C4F 78           	ld a,b					; check if 0										;7c4f	78
 267  7C50 B1           	or c					; a = b|c											;7c50	b1
 268  7C51 20 FB        	jr nz,G_WAIT_BC			; repeat until 0									;7c51	20 fb
 269  7C53 15           	dec d					; dec delay counter 								;7c53	15
 270  7C54 20 F5        	jr nz,G_WAIT_DBC		; repeat until 0									;7c54	20 f5
 271  7C56
 272  7C56              ; -- Continue Game
 273  7C56              GAMEPLAY_START:
 274  7C56              ; -- reset Player Unit position and Bar state
 275  7C56 AF           	xor a					; 0 - player unit bar not flipped (left-up)			;7c56	af
 276  7C57 32 1B 78     	ld (BAR_FLIP_FLAG),a	; store current bar state 							;7c57	32 1b 78
 277  7C5A 21 00 34     	ld hl,03400h			; player pos X: h=52 pixels, l=fraction				;7c5a	21 00 34
 278  7C5D 22 0F 78     	ld (PLAYER_X_FRAC),hl	; store initial player position						;7c5d	22 0f 78
 279  7C60              ; -- reset Jumper Waiting position
 280  7C60 3E 45        	ld a,69					; Jumper Waiting pos X 								;7c60	3e 45
 281  7C62 32 11 78     	ld (JUMPER_W_X_INT),a	; store initial value								;7c62	32 11 78
 282  7C65 32 26 78     	ld (JUMPER_W_CLR_X_INT),a	; store pos X for clear routines				;7c65	32 26 78
 283  7C68 3E 0F        	ld a,15					; Jumper Waiting pos Y (bottom up)					;7c68	3e 0f
 284  7C6A 32 13 78     	ld (JUMPER_W_Y_INT),a	; store initial value								;7c6a	32 13 78
 285  7C6D 21 11 76     	ld hl,VRAM+(48*32)+17	; screen coord (68x48) px [$7611]					;7c6d	21 11 76
 286  7C70 22 0B 78     	ld (JUMPER_W_VADR),hl	; store current position							;7c70	22 0b 78
 287  7C73              ; -- reset Player Unit offscreen buffer content
 288  7C73 21 38 80     	ld hl,SPR_PLAYER_S0		; src - address of original sprite (base version)	;7c73	21 38 80
 289  7C76 11 01 7A     	ld de,SPR_BUF_PLAYER	; dst - address of buffer							;7c76	11 01 7a
 290  7C79 01 38 00     	ld bc,56				; cnt - 56 bytes to copy							;7c79	01 38 00
 291  7C7C ED B0        	ldir					; copy sprite to buffer								;7c7c	ed b0
 292  7C7E              ; -- reset Jumper Waiting offscreen buffer content
 293  7C7E 21 3B 81     	ld hl,SPR_JUMPER_S1		; src - address of original sprite (1px shifted) 	;7c7e	21 3b 81
 294  7C81 11 39 7A     	ld de,SPR_BUF_JUMPER_W	; dst - address of buffer							;7c81	11 39 7a
 295  7C84 01 15 00     	ld bc,21				; cnt - bytes to copy								;7c84	01 15 00
 296  7C87 ED B0        	ldir					; copy sprite to buffer								;7c87	ed b0
 297  7C89              ; -- play double sound
 298  7C89 CD 2D 87     	call PLAY_SND_HIGH		; play high beep sound								;7c89	cd 2d 87
 299  7C8C CD 2D 87     	call PLAY_SND_HIGH		; play high beep sound								;7c8c	cd 2d 87
 300  7C8F              ; -- schedule screen cleanup and wait for frame
 301  7C8F 21 B9 88     	ld hl,INT_CLEANUP		; Game interrupt proc - Cleanup variant				;7c8f	21 b9 88
 302  7C92 22 7E 78     	ld (USER_INT_PROC+1),hl	; set system redirection							;7c92	22 7e 78
 303  7C95              ; -- set dirty flag and wait
 304  7C95 3E 80        	ld a,$80				; a - screen needs cleanup							;7c95	3e 80
 305  7C97 32 2C 78     	ld (SCR_DIRTY_FLAG),a	; set dirty flag									;7c97	32 2c 78
 306  7C9A FB           	ei						; enable interrupts									;7c9a	fb
 307  7C9B              WAIT_SCR_READY:
 308  7C9B 3A 2C 78     	ld a,(SCR_DIRTY_FLAG)	; a - dirty screen flag								;7c9b	3a 2c 78
 309  7C9E B7           	or a					; is screen ready ?									;7c9e	b7
 310  7C9F 20 FA        	jr nz,WAIT_SCR_READY	; no - wait for interrupt proc done 				;7c9f	20 fa
 311  7CA1
 312  7CA1              ; -- Screen is Ready - set INT routine to handle game
 313  7CA1 F3           	di						; disable interrupts while setting					;7ca1	f3
 314  7CA2 21 AE 82     	ld hl,INT_GAME_MAIN		; hl - interrupt proc (Game Main variant) 			;7ca2	21 ae 82
 315  7CA5 22 7E 78     	ld (USER_INT_PROC+1),hl	; set system redirection							;7ca5	22 7e 78
 316  7CA8 C3 ED 7B     	jp GAME_NEW				; ----- End of Proc --- restart gameplay			;7ca8	c3 ed 7b
 317  7CAB
 318  7CAB
 319  7CAB              ;*****************************************************************************************
 320  7CAB              ; Baloon was collected by Player
 321  7CAB              BALOON_COLLECTED:
 322  7CAB              ; -- play short beep sound
 323  7CAB CD 2D 87     	call PLAY_SND_HIGH		; play high beep sound								;7cab	cd 2d 87
 324  7CAE              ; --
 325  7CAE 21 10 00     	ld hl,$0010				; new JUMPER Y velocity ~1/25 px					;7cae	21 10 00
 326  7CB1 22 22 78     	ld (JUMPER_Y_VEL),hl	; store new Y velocity								;7cb1	22 22 78
 327  7CB4 21 17 88     	ld hl,INT_BALOON_COLLECTED	; interrupt proc - Baloon Killed variant			;7cb4	21 17 88
 328  7CB7 22 7E 78     	ld (USER_INT_PROC+1),hl	; set system redirection							;7cb7	22 7e 78
 329  7CBA FB           	ei						; enable interrupts									;7cba	fb
 330  7CBB              ; -- wait until interrupt proc updaate score, baloons buffer, etc
 331  7CBB              AK_WAIT:
 332  7CBB 3A 18 78     	ld a,(GAME_EVENT)		; a - Game Event									;7cbb	3a 18 78
 333  7CBE B7           	or a					; check if already handled							;7cbe	b7
 334  7CBF 20 FA        	jr nz,AK_WAIT			; no - wait for event handled						;7cbf	20 fa
 335  7CC1              ; -- Game is updated - restore main intterrupt routine
 336  7CC1 F3           	di						; disable interrupts								;7cc1	f3
 337  7CC2 21 AE 82     	ld hl,INT_GAME_MAIN		; hl - interrupt proc (Game Main variant)			;7cc2	21 ae 82
 338  7CC5 22 7E 78     	ld (USER_INT_PROC+1),hl	; set system redirection							;7cc5	22 7e 78
 339  7CC8              ; -- decrement Baloons counter and check if any left
 340  7CC8 3A 19 78     	ld a,(BALOONS_LEFT)		; a - baloons left									;7cc8	3a 19 78
 341  7CCB 3D           	dec a					; decrement counter									;7ccb	3d
 342  7CCC 32 19 78     	ld (BALOONS_LEFT),a		; store new value									;7ccc	32 19 78
 343  7CCF C2 18 7C     	jp nz,GAME_MAIN_LOOP	; if any left continue game							;7ccf	c2 18 7c
 344  7CD2
 345  7CD2              ; -- no more Baloons to collect - Player Won - let him continue with any Lives left
 346  7CD2              ; -- wait delay (24 bit value using registers D and BC)
 347  7CD2 16 04        	ld d,4					; d - delay counter 								;7cd2	16 04
 348  7CD4              AK_DELAY_BCD:
 349  7CD4 01 00 00     	ld bc,$0000				; bc - delay counter lower word $10000				;7cd4	01 00 00
 350  7CD7              AK_DELAY_BC:
 351  7CD7 0B           	dec bc					; decrement counter									;7cd7	0b
 352  7CD8 79           	ld a,c					; check if 0										;7cd8	79
 353  7CD9 B0           	or b					; a = b|c											;7cd9	b0
 354  7CDA 20 FB        	jr nz,AK_DELAY_BC		; repeat until 0									;7cda	20 fb
 355  7CDC 15           	dec d					; decrement high counter value						;7cdc	15
 356  7CDD 20 F5        	jr nz,AK_DELAY_BCD		; wait until 0										;7cdd	20 f5
 357  7CDF
 358  7CDF              ; -- restart screen to initial state
 359  7CDF CD 45 7D     	call INIT_START_SCREEN	; draw screen in startup state						;7cdf	cd 45 7d
 360  7CE2
 361  7CE2              ; -- decrement life counter and draw it on screen
 362  7CE2 3A 2A 78     	ld a,(LIFE_COUNTER)		; current Life Counter value						;7ce2	3a 2a 78
 363  7CE5 3D           	dec a					; dec counter										;7ce5	3d
 364  7CE6 57           	ld d,a					; d - number of lives left							;7ce6	57
 365  7CE7 CD A9 7D     	call SET_LIFE_COUNTER	; redraw life counter icons							;7ce7	cd a9 7d
 366  7CEA CD C6 7D     	call INIT_SPRITES		; initialize Sprites 								;7cea	cd c6 7d
 367  7CED
 368  7CED              ; -- draw JUMPER on Left Stand
 369  7CED 21 80 72     	ld hl,VRAM+(20*32)+0	; screen coord (0,20)px [$7280]						;7ced	21 80 72
 370  7CF0 DD 21 26 81  	ld ix,SPR_JUMPER_S0		; sprite JUMPER (12x7)px (base version)				;7cf0	dd 21 26 81
 371  7CF4 06 07        	ld b,7					; 7 lines - sprite height 							;7cf4	06 07
 372  7CF6 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;7cf6	0e 03
 373  7CF8 CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;7cf8	cd 8c 7f  
 374  7CFB C3 ED 7B     	jp GAME_NEW				; start New Game									;7cfb	c3 ed 7b
 375  7CFE
 376  7CFE              ;********************************************************************************
 377  7CFE              ; Game Over routine
 378  7CFE              ; Called when no more lives left in life counter
 379  7CFE              GAME_OVER:
 380  7CFE              ; -- short delay ----
 381  7CFE 01 30 00     	ld bc,48				; delay counter										;7cfe	01 30 00
 382  7D01              GO_DELAY:
 383  7D01 0B           	dec bc					; dec delay counter									;7d01	0b
 384  7D02 78           	ld a,b					; check if 0										;7d02	78
 385  7D03 B1           	or c					; a = b|c											;7d03	b1
 386  7D04 20 FB        	jr nz,GO_DELAY			; repeat until 0									;7d04	20 fb
 387  7D06
 388  7D06              ; -- play GameOver Melody
 389  7D06 CD 49 89     	call PLAY_MEL_GAME_OVER	; play GameOver Melody								;7d06	cd 49 89
 390  7D09
 391  7D09              ; -- check if Demo mode and if so than start new Game
 392  7D09 3A 2F 78     	ld a,(GAME_MODE)		; a - Game Mode										;7d09	3a 2f 78
 393  7D0C B7           	or a					; check if Demo Mode								;7d0c	b7
 394  7D0D C2 D9 7B     	jp nz,GAME_INIT			; yes - start new game								;7d0d	c2 d9 7b
 395  7D10
 396  7D10              ; -- Game Running - wait for key or joystick input
 397  7D10              GO_WAIT_FOR_INPUT:
 398  7D10 3A 12 78     	ld a,(INPUT_FLAG)		; check chosen input device							;7d10	3a 12 78
 399  7D13 B7           	or a					; is this Keyboard ? (0 keys, 255 joystick)			;7d13	b7
 400  7D14 28 07        	jr z,GO_CHECK_KEYS		; yes - check key pressed							;7d14	28 07
 401  7D16              ; -- check joystick input
 402  7D16 DB 20        	in a,(JOY_FIRE_PORT)	; get joiystick button								;7d16	db 20
 403  7D18 CB 67        	bit 4,a					; is button pressed ?								;7d18	cb 67
 404  7D1A CA D9 7B     	jp z,GAME_INIT			; yes - start new game								;7d1a	ca d9 7b
 405  7D1D              ; -- check key pressed
 406  7D1D              GO_CHECK_KEYS:
 407  7D1D 3A 00 68     	ld a,(KEYB_PORT)		; read all keys	at once								;7d1d	3a 00 68
 408  7D20 2F           	cpl						; inverse logic (key press sets bit)				;7d20	2f
 409  7D21 E6 3F        	and $3f					; any key pressed ?		 							;7d21	e6 3f
 410  7D23 28 EB        	jr z,GO_WAIT_FOR_INPUT	; no - wait for input								;7d23	28 eb
 411  7D25 C3 D9 7B     	jp GAME_INIT			; yes - start new game								;7d25	c3 d9 7b
 412  7D28
 413  7D28
 414  7D28              ;****************************************************************************************
 415  7D28              ; Delay beetween gameplays when the Game is in Demo Mode and continue
 416  7D28              DEMO_GAMEPLAY_END:
 417  7D28 01 FF FF     	ld bc,0ffffh			; delay counter										;7d28	01 ff ff
 418  7D2B              DEMO_DELAY:
 419  7D2B 0B           	dec bc					; decrement delay counter							;7d2b	0b
 420  7D2C 78           	ld a,b					; check if 0										;7d2c	78
 421  7D2D B1           	or c					; a = b|c											;7d2d	b1
 422  7D2E 20 FB        	jr nz,DEMO_DELAY		; wait until 0										;7d2e	20 fb
 423  7D30 C3 56 7C     	jp GAMEPLAY_START		; continune - start new play						;7d30	c3 56 7c
 424  7D33
 425  7D33              ;****************************************************************************************
 426  7D33              ; Initialize Game Screen, reset Life Counter, reset current Score, initialize Sprites
 427  7D33              INIT_GAME:
 428  7D33 CD 45 7D     	call INIT_START_SCREEN	; draw startup state of screen						;7d33	cd 45 7d
 429  7D36 16 04        	ld d,4					; number of player lives							;7d36	16 04
 430  7D38 CD A9 7D     	call SET_LIFE_COUNTER 	; set and draw life counter (d+1) 					;7d38	cd a9 7d
 431  7D3B 21 00 00     	ld hl,0		        	; hl - 0 current player                 			;7d3b	21 00 00
 432  7D3E 22 00 78     	ld (CUR_SCORE),hl		; save score initial value	        				;7d3e	22 00 78
 433  7D41 CD C6 7D     	call INIT_SPRITES		; initialize sprites at start positions				;7d41	cd c6 7d
 434  7D44 C9           	ret						;------------- End of Proc -----------				;7d44	c9
 435  7D45
 436  7D45              ;***************************************************************************************
 437  7D45              ; Screen initialization
 438  7D45              ; Set VDG Mode 1, clear screen and redraw all at starting positions
 439  7D45              INIT_START_SCREEN:
 440  7D45              ; -- Set VDG Mode 1, Background Green, Reset Speaker
 441  7D45 3E 28        	ld a,BIT_SPK_MINUS | BIT_VDG_MODE ; Speaker Out=1, VDG Mode 1   			;7d45	3e 28
 442  7D47 32 00 68     	ld (IOLATCH),a			; set VDG Mode 1 (bg=Green) (128x64)    			;7d47	32 00 68
 443  7D4A 32 2B 78     	ld (IOLATCH_SHADOW),a	; store last written value	in custom shadow reg 	;7d4a	32 2b 78
 444  7D4D
 445  7D4D              ; -- clear (fill green) screan (first 57 lines)
 446  7D4D AF               xor a					; value for video data         						;7d4d	af
 447  7D4E 01 20 07     	ld bc,(57*32)+0         ; counter = 57 lines x 32 bytes (128px)				;7d4e	01 20 07
 448  7D51 21 00 70     	ld hl,VRAM				; hl - start of Video RAM               			;7d51	21 00 70
 449  7D54 E5           	push hl					; copy hl to de                         			;7d54	e5
 450  7D55 D1           	pop de					; de - destination address              			;7d55	d1
 451  7D56 13           	inc de					; de - VRAM+1                           			;7d56	13
 452  7D57 77           	ld (hl),a				; store 0 to first address        					;7d57	77
 453  7D58 ED B0        	ldir		        	; fill 57 lines with 0 (green bg)       			;7d58	ed b0
 454  7D5A
 455  7D5A              ; -- fill (Red) Bottom Floor area (7 remaining lines) with 0xff value
 456  7D5A 2F               cpl						; a = $ff - 4 red pixels             				;7d5a	2f
 457  7D5B 77           	ld (hl),a				; store ff to first address       					;7d5b	77
 458  7D5C 01 DF 00     	ld bc,(7*32)-1			; counter = (7 lines * 32) - 1     					;7d5c	01 df 00
 459  7D5F ED B0        	ldir		        	; fill 7 lines with $ff (red)           			;7d5f	ed b0
 460  7D61
 461  7D61              ; -- draw Baloons - 3 series of 7 sprites in 3 areas of screen
 462  7D61 21 20 70         ld hl,VRAM+(1*32)+0     ; screen coord (0,1)px [$7020]						;7d61	21 20 70
 463  7D64 DD 21 A8 7F  	ld ix,SPR_BALOON_YEL	; sprite (8x4) px - Baloons Yellow Group           	;7d64	dd 21 a8 7f
 464  7D68 CD 5C 7E     	call DRAW_BALOON_GROUP	; draw 7 Yellow Baloons at line 1       			;7d68	cd 5c 7e
 465  7D6B 21 EC 70     	ld hl,VRAM+(7*32)+12    ; screen coord (48,7)px [$70ec]         			;7d6b	21 ec 70
 466  7D6E DD 21 B0 7F  	ld ix,SPR_BALOON_BLU 	; sprite (8x4) px -  Baloons Blue Group 	   		;7d6e	dd 21 b0 7f
 467  7D72 CD 5C 7E     	call DRAW_BALOON_GROUP	; draw 7 Blue Baloons at line 7						;7d72	cd 5c 7e
 468  7D75 21 A2 71     	ld hl,VRAM+(13*32)+2    ; screen coord (8,13)px [$71a2]						;7d75	21 a2 71
 469  7D78 DD 21 B8 7F  	ld ix,SPR_BALOON_RED	; sprite (8x4) px - Baloons Red Group      			;7d78	dd 21 b8 7f
 470  7D7C CD 5C 7E     	call DRAW_BALOON_GROUP	; draw 7 Red Baloons at line 13 					;7d7c	cd 5c 7e
 471  7D7F
 472  7D7F              ; -- draw left stand
 473  7D7F 21 60 73     	ld hl,VRAM+(27*32)+0    ; screen coord (0,27)px [$7360]         			;7d7f	21 60 73
 474  7D82 DD 21 C0 7F  	ld ix,SPR_STAND_LEFT 	; sprite (8x30) px Vertical Stand Left 				;7d82	dd 21 c0 7f
 475  7D86 06 1E        	ld b,30		        	; 30 lines - sprite height              			;7d86	06 1e
 476  7D88 0E 02        	ld c,2		        	; 2 bytes (8 px) - sprite width         			;7d88	0e 02
 477  7D8A CD 71 7F     	call DRAW_SPRITE		; draw sprite at (0,27)px	        				;7d8a	cd 71 7f
 478  7D8D
 479  7D8D              ; -- draw right stand
 480  7D8D 21 7E 73          ld hl,VRAM+(27*32)+30  ; screen coord (120,27)px [$737e]					;7d8d	21 7e 73
 481  7D90 DD 21 FC 7F  	ld ix,SPR_STAND_RIGHT 	; sprite (8x30) px Vertical Stand Right  			;7d90	dd 21 fc 7f
 482  7D94 CD 71 7F     	call DRAW_SPRITE		; draw sprite at (120,27)px             			;7d94	cd 71 7f
 483  7D97
 484  7D97              ; -- draw player unit at starting positions
 485  7D97 21 2D 76     	ld hl,VRAM+(49*32)+13   ; screen coord (52,49)px [$762d]					;7d97	21 2d 76
 486  7D9A 22 09 78     	ld (PLAYER_POS_VADR),hl	; store current player screen pos					;7d9a	22 09 78
 487  7D9D 06 08        	ld b,8		        	; 8 lines - sprite height               			;7d9d	06 08
 488  7D9F 0E 07        	ld c,7		        	; 7 bytes (28px) - sprite width         			;7d9f	0e 07
 489  7DA1 DD 21 38 80  	ld ix,SPR_PLAYER_S0		; sprite Player (base version)                    	;7da1	dd 21 38 80
 490  7DA5 CD 71 7F     	call DRAW_SPRITE		; draw sprite	                        			;7da5	cd 71 7f
 491  7DA8 C9           	ret						;------ End of Proc ----------          			;7da8	c9 	.
 492  7DA9
 493  7DA9              ;********************************************************************************************
 494  7DA9              ; Update and Draw Life Counter
 495  7DA9              ; Draws on screen number of men according to number of lives player has.
 496  7DA9              ; IN:  d - number of lives
 497  7DA9              SET_LIFE_COUNTER:
 498  7DA9 7A           	ld a,d					; a - number of sprites to draw						;7da9	7a
 499  7DAA 3C           	inc a					; inc counter (1 "life" in use)						;7daa	3c
 500  7DAB 32 2A 78     	ld (LIFE_COUNTER),a		; store current value								;7dab	32 2a 78
 501  7DAE 3D           	dec a					; dec counter - (life-1) sprites to draw			;7dae	3d
 502  7DAF C8           	ret z					; return if no lives left to draw					;7daf	c8
 503  7DB0              ; -- more lives left - redraw Life Counter area
 504  7DB0 21 20 77     	ld hl,VRAM+(57*32)+0 	; screen coord (0,57)px [$7720]						;7db0	21 20 77
 505  7DB3              DRAW_LIFE_SPRITE:
 506  7DB3 E5           	push hl					; save hl - screen address							;7db3	e5
 507  7DB4 06 07        	ld b,7		        	; 7 lines - sprite height               			;7db4	06 07
 508  7DB6 0E 02        	ld c,2		        	; 2 bytes (8px) - sprite width          			;7db6	0e 02
 509  7DB8 DD 21 18 81  	ld ix,SPR_LIFE_ICON		; sprite Life Icon (Man)							;7db8	dd 21 18 81
 510  7DBC CD 71 7F     	call DRAW_SPRITE		; draw sprite 										;7dbc	cd 71 7f
 511  7DBF E1           	pop hl					; restore hl - screen address						;7dbf	e1
 512  7DC0 23           	inc hl					; inc address (4px)									;7dc0	23
 513  7DC1 23           	inc hl					; inc address - new coord for sprite				;7dc1	23
 514  7DC2 15           	dec d					; dec number of sprites to draw						;7dc2	15
 515  7DC3 20 EE        	jr nz,DRAW_LIFE_SPRITE	; jump if more to draw								;7dc3	20 ee
 516  7DC5 C9           	ret						; ----------- End Of Proc --------					;7dc5	c9
 517  7DC6
 518  7DC6              ;****************************************************************************************
 519  7DC6              ; Initialize sprites at starting positions
 520  7DC6              INIT_SPRITES:
 521  7DC6              ; -- draw Score on screen
 522  7DC6 CD 72 7E     	call DRAW_CURRENT_SCORE	; draw current score on bottom 						;7dc6	cd 72 7e
 523  7DC9
 524  7DC9              ; -- store Baloons Red screen part to offscreen buffer
 525  7DC9 21 20 70     	ld hl,VRAM+(1*32)+0		; src - screen coord (0,1)px [$7020]				;7dc9	21 20 70
 526  7DCC 11 80 78     	ld de,SPR_BUF_BALOONS_RED	; dst - buffer for Baloons Red Group			;7dcc	11 80 78
 527  7DCF 01 80 00     	ld bc,128				; cnt - 128 bytes (4 lines) to copy					;7dcf	01 80 00
 528  7DD2 ED B0        	ldir					; store to buffer 									;7dd2	ed b0
 529  7DD4
 530  7DD4              ; -- store Baloons Yellow screen part to offscreen buffer
 531  7DD4 21 E0 70     	ld hl,VRAM+(7*32)+0		; src - screen coord (0,7)px [$70e0]				;7dd4	21 e0 70
 532  7DD7 11 00 79     	ld de,SPR_BUF_BALOONS_YEL	; dst - buffer for Baloons Yellow				;7dd7	11 00 79
 533  7DDA 01 80 00     	ld bc,128				; cnt - 128 bytes (4 lines) to copy					;7dda	01 80 00
 534  7DDD ED B0        	ldir					; store to buffer									;7ddd	ed b0
 535  7DDF
 536  7DDF              ; -- store Baloons Blue screen part to offscreen buffer
 537  7DDF 21 A0 71     	ld hl,VRAM+(13*32)+0    ; src - screen coord (0,13)px [$71a0]				;7ddf	21 a0 71
 538  7DE2 11 80 79     	ld de,SPR_BUF_BALOONS_BLU	; dst - buffer for Baloons Blue					;7de2	11 80 79
 539  7DE5 01 80 00     	ld bc,128				; cnt - 128 bytes (4 lines) to copy					;7de5	01 80 00
 540  7DE8 ED B0        	ldir					; store to buffer									;7de8	ed b0
 541  7DEA
 542  7DEA              ; -- store PLAYER Sprite to offscreen buffer
 543  7DEA 21 38 80     	ld hl,SPR_PLAYER_S0		; src - sprite PLAYER (base version)				;7dea	21 38 80
 544  7DED 11 01 7A     	ld de,SPR_BUF_PLAYER	; dst - buffer for current form of sprite			;7ded	11 01 7a
 545  7DF0 01 38 00     	ld bc,56				; cnt - 56 bytes to copy							;7df0	01 38 00
 546  7DF3 ED B0        	ldir					; store to buffer									;7df3	ed b0
 547  7DF5
 548  7DF5              ; -- store JUMPER (Waiting) to offscreen buffer	(1px offset)
 549  7DF5 21 3B 81     	ld hl,SPR_JUMPER_S1		; src - sprite JUMPER (1px shifted version)			;7df5	21 3b 81
 550  7DF8 11 39 7A     	ld de,SPR_BUF_JUMPER_W	; dst - buffer for current form of sprite			;7df8	11 39 7a
 551  7DFB 01 15 00     	ld bc,21				; cnt - 21 bytes to copy							;7dfb	01 15 00
 552  7DFE ED B0        	ldir					; store to buffer									;7dfe	ed b0
 553  7E00
 554  7E00              ; -- store JUMPER sprite to offscreen buffer
 555  7E00 21 26 81     	ld hl,SPR_JUMPER_S0		; src - sprite JUMPER (base version)				;7e00	21 26 81
 556  7E03 11 4E 7A     	ld de,SPR_BUF_JUMPER	; dst - buffer for current form of sprite			;7e03	11 4e 7a
 557  7E06 01 15 00     	ld bc,21				; cnt - 21 bytes to copy							;7e06	01 15 00
 558  7E09 ED B0        	ldir					; store to buffer									;7e09	ed b0
 559  7E0B
 560  7E0B              ; -- reset JUMPER Waiting position and draw it on screen
 561  7E0B 21 11 76     	ld hl,VRAM+(48*32)+17	; screen coord (17x48) px [$7611]					;7e0b	21 11 76
 562  7E0E 22 0B 78     	ld (JUMPER_W_VADR),hl	; store current VRAM address						;7e0e	22 0b 78
 563  7E11 22 24 78     	ld (JUMPER_W_CLR_VADR),hl; store address used for clear routine 			;7e11	22 24 78
 564  7E14 DD 21 3B 81  	ld ix,SPR_JUMPER_S1		; sprite JUMPER (12x7)px (1px shifted version)		;7e14	dd 21 3b 81
 565  7E18 06 07        	ld b,7					; 7 lines - sprite height							;7e18	06 07
 566  7E1A 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;7e1a	0e 03
 567  7E1C CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;7e1c	cd 8c 7f
 568  7E1F
 569  7E1F              ; -- reset Baloons Group's variables : BALOONS_RED_DIR, BALOONS_YEL_DIR, BALOONS_BLU_DIR
 570  7E1F AF           	xor a					; 0 value - reset									;7e1f	af
 571  7E20 21 02 78     	ld hl,BALOONS_RED_DIR	; address of first variable to clear				;7e20	21 02 78
 572  7E23 06 04        	ld b,4					; 4 bytes to clear									;7e23	06 04
 573  7E25              RESET_BALOONS_VARS:
 574  7E25 77           	ld (hl),a				; store 0 value										;7e25	77
 575  7E26 23           	inc hl					; next variable address								;7e26	23
 576  7E27 10 FC        	djnz RESET_BALOONS_VARS	; repeat for 4 bytes								;7e27	10 fc
 577  7E29
 578  7E29              ; -- reset PLAYER movement and position variables
 579  7E29 32 1B 78     	ld (BAR_FLIP_FLAG),a	; 0 - player unit bar not flipped (left-up)			;7e29	32 1b 78
 580  7E2C 21 00 34     	ld hl,$3400				; player pos X: h=52 pixels, l=00 fraction 			;7e2c	21 00 34
 581  7E2F 22 0F 78     	ld (PLAYER_X_FRAC),hl	; store initial player position						;7e2f	22 0f 78
 582  7E32 3E 45        	ld a,69					; Jumper Waiting pos X in pixels					;7e32	3e 45
 583  7E34 32 11 78     	ld (JUMPER_W_X_INT),a	; store initial value								;7e34	32 11 78
 584  7E37 32 26 78     	ld (JUMPER_W_CLR_X_INT),a	; store pos X for clear routines				;7e37	32 26 78
 585  7E3A 3E 0F        	ld a,15					; Jumper Waiting pos Y (bottom up)					;7e3a	3e 0f
 586  7E3C 32 13 78     	ld (JUMPER_W_Y_INT),a	; store initial value								;7e3c	32 13 78
 587  7E3F 21 FF 00     	ld hl,$00ff				; player unit X velocity ($00ff) almost pixel		;7e3f	21 ff 00
 588  7E42 22 1C 78     	ld (PLAYER_X_VEL),hl	; store initial value								;7e42	22 1c 78
 589  7E45
 590  7E45              ;-- clear reset variable (not used)
 591  7E45 AF           	xor a					; 0 - reset value									;7e45	af
 592  7E46 32 00 7A     	ld (RESET_VAR),a		; store to variable (not used)						;7e46	32 00 7a
 593  7E49
 594  7E49              ; -- reset Baloons Left Counter - number of Baloons left to collect
 595  7E49 3E 15        	ld a,3*7				; 7 Baloons in each of 3 groups/rows = 21 Baloons	;7e49	3e 15
 596  7E4B 32 19 78     	ld (BALOONS_LEFT),a		; store as number Baloons to collect				;7e4b	32 19 78
 597  7E4E
 598  7E4E              ; --- set custom interrupt handler
 599  7E4E 3E C3        	ld a,$c3				; JP opcode byte									;7e4e	3e c3
 600  7E50 32 7D 78     	ld (USER_INT_PROC),a	; set INT jump vector								;7e50	32 7d 78
 601  7E53 21 AE 82     	ld hl,INT_GAME_MAIN		; hl - interrupt proc (Game Main variant)			;7e53	21 ae 82
 602  7E56 22 7E 78     	ld (USER_INT_PROC+1),hl	; set system redirection							;7e56	22 7e 78
 603  7E59 ED 56        	im 1					; reset Interrupt Mode to 1							;7e59	ed 56
 604  7E5B C9           	ret						; ------------- End of Proc	-------------			;7e5b	c9
 605  7E5C
 606  7E5C
 607  7E5C              ;****************************************************************************
 608  7E5C              ; Copy Sprite to Screen 7 times with 24px gaps
 609  7E5C              ; Every sprite dimension forced to 8x4px (2x4 bytes)
 610  7E5C              ; IN:   ix - sprite data - fixed dimensions 8x4px
 611  7E5C              ;       hl - destination VRAM address
 612  7E5C              DRAW_BALOON_GROUP:
 613  7E5C 16 07        	ld d,7              	; d - 7 - sprite to draw counter            		 ;7e5c	16 07
 614  7E5E              DRAW_NEXT_BALOON:
 615  7E5E E5           	push hl					; save hl - left pixel screen address   			;7e5e	e5
 616  7E5F 06 04        	ld b,4                  ; b - 4 lines - sprite height           			;7e5f	06 04
 617  7E61 0E 02        	ld c,2		        	; c - 2 bytes (8px) - sprite width      			;7e61	0e 02
 618  7E63 DD E5        	push ix		        	; save ix - sprite source data address     			;7e63	dd e5
 619  7E65 CD 71 7F     	call DRAW_SPRITE		; draw sprite	                        			;7e65	cd 71 7f
 620  7E68 DD E1        	pop ix		        	; restore ix - sprite source data address  			;7e68	dd e1
 621  7E6A E1           	pop hl					; restore hl - destination VRAM address 			;7e6a	e1
 622  7E6B 23           	inc hl					; hl++ - next VRAM address (8px right)  			;7e6b	23
 623  7E6C 23           	inc hl					; hl++ - next VRAM address (8px right)  			;7e6c	23
 624  7E6D 23           	inc hl					; VRAM + 3 - VRAM address (24px offset) 			;7e6d	23
 625  7E6E 15           	dec d					; decrement sprites' counter            			;7e6e	15
 626  7E6F 20 ED        	jr nz,DRAW_NEXT_BALOON	; jump if more Aliens to draw           			;7e6f	20 ed
 627  7E71 C9           	ret						; ------------ End Of Proc  ---------------			;7e71	c9
 628  7E72
 629  7E72              ;*************************************************************************************
 630  7E72              ; Convert score from numeric value (BCD format) into decimal digits and then
 631  7E72              ; every digit is converted to sprite and draw at the bottom of screen.
 632  7E72              ; Score is stored in BCD format
 633  7E72              DRAW_CURRENT_SCORE:
 634  7E72              ; -- draw 4th digit on screen at (72,58)px
 635  7E72 3A 00 78     	ld a,(CUR_SCORE)		; a - 4th and 3rd digits of Score					;7e72	3a 00 78
 636  7E75 F5           	push af					; save a                                			;7e75	f5
 637  7E76 E6 0F        	and $0f		        	; a - 4th digit (BCD)                   			;7e76	e6 0f
 638  7E78 CD F1 7E     	call DIGIT_TO_SPRITE	; convert digit to sprite and set b,c (sprite dim)	;7e78	cd f1 7e
 639  7E7B 21 52 77     	ld hl,VRAM+(58*32)+18   ; screen coord (72,58)px [$7752]					;7e7b	21 52 77
 640  7E7E DD 21 30 78  	ld ix,SPR_BUF_DIGIT		; converted sprite of 4th digit                     ;7e7e	dd 21 30 78
 641  7E82 CD 71 7F     	call DRAW_SPRITE		; draw 4th digit	          	       				;7e82	cd 71 7f
 642  7E85              ; -- draw 3rd digit on screen at (64,58)px
 643  7E85 F1           	pop af					; restore a - 3rd & 4th digit           			;7e85	f1
 644  7E86 CB 3F        	srl a		        	; right shift a 4 times                 			;7e86	cb 3f
 645  7E88 CB 3F        	srl a		                                                				;7e88	cb 3f
 646  7E8A CB 3F        	srl a		                                                				;7e8a	cb 3f
 647  7E8C CB 3F        	srl a		        	; a - 3rd digit on 4 lower bits  	     			;7e8c	cb 3f
 648  7E8E CD F1 7E     	call DIGIT_TO_SPRITE	; convert digit to sprite and set b,c (sprite dim)	;7e8e	cd f1 7e
 649  7E91 CD D7 7E     	call SHIFT_SPRITE_1PX	; shift sprite 1 px right							;7e91	cd d7 7e
 650  7E94 21 50 77     	ld hl,VRAM+(58*32)+16   ; screen coord (64,58)px [$7750]					;7e94	21 50 77
 651  7E97 DD 21 30 78  	ld ix,SPR_BUF_DIGIT		; converted sprite 									;7e97	dd 21 30 78
 652  7E9B CD 71 7F     	call DRAW_SPRITE		; draw 3rd digit									;7e9b	cd 71 7f
 653  7E9E              ; -- draw 2nd digit on screen at (56,58)px
 654  7E9E 3A 01 78     	ld a,(CUR_SCORE+1)		; a - 1st & 2nd digit 								;7e9e	3a 01 78
 655  7EA1 F5           	push af					; save a											;7ea1	f5
 656  7EA2 E6 0F        	and $0f					; a - 2nd digit (BCD)								;7ea2	e6 0f
 657  7EA4 CD F1 7E     	call DIGIT_TO_SPRITE	; convert digit to sprite and set b,c				;7ea4	cd f1 7e
 658  7EA7 CD D7 7E     	call SHIFT_SPRITE_1PX	; shift sprite 1 px right							;7ea7	cd d7 7e
 659  7EAA CD D7 7E     	call SHIFT_SPRITE_1PX	; shift sprite 1 px right (2px total)				;7eaa	cd d7 7e
 660  7EAD 21 4E 77     	ld hl,VRAM+(58*32)+14   ; screen coord (56,58)px [$774e]					;7ead	21 4e 77
 661  7EB0 DD 21 30 78  	ld ix,SPR_BUF_DIGIT		; converted sprite									;7eb0	dd 21 30 78
 662  7EB4 CD 71 7F     	call DRAW_SPRITE		; draw 2nd digit									;7eb4	cd 71 7f
 663  7EB7              ; -- draw 1st digit on screen at (56,58)px
 664  7EB7 F1           	pop af					; restore a - 1st & 2nd digit						;7eb7	f1
 665  7EB8 CB 3F        	srl a					; right shift a 4 times 							;7eb8	cb 3f
 666  7EBA CB 3F        	srl a																		;7eba	cb 3f
 667  7EBC CB 3F        	srl a																		;7ebc	cb 3f
 668  7EBE CB 3F        	srl a					; a has 1rd digit on 4 lower bits					;7ebe	cb 3f
 669  7EC0 CD F1 7E     	call DIGIT_TO_SPRITE	; convert digit to sprite and set b,c				;7ec0	cd f1 7e
 670  7EC3 CD D7 7E     	call SHIFT_SPRITE_1PX	; shift sprite 1 px right							;7ec3	cd d7 7e
 671  7EC6 CD D7 7E     	call SHIFT_SPRITE_1PX	; shift sprite 1 px right once more					;7ec6	cd d7 7e
 672  7EC9 CD D7 7E     	call SHIFT_SPRITE_1PX	; shift sprite 1 px right (3px total)				;7ec9	cd d7 7e
 673  7ECC 21 4C 77     	ld hl,VRAM+(58*32)+12   ; screen coord (48,58)px [$774c]					;7ecc	21 4c 77
 674  7ECF DD 21 30 78  	ld ix,SPR_BUF_DIGIT	; converted sprite										;7ecf	dd 21 30 78
 675  7ED3 CD 71 7F     	call DRAW_SPRITE		; draw 1st digit									;7ed3	cd 71 7f
 676  7ED6 C9           	ret						; --------- End of Proc	-------------------			;7ed6	c9
 677  7ED7
 678  7ED7              ;**************************************************************************************
 679  7ED7              ; Shift right sprite bits by 2 bits (1px) used to correct screen position of score digits
 680  7ED7              SHIFT_SPRITE_1PX:
 681  7ED7 21 30 78     	ld hl,SPR_BUF_DIGIT		; address of digit sprite buffer					;7ed7	21 30 78
 682  7EDA 06 05        	ld b,5					; 5 lines - sprite height							;7eda	06 05
 683  7EDC              S_SHIFT_LINE:
 684  7EDC 0E 02        	ld c,2					; shift by 2 bits in byte (1px)						;7edc	0e 02
 685  7EDE              S_SHIFT_WORD:
 686  7EDE 37           	scf						; set CY flag (to have 7 bit = 1 [Red])				;7ede	37
 687  7EDF CB 1E        	rr (hl)					; rotate right byte in buffer						;7edf	cb 1e
 688  7EE1 23           	inc hl					; next byte in this screen line						;7ee1	23
 689  7EE2 CB 1E        	rr (hl)					; rotate right (with bit from prev)					;7ee2	cb 1e
 690  7EE4 2B           	dec hl					; back to previous byte								;7ee4	2b
 691  7EE5 0D           	dec c					; check if already shfted by 2 bits					;7ee5	0d
 692  7EE6 20 F6        	jr nz,S_SHIFT_WORD		; no - repeat one more time							;7ee6	20 f6
 693  7EE8 23           	inc hl					; inc pointer in buffer	to next line				;7ee8	23
 694  7EE9 23           	inc hl					; ... by 2 bytes (sprite width)						;7ee9	23
 695  7EEA 10 F0        	djnz S_SHIFT_LINE		; repeat for all 5 lines							;7eea	10 f0
 696  7EEC              ; -- restore b, c to have sprite dimensions
 697  7EEC 06 05        	ld b,5					; 5 lines - sprite height							;7eec	06 05
 698  7EEE 0E 02        	ld c,2					; 2 bytes - sprite width (8px)						;7eee	0e 02
 699  7EF0 C9           	ret						; ---------- End of Proc --------					;7ef0	c9
 700  7EF1
 701  7EF1              ;*******************************************************************************
 702  7EF1              ; Convert one digit (0..9) to sprite
 703  7EF1              ; IN:  a - one digit of score to convert to sprite
 704  7EF1              ; OUT: b - sprite height (lines)
 705  7EF1              ;      c - sprite width (in bytes)
 706  7EF1              ;      [SPR_BUF_DIGIT] - sprite to draw in buffer
 707  7EF1              DIGIT_TO_SPRITE:
 708  7EF1 CB 27        	sla a		        	; a = IN * 2                            			;7ef1	cb 27
 709  7EF3 47           	ld b,a					; b = IN * 2                            			;7ef3	47
 710  7EF4 CB 27        	sla a		        	; a = IN * 4                            			;7ef4	cb 27
 711  7EF6 CB 27        	sla a		        	; a = IN * 8                            			;7ef6	cb 27
 712  7EF8 80           	add a,b					; a = IN * 10                           			;7ef8	80
 713  7EF9 4F           	ld c,a					; c = IN * 10                           			;7ef9	4f
 714  7EFA 06 00        	ld b,0		        	; bc = IN * 10                          			;7efa	06 00
 715  7EFC 21 0D 7F     	ld hl,TAB_DIGIT_SPRITES	; hl - start of sprites table   					;7efc	21 0d 7f
 716  7EFF 09           	add hl,bc				; hl - address of sprite for this digit				;7eff	09
 717  7F00 01 0A 00     	ld bc,10				; every sprite has 10 bytes data        			;7f00	01 0a 00
 718  7F03 11 30 78     	ld de,SPR_BUF_DIGIT  ; buffer for sprite	        						;7f03	11 30 78
 719  7F06 ED B0        	ldir		        	; copy 10 bytes of sprite to buffer     			;7f06	ed b0
 720  7F08 06 05        	ld b,5		        	; 5 lines - sprite height               			;7f08	06 05
 721  7F0A 0E 02        	ld c,2  				; 2 bytes (8px) - sprite width          			;7f0a	0e 02
 722  7F0C C9           	ret						; ------- End of Proc ------------------------		;7f0c	c9
 723  7F0D
 724  7F0D              ;*******************************************************************************************
 725  7F0D              ; Sprites Table for Digits
 726  7F0D              ; Containts 10 sprites form every digit. Every sprite has dimension (8x5)px (2x5)bytes
 727  7F0D              TAB_DIGIT_SPRITES:
 728  7F0D              ; -- 0 --
 729  7F0D 55 7F            defb    $55,$7f         ;7f0d	55 7f
 730  7F0F 7F 7F        	defb    $7f,$7f			;7f0f	7f 7f
 731  7F11 7F 7F        	defb    $7f,$7f         ;7f11	7f 7f
 732  7F13 7F 7F        	defb    $7f,$7f			;7f13	7f 7f
 733  7F15 55 7F        	defb    $55,$7f			;7f15	55 7f
 734  7F17              ; -- 1 --
 735  7F17 FF 7F            defb    $ff,$7f			;7f17	ff 7f
 736  7F19 FF 7F        	defb    $ff,$7f			;7f19	ff 7f
 737  7F1B FF 7F        	defb    $ff,$7f			;7f1b	ff 7f
 738  7F1D FF 7F        	defb    $ff,$7f         ;7f1d	ff 7f
 739  7F1F FF 7F        	defb    $ff,$7f         ;7f1f	ff 7f
 740  7F21              ; -- 2 --
 741  7F21 55 7F        	defb    $55,$7f			;7f21	55 7f
 742  7F23 FF 7F        	defb    $ff,$7f         ;7f23	ff 7f
 743  7F25 55 7F        	defb    $55,$7f			;7f25	55 7f
 744  7F27 7F FF        	defb    $7f,$ff			;7f27	7f ff
 745  7F29 55 7F        	defb    $55,$7f			;7f29	55 7f
 746  7F2B              ; -- 3 --
 747  7F2B 55 7F        	defb    $55,$7f			;7f2b	55 7f
 748  7F2D FF 7F        	defb    $ff,$7f     	;7f2d	ff 7f
 749  7F2F 55 7F        	defb    $55,$7f			;7f2f	55 7f
 750  7F31 FF 7F        	defb    $ff,$7f			;7f31	ff 7f
 751  7F33 55 7F        	defb    $55,$7f			;7f33	55 7f
 752  7F35              ; -- 4 --
 753  7F35 7F 7F        	defb    $7f,$7f         ;7f35	7f 7f
 754  7F37 7F 7F        	defb    $7f,$7f			;7f37	7f 7f
 755  7F39 55 7F        	defb    $55,$7f         ;7f39	55 7f
 756  7F3B FF 7F        	defb    $ff,$7f         ;7f3b	ff 7f
 757  7F3D FF 7F        	defb    $ff,$7f         ;7f3d	ff 7f
 758  7F3F              ; -- 5 --
 759  7F3F 55 7F        	defb    $55,$7f         ;7f3f	55 7f
 760  7F41 7F FF        	defb    $7f,$ff         ;7f41	7f ff
 761  7F43 55 7F        	defb    $55,$7f 		;7f43	55 7f
 762  7F45 FF 7F        	defb    $ff,$7f         ;7f45	ff 7f
 763  7F47 55 7F        	defb    $55,$7f         ;7f47	55 7f
 764  7F49              ; -- 6 --
 765  7F49 55 7F        	defb    $55,$7f         ;7f49	55 7f
 766  7F4B 7F FF        	defb    $7f,$ff         ;7f4b	7f ff
 767  7F4D 55 7F        	defb    $55,$7f         ;7f4d	55 7f
 768  7F4F 7F 7F        	defb    $7f,$7f         ;7f4f	7f 7f
 769  7F51 55 7F        	defb    $55,$7f         ;7f51	55 7f
 770  7F53              ; -- 7 --
 771  7F53 55 7F        	defb    $55,$7f         ;7f53	55 7f
 772  7F55 FF 7F        	defb    $ff,$7f         ;7f55	ff 7f
 773  7F57 FF 7F        	defb    $ff,$7f         ;7f57	ff 7f
 774  7F59 FF 7F        	defb    $ff,$7f 		;7f59	ff 7f
 775  7F5B FF 7F        	defb    $ff,$7f 		;7f5b	ff 7f
 776  7F5D              ; -- 8 --
 777  7F5D 55 7F        	defb    $55,$7f         ;7f5d	55 7f
 778  7F5F 7F 7F        	defb    $7f,$7f 		;7f5f	7f 7f
 779  7F61 55 7F        	defb    $55,$7f 		;7f61	55 7f
 780  7F63 7F 7F        	defb    $7f,$7f			;7f63	7f 7f
 781  7F65 55 7F        	defb    $55,$7f         ;7f65	55 7f
 782  7F67              ; -- 9 --
 783  7F67 55 7F        	defb    $55,$7f         ;7f67	aa 7f
 784  7F69 7F 7F        	defb    $7f,$7f			;7f69	7f 7f
 785  7F6B 55 7F        	defb    $55,$7f 		;7f6b	aa 7f
 786  7F6D FF 7F        	defb    $ff,$7f			;7f6d	ff 7f
 787  7F6F FF 7F        	defb    $ff,$7f			;7f6f	ff 7f
 788  7F71
 789  7F71              ;*************************************************************************
 790  7F71              ; Draw sprite to screen
 791  7F71              ; IN: ix - source data address
 792  7F71              ;     hl - destination VRAM address
 793  7F71              ;     c - sprite width (in bytes)
 794  7F71              ;     b - sprite height (in lines)
 795  7F71              DRAW_SPRITE:
 796  7F71 C5           	push bc				; save bc                       						;7f71	c5
 797  7F72 D5           	push de				; save de                       						;7f72	d5
 798  7F73 59           	ld e,c				; e - sprite width (in bytes)      						;7f73	59
 799  7F74              DS_NEXT_LINE:
 800  7F74 4B           	ld c,e				; c - sprite width (in bytes)      						;7f74	4b
 801  7F75 E5           	push hl				; save hl (VRAM of left edge)  							;7f75	e5
 802  7F76              DS_NEXT_BYTE:
 803  7F76 DD 7E 00     	ld a,(ix+000h)		; a - sprite byte data          						;7f76	dd 7e 00
 804  7F79 77           	ld (hl),a			; store to VRAM	                						;7f79	77
 805  7F7A DD 23        	inc ix		        ; next byte of sprite data         						;7f7a	dd 23
 806  7F7C 23           	inc hl				; next VRAM address in this line						;7f7c	23
 807  7F7D 0D           	dec c				; dec bytes counter             						;7f7d	0d
 808  7F7E 20 F6        	jr nz,DS_NEXT_BYTE	; jump if more data in this line						;7f7e	20 f6
 809  7F80 E1           	pop hl				; hl - VRAM of left edge		  						;7f80	e1
 810  7F81 C5           	push bc				; temp save bc                  						;7f81	c5
 811  7F82 01 20 00     	ld bc,32            ; bc - 32 bytes per screen line							;7f82	01 20 00
 812  7F85 09           	add hl,bc			; hl - next line address								;7f85	09
 813  7F86 C1           	pop bc				; restore bc -> b - line counter 						;7f86	c1
 814  7F87 10 EB        	djnz DS_NEXT_LINE	; jump if more lines to copy    						;7f87	10 eb
 815  7F89 D1           	pop de				; restore de                    						;7f89	d1
 816  7F8A C1           	pop bc				; restore bc                   							;7f8a	c1
 817  7F8B C9           	ret					;-------- End of Proc -----------------------			;7f8b	c9
 818  7F8C
 819  7F8C              ;*************************************************************************
 820  7F8C              ; Draw sprite to screen with transparency
 821  7F8C              ; IN: ix - source data address
 822  7F8C              ;     hl - destination VRAM address
 823  7F8C              ;     c - sprite width (in bytes)
 824  7F8C              ;     b - sprite height (in lines)
 825  7F8C
 826  7F8C              DRAW_SPRITE_T:
 827  7F8C C5           	push bc				; save bc   											;7f8c	c5
 828  7F8D D5           	push de				; save de 												;7f8d	d5
 829  7F8E 59           	ld e,c				; e - sprite width  (in bytes)							;7f8e	59
 830  7F8F              DST_NEXT_LINE:
 831  7F8F 4B           	ld c,e				; c - sprite width (in bytes)							;7f8f	4b
 832  7F90 E5           	push hl				; save hl (VRAM of left edge) 							;7f90	e5
 833  7F91              DST_NEXT_BYTE:
 834  7F91 DD 7E 00     	ld a,(ix+000h)		; a - sprite byte data 									;7f91	dd 7e 00
 835  7F94 B6           	or (hl)				; aply current screen data								;7f94	b6
 836  7F95 77           	ld (hl),a			; and save with "or-ed" sprite							;7f95	77
 837  7F96 DD 23        	inc ix				; next byte of sprite data 								;7f96	dd 23
 838  7F98 23           	inc hl				; next VRAM address in this line						;7f98	23
 839  7F99 0D           	dec c				; dec bytes counter 									;7f99	0d
 840  7F9A 20 F5        	jr nz,DST_NEXT_BYTE	; jump if more data in this line						;7f9a	20 f5
 841  7F9C E1           	pop hl				; hl - VRAM of left edge								;7f9c	e1
 842  7F9D C5           	push bc				; temp save bc  										;7f9d	c5
 843  7F9E 01 20 00     	ld bc,32			; bc - 32 bytes per screen line							;7f9e	01 20 00
 844  7FA1 09           	add hl,bc			; hl - next line address								;7fa1	09
 845  7FA2 C1           	pop bc				; restore bc -> b - line counter 						;7fa2	c1
 846  7FA3 10 EA        	djnz DST_NEXT_LINE	; jump if more lines to draw  							;7fa3	10 ea
 847  7FA5 D1           	pop de				; restore de  											;7fa5	d1
 848  7FA6 C1           	pop bc				; restore bc 											;7fa6	c1
 849  7FA7 C9           	ret					;-------- End of Proc ----------------------			;7fa7	c9
 850  7FA8
 851  7FA8              ;***********************************************
 852  7FA8              ; Sprite Ballon Yellow (8x4)px (2x4) bytes
 853  7FA8              SPR_BALOON_YEL:
 854  7FA8 05 50            defb    $05,$50	        ;7fa8	05 50
 855  7FAA 15 54            defb    $15,$54         ;7faa	15 54
 856  7FAC 15 54            defb    $15,$54 		;7fac	15 54
 857  7FAE 05 50        	defb    $05,$50         ;7fae	05 50
 858  7FB0
 859  7FB0              ;***********************************************
 860  7FB0              ; Sprite Baloon Blue (8x4)px (2x4) bytes
 861  7FB0              SPR_BALOON_BLU:
 862  7FB0 0A A0            defb 	$0a,$a0     	;7fb0   0a a0
 863  7FB2 2A A8            defb 	$2a,$a8    		;7fb2	2a a8
 864  7FB4 2A A8        	defb 	$2a,$a8    		;7fb4	2a a8
 865  7FB6 0A A0        	defb 	$0a,$a0			;7fb6	0a a0
 866  7FB8
 867  7FB8              ;***********************************************
 868  7FB8              ; Sprite Baloon Red (8x4)px (2x4) bytes
 869  7FB8              SPR_BALOON_RED:
 870  7FB8 0F F0            defb    $0f,$f0         ;7fb8   0f f0
 871  7FBA 3F FC        	defb    $3f,$fc 		;7fba	3f fc
 872  7FBC 3F FC        	defb    $3f,$fc         ;7fbc	3f fc
 873  7FBE 0F F0        	defb    $0f,$f0			;7fbe	0f f0
 874  7FC0
 875  7FC0              ;**********************************************
 876  7FC0              ; Sprite Stand Left (8x30)px (2x30) bytes
 877  7FC0              SPR_STAND_LEFT:
 878  7FC0 AA AA            defb    $aa,$aa         ;7fc0   aa aa
 879  7FC2 AA AA            defb    $aa,$aa         ;7fc2   aa aa
 880  7FC4 80 20            defb    $80,$20         ;7fc4   80 20
 881  7FC6 80 20            defb    $80,$20         ;7fc6   80 20
 882  7FC8 AA A0            defb    $aa,$a0         ;7fc8   aa a0
 883  7FCA 80 20            defb    $80,$20         ;7fca   80 20
 884  7FCC 80 20            defb    $80,$20         ;7fcc   80 20
 885  7FCE AA A0            defb    $aa,$a0         ;7fce   aa a0
 886  7FD0 80 20            defb    $80,$20         ;7fd0   80 20
 887  7FD2 80 20            defb    $80,$20         ;7fd2   80 20
 888  7FD4 AA A0            defb    $aa,$a0         ;7fd4   aa a0
 889  7FD6 80 20            defb    $80,$20         ;7fd6   80 20
 890  7FD8 80 20            defb    $80,$20         ;7fd8   80 20
 891  7FDA AA A0            defb    $aa,$a0         ;7fda   aa a0
 892  7FDC 80 20            defb    $80,$20         ;7fdc   80 20
 893  7FDE 80 20            defb    $80,$20         ;7fde   80 20
 894  7FE0 AA A0            defb    $aa,$a0         ;7fe0   aa a0
 895  7FE2 80 20            defb    $80,$20         ;7fe2   80 20
 896  7FE4 80 20            defb    $80,$20         ;7fe4   80 20
 897  7FE6 AA A0            defb    $aa,$a0         ;7fe6   aa a0
 898  7FE8 80 20            defb    $80,$20         ;7fe8   80 20
 899  7FEA 80 20            defb    $80,$20         ;7fea   80 20
 900  7FEC AA A0            defb    $aa,$a0         ;7fec   aa a0
 901  7FEE 80 20            defb    $80,$20         ;7fee   80 20
 902  7FF0 80 20            defb    $80,$20         ;7ff0   80 20
 903  7FF2 AA A0            defb    $aa,$a0         ;7ff2   aa a0
 904  7FF4 80 20            defb    $80,$20         ;7ff4   80 20
 905  7FF6 80 20            defb    $80,$20         ;7ff6   80 20
 906  7FF8 AA A0            defb    $aa,$a0         ;7ff8   aa a0
 907  7FFA 80 20            defb    $80,$20         ;7ffa   80 20
 908  7FFC
 909  7FFC              ;**********************************************
 910  7FFC              ; Sprite Stand Right (8x30)px (2x30) bytes
 911  7FFC              SPR_STAND_RIGHT:
 912  7FFC AA AA            defb    $aa,$aa         ;7ffc   aa aa
 913  7FFE AA AA            defb    $aa,$aa         ;7ffe   aa aa
 914  8000 08 02        	defb    $08,$02			;8000	08 02
 915  8002 08 02        	defb    $08,$02			;8002	08 02
 916  8004 0A AA        	defb    $0a,$aa			;8004	0a aa
 917  8006 08 02        	defb    $08,$02			;8006	08 02
 918  8008 08 02        	defb    $08,$02			;8008	08 02
 919  800A 0A AA        	defb    $0a,$aa			;800a	0a aa
 920  800C 08 02        	defb    $08,$02			;800c	08 02
 921  800E 08 02        	defb    $08,$02			;800e	08 02
 922  8010 0A AA        	defb    $0a,$aa			;8010	0a aa
 923  8012 08 02        	defb    $08,$02			;8012	08 02
 924  8014 08 02        	defb    $08,$02			;8014	08 02
 925  8016 0A AA        	defb    $0a,$aa			;8016	0a aa
 926  8018 08 02        	defb    $08,$02			;8018	08 02
 927  801A 08 02        	defb    $08,$02			;801a	08 02
 928  801C 0A AA        	defb    $0a,$aa			;801c	0a aa
 929  801E 08 02        	defb    $08,$02			;801e	08 02
 930  8020 08 02        	defb    $08,$02			;8020	08 02
 931  8022 0A AA        	defb    $0a,$aa			;8022	0a aa
 932  8024 08 02        	defb    $08,$02			;8024	08 02
 933  8026 08 02        	defb    $08,$02			;8026	08 02
 934  8028 0A AA        	defb    $0a,$aa			;8028	0a aa
 935  802A 08 02        	defb    $08,$02			;802a	08 02
 936  802C 08 02        	defb    $08,$02			;802c	08 02
 937  802E 0A AA        	defb    $0a,$aa			;802e	0a aa
 938  8030 08 02        	defb    $08,$02			;8030	08 02
 939  8032 08 02        	defb    $08,$02			;8032	08 02
 940  8034 0A AA        	defb    $0a,$aa			;8034	0a aa
 941  8036 08 02        	defb    $08,$02			;8036	08 02
 942  8038
 943  8038              ;**********************************************************
 944  8038              ; Sprite Player Unit 28x8px (7x8)bytes - base variant (not shifted)
 945  8038              SPR_PLAYER_S0:
 946  8038 A8 00 00 00  	defb    $a8,$00,$00,$00,$00,$00,$00     ;8038	a8 00 00 00 00 00 00
 946  803C 00 00 00
 947  803F 02 A0 00 00      defb    $02,$a0,$00,$00,$00,$00,$00     ;803f	02 a0 00 00 00 00 00
 947  8043 00 00 00
 948  8046 00 0A 80 00  	defb    $00,$0a,$80,$00,$00,$00,$00		;8046	00 0a 80 00 00 00 00
 948  804A 00 00 00
 949  804D 00 00 2A 00  	defb    $00,$00,$2a,$00,$00,$00,$00     ;804d	00 00 2a 00 00 00 00
 949  8051 00 00 00
 950  8054 00 00 00 A8  	defb    $00,$00,$00,$a8,$00,$00,$00		;8054	00 00 00 a8 00 00 00
 950  8058 00 00 00
 951  805B 00 00 0A A2      defb    $00,$00,$0a,$a2,$a0,$00,$00     ;805b	00 00 0a a2 a0 00 00
 951  805F A0 00 00
 952  8062 00 00 AA AA  	defb    $00,$00,$aa,$aa,$0a,$80,$00     ;8062	00 00 aa aa 0a 80 00
 952  8066 0A 80 00
 953  8069 00 0A AA AA      defb    $00,$0a,$aa,$aa,$a0,$2a,$00     ;8069	00 0a aa aa a0 2a 00
 953  806D A0 2A 00
 954  8070
 955  8070              ;**********************************************************
 956  8070              ; Sprite Player Unit 28x8px (7x8)bytes - variant 1 - shifted 1px right
 957  8070              SPR_PLAYER_S1
 958  8070 2A 00 00 00  	defb 	$2a,$00,$00,$00,$00,$00,$00		;8070	2a 00 00 00 00 00 00
 958  8074 00 00 00
 959  8077 00 A8 00 00  	defb	$00,$a8,$00,$00,$00,$00,$00		;8077	00 a8 00 00 00 00 00
 959  807B 00 00 00
 960  807E 00 02 A0 00  	defb	$00,$02,$a0,$00,$00,$00,$00		;807e	00 02 a0 00 00 00 00
 960  8082 00 00 00
 961  8085 00 00 0A 80  	defb	$00,$00,$0a,$80,$00,$00,$00		;8085	00 00 0a 80 00 00 00
 961  8089 00 00 00
 962  808C 00 00 00 2A  	defb	$00,$00,$00,$2a,$00,$00,$00		;808c	00 00 00 2a 00 00 00
 962  8090 00 00 00
 963  8093 00 00 02 A8  	defb	$00,$00,$02,$a8,$a8,$00,$00		;8093	00 00 02 a8 a8 00 00
 963  8097 A8 00 00
 964  809A 00 00 2A AA  	defb	$00,$00,$2a,$aa,$82,$a0,$00		;809a	00 00 2a aa 82 a0 00
 964  809E 82 A0 00
 965  80A1 00 02 AA AA  	defb	$00,$02,$aa,$aa,$a8,$0a,$80		;80a1	00 02 aa aa a8 0a 80
 965  80A5 A8 0A 80
 966  80A8
 967  80A8              ;**********************************************************
 968  80A8              ; Sprite Player Unit 28x8px (7x8)bytes - variant 2 - shifted 2px right
 969  80A8              SPR_PLAYER_S2
 970  80A8 0A 80 00 00  	defb	$0a,$80,$00,$00,$00,$00,$00		;80a8	0a 80 00 00 00 00 00
 970  80AC 00 00 00
 971  80AF 00 2A 00 00  	defb 	$00,$2a,$00,$00,$00,$00,$00		;80af	00 2a 00 00 00 00 00
 971  80B3 00 00 00
 972  80B6 00 00 A8 00  	defb	$00,$00,$a8,$00,$00,$00,$00		;80b6	00 00 a8 00 00 00 00
 972  80BA 00 00 00
 973  80BD 00 00 02 A0  	defb	$00,$00,$02,$a0,$00,$00,$00		;80bd	00 00 02 a0 00 00 00
 973  80C1 00 00 00
 974  80C4 00 00 00 0A  	defb	$00,$00,$00,$0a,$80,$00,$00		;80c4	00 00 00 0a 80 00 00
 974  80C8 80 00 00
 975  80CB 00 00 00 AA  	defb	$00,$00,$00,$aa,$2a,$00,$00		;80cb	00 00 00 aa 2a 00 00
 975  80CF 2A 00 00
 976  80D2 00 00 0A AA  	defb 	$00,$00,$0a,$aa,$a0,$a8,$00		;80d2	00 00 0a aa a0 a8 00
 976  80D6 A0 A8 00
 977  80D9 00 00 AA AA  	defb	$00,$00,$aa,$aa,$aa,$02,$a0		;80d9	00 00 aa aa aa 02 a0
 977  80DD AA 02 A0
 978  80E0
 979  80E0              ;**********************************************************
 980  80E0              ; Sprite Player Unit 28x8px (7x8)bytes - variant 3 - shifted 3px right
 981  80E0              SPR_PLAYER_S3
 982  80E0 02 A0 00 00  	defb	$02,$a0,$00,$00,$00,$00,$00		;80e0	02 a0 00 00 00 00 00
 982  80E4 00 00 00
 983  80E7 00 0A 80 00  	defb	$00,$0a,$80,$00,$00,$00,$00		;80e7	00 0a 80 00 00 00 00
 983  80EB 00 00 00
 984  80EE 00 00 2A 00  	defb	$00,$00,$2a,$00,$00,$00,$00		;80ee	00 00 2a 00 00 00 00
 984  80F2 00 00 00
 985  80F5 00 00 00 A8  	defb	$00,$00,$00,$a8,$00,$00,$00		;80f5	00 00 00 a8 00 00 00
 985  80F9 00 00 00
 986  80FC 00 00 00 02  	defb	$00,$00,$00,$02,$a0,$00,$00		;80fc	00 00 00 02 a0 00 00
 986  8100 A0 00 00
 987  8103 00 00 00 2A  	defb	$00,$00,$00,$2a,$8a,$80,$00		;8103	00 00 00 2a 8a 80 00
 987  8107 8A 80 00
 988  810A 00 00 02 AA  	defb	$00,$00,$02,$aa,$a8,$2a,$00		;810a	00 00 02 aa a8 2a 00
 988  810E A8 2A 00
 989  8111 00 00 2A AA  	defb	$00,$00,$2a,$aa,$aa,$80,$a8		;8111	00 00 2a aa aa 80 a8
 989  8115 AA 80 A8
 990  8118
 991  8118              ;***********************************************************
 992  8118              ; Sprite Life Icon (Man) (8x7) px (2x7 bytes)
 993  8118              ; Used to draw Life Counter
 994  8118              SPR_LIFE_ICON:
 995  8118 F5 7F        	defb    $f5,$7f         ;8118	5f 7f
 996  811A F5 7F            defb    $f5,$7f         ;811a	f5 7f
 997  811C 7D F7        	defb    $7d,$f7			;811c	7d f7
 998  811E D5 5F        	defb    $d5,$5f         ;811e	d5 5f
 999  8120 F5 7F        	defb    $f5,$7f			;8120	f5 7f
1000  8122 F7 7F        	defb    $f7,$7f 		;8122	f7 7f
1001  8124 D7 5F        	defb    $d7,$5f         ;8124	d7 5f
1002  8126
1003  8126              ;***********************************************************
1004  8126              ; Sprite JUMPER (12x7) px (3x7) bytes - base variant (not shifted)
1005  8126              SPR_JUMPER_S0:
1006  8126 05 40 00     	defb	$05,$40,$00		;8126	05 40 00
1007  8129 05 40 00     	defb 	$05,$40,$00		;8129	05 40 00
1008  812C 41 04 00     	defb	$41,$04,$00		;812c	41 04 00
1009  812F 15 50 00     	defb	$15,$50,$00		;812f	15 50 00
1010  8132 05 40 00     	defb	$05,$40,$00		;8132	05 40 00
1011  8135 04 40 00     	defb	$04,$40,$00		;8135	04 40 00
1012  8138 14 50 00     	defb	$14,$50,$00		;8138	14 50 00
1013  813B
1014  813B              ;*******************************************************************
1015  813B              ; Sprite Jumping Man 1 (12x7) px (3x7) bytes - variant shifted 1px right
1016  813B
1017  813B              SPR_JUMPER_S1:
1018  813B 01 50 00     	defb	$01,$50,$00		;813b	01 50 00
1019  813E 01 50 00     	defb	$01,$50,$00		;813e	01 50 00
1020  8141 10 41 00     	defb 	$10,$41,$00		;8141	10 41 00
1021  8144 05 54 00     	defb	$05,$54,$00		;8144	05 54 00
1022  8147 01 50 00     	defb	$01,$50,$00		;8147	01 50 00
1023  814A 01 10 00     	defb	$01,$10,$00		;814a	01 10 00
1024  814D 05 14 00     	defb	$05,$14,$00		;814d	05 14 00
1025  8150
1026  8150              ;*******************************************************************
1027  8150              ; Sprite Jumping Man (12x7) px (3x7) bytes - variant shifted 2px right
1028  8150              SPR_JUMPER_S2
1029  8150 00 54 00     	defb	$00,$54,$00		;8150	00 54 00
1030  8153 00 54 00     	defb	$00,$54,$00		;8153	00 54 00
1031  8156 04 10 40     	defb	$04,$10,$40		;8156	04 10 40
1032  8159 01 55 00     	defb	$01,$55,$00		;8159	01 55 00
1033  815C 00 54 00     	defb	$00,$54,$00		;815c	00 54 00
1034  815F 00 44 00     	defb	$00,$44,$00		;815f	00 44 00
1035  8162 01 45 00     	defb	$01,$45,$00		;8162	01 45 00
1036  8165
1037  8165              ;*******************************************************************
1038  8165              ; Sprite Jumping Man (12x7) px (3x7) bytes - variant shifted 3px right
1039  8165              SPR_JUMPER_S3
1040  8165 00 15 00     	defb	$00,$15,$00		;8165	00 15 00
1041  8168 00 15 00     	defb	$00,$15,$00		;8168	00 15 00
1042  816B 01 04 10     	defb	$01,$04,$10		;816b	01 04 10
1043  816E 00 55 40     	defb	$00,$55,$40		;816e	00 55 40
1044  8171 00 15 00     	defb	$00,$15,$00		;8171	00 15 00
1045  8174 00 11 00     	defb	$00,$11,$00		;8174	00 11 00
1046  8177 00 51 40     	defb	$00,$51,$40		;8177	00 51 40
1047  817A
1048  817A              ;***********************************************************
1049  817A              ; Sprite Jumping Man Mask (12x7) px (3x7) bytes - base variant
1050  817A              SPR_JUMPER_S0_MASK:
1051  817A F0 3F FF     	defb	$f0,$3f,$ff		;817a	f0 3f ff
1052  817D F0 3F FF     	defb	$f0,$3f,$ff		;817d	f0 3f ff
1053  8180 3C F3 FF     	defb	$3c,$f3,$ff		;8180	3c f3 ff
1054  8183 C0 0F FF     	defb	$c0,$0f,$ff		;8183	c0 0f ff
1055  8186 F0 3F FF     	defb	$f0,$3f,$ff		;8186	f0 3f ff
1056  8189 F3 3F FF     	defb	$f3,$3f,$ff		;8189	f3 3f ff
1057  818C C3 0F FF     	defb	$c3,$0f,$ff		;818c	c3 0f ff
1058  818F
1059  818F              ;***********************************************************
1060  818F              ; Sprite Jumping Man Mask (12x7) px (3x7) bytes - variant shifted 1px right
1061  818F              SPR_JUMPER_S1_MASK:
1062  818F FC 0F FF     	defb	$fc,$0f,$ff		;818f	fc 0f ff
1063  8192 FC 0F FF     	defb	$fc,$0f,$ff		;8192	fc 0f ff
1064  8195 CF 3C FF     	defb	$cf,$3c,$ff		;8195	cf 3c ff
1065  8198 F0 03 FF     	defb	$f0,$03,$ff		;8198	f0 03 ff
1066  819B FC 0F FF     	defb	$fc,$0f,$ff		;819b	fc 0f ff
1067  819E FC CF FF     	defb	$fc,$cf,$ff		;819e	fc cf ff
1068  81A1 F0 C3 FF     	defb	$f0,$c3,$ff		;81a1	f0 c3 ff
1069  81A4
1070  81A4              ;***********************************************************
1071  81A4              ; Sprite Jumping Man Mask (12x7) px (3x7) bytes - variant shifted 2px right
1072  81A4              SPR_JUMPER_S2_MASK:
1073  81A4 FF 03 FF     	defb	$ff,$03,$ff		;81a4	ff 03 ff
1074  81A7 FF 03 FF     	defb	$ff,$03,$ff		;81a7	ff 03 ff
1075  81AA F3 CF 3F     	defb	$f3,$cf,$3f		;81aa	f3 cf 3f
1076  81AD FC 00 FF     	defb	$fc,$00,$ff		;81ad	fc 00 ff
1077  81B0 FF 03 FF     	defb	$ff,$03,$ff		;81b0	ff 03 ff
1078  81B3 FF 33 FF     	defb	$ff,$33,$ff		;81b3	ff 33 ff
1079  81B6 FC 30 FF     	defb	$fc,$30,$ff		;81b6	fc 30 ff
1080  81B9
1081  81B9              ;***********************************************************
1082  81B9              ; Sprite Jumping Man Mask (12x7) px (3x7) bytes - variant shifted 3px right
1083  81B9              SPR_JUMPER_S3_MASK:
1084  81B9 FF C0 FF     	defb	$ff,$c0,$ff		;81b9	ff c0 ff
1085  81BC FF C0 FF     	defb	$ff,$c0,$ff		;81bc	ff c0 ff
1086  81BF FC F3 CF     	defb	$fc,$f3,$cf		;81bf	fc f3 cf
1087  81C2 FF 00 3F     	defb	$ff,$00,$3f		;81c2	ff 00 3f
1088  81C5 FF C0 FF     	defb	$ff,$c0,$ff		;81c5	ff c0 ff
1089  81C8 FF CC FF     	defb	$ff,$cc,$ff		;81c8	ff cc ff
1090  81CB FF 0C 3F     	defb	$ff,$0c,$3f		;81cb	ff 0c 3f
1091  81CE
1092  81CE
1093  81CE              ;**********************************************************
1094  81CE              ; Player Unit Sprite 28x8px (7x8)bytes - flipped Bar - base variant
1095  81CE              SPR_PLAYER_FB_S0:
1096  81CE 00 00 00 00  	defb	$00,$00,$00,$00,$00,$2a,$00		;81ce	00 00 00 00 00 2a 00
1096  81D2 00 2A 00
1097  81D5 00 00 00 00  	defb	$00,$00,$00,$00,$0a,$80,$00		;81d5	00 00 00 00 0a 80 00
1097  81D9 0A 80 00
1098  81DC 00 00 00 02  	defb	$00,$00,$00,$02,$a0,$00,$00		;81dc	00 00 00 02 a0 00 00
1098  81E0 A0 00 00
1099  81E3 00 00 00 A8  	defb	$00,$00,$00,$a8,$00,$00,$00		;81e3	00 00 00 a8 00 00 00
1099  81E7 00 00 00
1100  81EA 00 00 2A 00  	defb	$00,$00,$2a,$00,$00,$00,$00		;81ea	00 00 2a 00 00 00 00
1100  81EE 00 00 00
1101  81F1 00 0A 8A A0  	defb	$00,$0a,$8a,$a0,$00,$00,$00		;81f1	00 0a 8a a0 00 00 00
1101  81F5 00 00 00
1102  81F8 02 A0 AA AA  	defb	$02,$a0,$aa,$aa,$00,$00,$00		;81f8	02 a0 aa aa 00 00 00
1102  81FC 00 00 00
1103  81FF A8 0A AA AA  	defb	$a8,$0a,$aa,$aa,$a0,$00,$00		;81ff	a8 0a aa aa a0 00 00
1103  8203 A0 00 00
1104  8206
1105  8206              ;**********************************************************
1106  8206              ; Player Unit Sprite 28x8px (7x8)bytes - flipped Bar - variant 1 - shifted 1px right
1107  8206              SPR_PLAYER_FB_S1:
1108  8206 00 00 00 00  	defb	$00,$00,$00,$00,$00,$0a,$80		;8206	00 00 00 00 00 0a 80
1108  820A 00 0A 80
1109  820D 00 00 00 00  	defb	$00,$00,$00,$00,$02,$a0,$00		;820d	00 00 00 00 02 a0 00
1109  8211 02 A0 00
1110  8214 00 00 00 00  	defb	$00,$00,$00,$00,$a8,$00,$00		;8214	00 00 00 00 a8 00 00
1110  8218 A8 00 00
1111  821B 00 00 00 2A  	defb	$00,$00,$00,$2a,$00,$00,$00		;821b	00 00 00 2a 00 00 00
1111  821F 00 00 00
1112  8222 00 00 0A 80  	defb	$00,$00,$0a,$80,$00,$00,$00		;8222	00 00 0a 80 00 00 00
1112  8226 00 00 00
1113  8229 00 02 A2 A8  	defb	$00,$02,$a2,$a8,$00,$00,$00		;8229	00 02 a2 a8 00 00 00
1113  822D 00 00 00
1114  8230 00 A8 2A AA  	defb	$00,$a8,$2a,$aa,$80,$00,$00		;8230	00 a8 2a aa 80 00 00
1114  8234 80 00 00
1115  8237 2A 02 AA AA  	defb	$2a,$02,$aa,$aa,$a8,$00,$00		;8237	2a 02 aa aa a8 00 00
1115  823B A8 00 00
1116  823E
1117  823E              ;**********************************************************
1118  823E              ; Player Unit Sprite 28x8px (7x8)bytes - flipped Bar - variant 2 - shifted 2px right
1119  823E              SPR_PLAYER_FB_S2:
1120  823E 00 00 00 00  	defb	$00,$00,$00,$00,$00,$02,$a0		;823e	00 00 00 00 00 02 a0
1120  8242 00 02 A0
1121  8245 00 00 00 00  	defb	$00,$00,$00,$00,$00,$a8,$00		;8245	00 00 00 00 00 a8 00
1121  8249 00 A8 00
1122  824C 00 00 00 00  	defb	$00,$00,$00,$00,$2a,$00,$00		;824c	00 00 00 00 2a 00 00
1122  8250 2A 00 00
1123  8253 00 00 00 0A  	defb	$00,$00,$00,$0a,$80,$00,$00		;8253	00 00 00 0a 80 00 00
1123  8257 80 00 00
1124  825A 00 00 02 A0  	defb	$00,$00,$02,$a0,$00,$00,$00		;825a	00 00 02 a0 00 00 00
1124  825E 00 00 00
1125  8261 00 00 A8 AA  	defb	$00,$00,$a8,$aa,$00,$00,$00		;8261	00 00 a8 aa 00 00 00
1125  8265 00 00 00
1126  8268 00 2A 0A AA  	defb	$00,$2a,$0a,$aa,$a0,$00,$00		;8268	00 2a 0a aa a0 00 00
1126  826C A0 00 00
1127  826F 0A 80 AA AA  	defb	$0a,$80,$aa,$aa,$aa,$00,$00		;826f	0a 80 aa aa aa 00 00
1127  8273 AA 00 00
1128  8276
1129  8276              ;**********************************************************
1130  8276              ; Player Unit Sprite 28x8px (7x8)bytes - flipped Bar - variant 3 - shifted 3px right
1131  8276              SPR_PLAYER_FB_S3:
1132  8276 00 00 00 00  	defb	$00,$00,$00,$00,$00,$00,$a8		;8276	00 00 00 00 00 00 a8
1132  827A 00 00 A8
1133  827D 00 00 00 00  	defb	$00,$00,$00,$00,$00,$2a,$00		;827d	00 00 00 00 00 2a 00
1133  8281 00 2A 00
1134  8284 00 00 00 00  	defb	$00,$00,$00,$00,$0a,$80,$00		;8286	00 00 00 00 0a 80 00
1134  8288 0A 80 00
1135  828B 00 00 00 02  	defb	$00,$00,$00,$02,$a0,$00,$00		;828b	00 00 00 02 a0 00 00
1135  828F A0 00 00
1136  8292 00 00 00 A8  	defb 	$00,$00,$00,$a8,$00,$00,$00		;8292	00 00 00 a8 00 00 00
1136  8296 00 00 00
1137  8299 00 00 2A 2A  	defb	$00,$00,$2a,$2a,$80,$00,$00		;8299	00 00 2a 2a 80 00 00
1137  829D 80 00 00
1138  82A0 00 0A 82 AA  	defb 	$00,$0a,$82,$aa,$a8,$00,$00		;82a0	00 0a 82 aa a8 00 00
1138  82A4 A8 00 00
1139  82A7 02 A0 2A AA  	defb	$02,$a0,$2a,$aa,$aa,$80,$00		;82a7	02 a0 2a aa aa 80 00
1139  82AB AA 80 00
1140  82AE
1141  82AE              ;****************************************************************************
1142  82AE              ;
1143  82AE              ; Game interrupt proc - Game Main variant
1144  82AE              ;
1145  82AE              ; In Demo Mode just checks if any key/joystick event occured. If so switch to Running and exit.
1146  82AE              ; In Running mode or in Demo with no input detected, executes Frame Update routines
1147  82AE              ;
1148  82AE              ;*****************************************************************************
1149  82AE              INT_GAME_MAIN:
1150  82AE DD E5        	push ix					; save ix 											;82ae	dd e5
1151  82B0 3A 2F 78     	ld a,(GAME_MODE)		; a - Game Mode										;82b0	3a 2f 78
1152  82B3 B7           	or a					; check if Running									;82b3	b7
1153  82B4 28 2D        	jr z,GIH_FRAME_UPDATE	; yes - continue Frame Update						;82b4	28 2d
1154  82B6
1155  82B6              ; -- Game in Demo Mode - check key/joystick to stop demo and start Game
1156  82B6 3A 12 78     	ld a,(INPUT_FLAG)		; input mode Keyboard/Joystick						;82b6	3a 12 78
1157  82B9 B7           	or a					; is Keyboard ?										;82b9	b7
1158  82BA 28 06        	jr z,GIH_CHECK_KEYS		; yes - check key pressed							;82ba	28 06
1159  82BC
1160  82BC              ; -- check joystick button
1161  82BC DB 20        	in a,(JOY_FIRE_PORT)	; read joystick port								;82bc	db 20
1162  82BE CB 67        	bit 4,a					; is button pressed ?								;82be	cb 67
1163  82C0 28 08        	jr z,INT_EXIT_RUN		; yes - set Running and Exit						;82c0	28 08
1164  82C2
1165  82C2              ; -- check if any key pressed
1166  82C2              GIH_CHECK_KEYS:
1167  82C2 3A 00 68     	ld a,(KEYB_PORT)		; read all keys										;82c2	3a 00 68
1168  82C5 2F           	cpl						; inverse logic (key press sets bit)				;82c5	2f
1169  82C6 E6 3F        	and $3f					; any key pressed ?									;82c6	e6 3f
1170  82C8 28 19        	jr z,GIH_FRAME_UPDATE	; no - continue Frame Update						;82c8	28 19
1171  82CA              INT_EXIT_RUN:
1172  82CA AF           	xor a					; 0 - Game Mode Running								;82ca	af
1173  82CB 32 2F 78     	ld (GAME_MODE),a		; turn off Demo Mode								;82cb	32 2f 78
1174  82CE              ;-- clean up stack pointer (set by System INT handler)
1175  82CE DD E1        	pop ix					; restore ix										;82ce	dd e1
1176  82D0 E1           	pop hl					; clean return address								;82d0	e1
1177  82D1 E1           	pop hl					; restore hl										;82d1	e1
1178  82D2 D1           	pop de					; restore de										;82d2	d1
1179  82D3 C1           	pop bc					; restore bc										;82d3	c1
1180  82D4 F1           	pop af					; restore af										;82d4	f1
1181  82D5 21 D9 7B     	ld hl,GAME_INIT			; GAME_INIT address 								;82d5	21 d9 7b
1182  82D8 E5           	push hl					; set as return from INT address					;82d8	e5
1183  82D9              ; -- delay
1184  82D9 01 FF FF     	ld bc,0ffffh			; delay counter										;82d9	01 ff ff
1185  82DC              GTH_DELAY:
1186  82DC 0B           	dec bc					; decrement counter									;82dc	0b
1187  82DD 78           	ld a,b					; check if 0										;82dd	78
1188  82DE B1           	or c					; a = b|c											;82de	b1
1189  82DF 20 FB        	jr nz,GTH_DELAY			; repeat until 0									;82df	20 fb
1190  82E1 ED 4D        	reti					; ----------- End of INT Proc -----------			;82e1	ed 4d
1191  82E3
1192  82E3              ; -- Game Frame Update Routines
1193  82E3              GIH_FRAME_UPDATE:
1194  82E3 CD F9 82     	call CLEAR_JUMPER_SPRITES	; clear both JUMPER sprites on screen			;82e3	cd f9 82
1195  82E6 CD 5E 87     	call CHECK_BALOON_COLLISION	; check if any collision for JUMPER and BALOON	;82e6	cd 5e 87
1196  82E9 CD 52 83     	call DRAW_FRAME			; draw sprites at current positions					;82e9	cd 52 83
1197  82EC CD CA 83     	call UPDATE_POSITIONS	; calculate and update new positions for sprites	;82ec	cd ca 83
1198  82EF              INT_EXIT:
1199  82EF DD E1        	pop ix					; restore ix										82ef	dd e1
1200  82F1 E1           	pop hl					; clean return address								82f1	e1
1201  82F2 E1           	pop hl					; restore hl										82f2	e1
1202  82F3 D1           	pop de					; restore de										82f3	d1
1203  82F4 C1           	pop bc					; restore bc										82f4	c1
1204  82F5 F1           	pop af					; restore af										82f5	f1
1205  82F6 FB           	ei						; enable interrupts									82f6	fb
1206  82F7 ED 4D        	reti					; ----------- End of INT Proc -------------------	82f7	ed 4d
1207  82F9
1208  82F9              ;***************************************************************************************
1209  82F9              ; Clear screen areas where were both Jumpers and Player Unit Bar if needed
1210  82F9              CLEAR_JUMPER_SPRITES:
1211  82F9              ; -- clear Player Unit part if needed
1212  82F9 3A 1A 78     	ld a,(BAR_CLEAR_FLAG)	; check flags if 1px need to be clered	 			;82f9	3a 1a 78
1213  82FC B7           	or a					; need update ?										;82fc	b7
1214  82FD 28 14        	jr z,CMS_CLEAR_WAIT_MAN	; 0 - no update needed								;82fd	28 14
1215  82FF
1216  82FF              ; -- clear 1px left from Player Unit - only 1st and 8th line where bar can be
1217  82FF 2A 09 78     	ld hl,(PLAYER_POS_VADR)	; player unit VRAM address - first line				;82ff	2a 09 78
1218  8302 2B           	dec hl					; 1 byte on left									;8302	2b
1219  8303 7E           	ld a,(hl)				; current byte from screen							;8303	7e
1220  8304 E6 FC        	and %11111100			; clear 4th pixel of this byte						;8304	e6 fc
1221  8306 77           	ld (hl),a				; store new value									;8306	77
1222  8307 11 E0 00     	ld de,7*32				; add 7 screen lines - last line of sprite			;8307	11 e0 00
1223  830A 19           	add hl,de				; last line of sprite, 1 byte on left				;830a	19
1224  830B 7E           	ld a,(hl)				; byte from screen									;830b	7e
1225  830C E6 FC        	and %11111100			; clear 4th pixel of this byte						;830c	e6 fc
1226  830E 77           	ld (hl),a				; store new value									;830e	77
1227  830F              ; -- reset update flag
1228  830F AF           	xor a					; 0 - no updates needed  							;830f	af
1229  8310 32 1A 78     	ld (BAR_CLEAR_FLAG),a	; clear update flag									;8310	32 1a 78
1230  8313
1231  8313              ; -- clear 16px - JUMPER Waiting sprite area plus 1 byte (4px) on left side
1232  8313              CMS_CLEAR_WAIT_MAN:
1233  8313 2A 24 78     	ld hl,(JUMPER_W_CLR_VADR); Waiting MAN sprite address						;8313	2a 24 78
1234  8316 2B           	dec hl					; 1 byte to the left								;8316	2b
1235  8317 11 1C 00     	ld de,28				; 28 bytes per screen line (4 bytes in loop)		;8317	11 1c 00
1236  831A AF           	xor a					; clear value - all 4 pixels green (bg)				;831a	af
1237  831B 06 07        	ld b,7					; 7 lines - area height 							;831b	06 07
1238  831D              CMSW_CLEAR_LINE:
1239  831D 0E 04        	ld c,4					; 4 bytes - area width (16px)						;831d	0e 04
1240  831F              CMSW_CLEAR_BYTE:
1241  831F 77           	ld (hl),a				; clear screen byte									;831f	77
1242  8320 23           	inc hl					; next screen address								;8320	23
1243  8321 0D           	dec c					; decrement bytes counter							;8321	0d
1244  8322 20 FB        	jr nz,CMSW_CLEAR_BYTE	; repeat for 4 bytes								;8322	20 fb
1245  8324 19           	add hl,de				; next area line 									;8324	19
1246  8325 10 F6        	djnz CMSW_CLEAR_LINE	; repeat for all 7 lines							;8325	10 f6
1247  8327
1248  8327              ; -- clear JUMPER sprite area on screen using mask to clear only non-transparent pixels
1249  8327 2A 27 78     	ld hl,(JUMPER_CLR_VADR)	; JUMPER sprite address								;8327	2a 27 78
1250  832A 3A 29 78     	ld a,(JUMPER_CLR_X_INT)	; JUMPER position X in pixels						;832a	3a 29 78
1251  832D E5           	push hl					; save hl - sprite screen address					;832d	e5
1252  832E 11 15 00     	ld de,21				; 21 bytes of sprite content						;832e	11 15 00
1253  8331 E6 03        	and $03					; a - pixel in screen byte index 0..3				;8331	e6 03
1254  8333 3C           	inc a					; pixel index 1..4	-> shift needed					;8333	3c
1255  8334 47           	ld b,a					; b - index in sprite variants table				;8334	47
1256  8335 21 65 81     	ld hl,SPR_JUMPER_S0_MASK-21; sprites table -21 (size of one sprite)			;8335	21 65 81
1257  8338              ; -- find mask with required pixels shifted
1258  8338              CMSJ_NEXT_MASK:
1259  8338 19           	add hl,de				; add size of sprite in table						;8338	19
1260  8339 10 FD        	djnz CMSJ_NEXT_MASK		; repeat b times									;8339	10 fd
1261  833B              ; -- clear area using sprite mask
1262  833B EB           	ex de,hl				; de - address of sprite mask 						;833b	eb
1263  833C E1           	pop hl					; hl - sprite screen address						;833c	e1
1264  833D 06 07        	ld b,7					; 7 lines - sprite/area height						;833d	06 07
1265  833F              CMSJ_CLEAR_LINE:
1266  833F 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;833f	0e 03
1267  8341              CMSJ_CLEAR_BYTE:
1268  8341 1A           	ld a,(de)				; a - mask byte										;8341	1a
1269  8342 A6           	and (hl)				; apply mask - clear foreground pixels				;8342	a6
1270  8343 77           	ld (hl),a				; store back byte									;8343	77
1271  8344 23           	inc hl					; next screen byte									;8344	23
1272  8345 13           	inc de					; next mask byte									;8345	13
1273  8346 0D           	dec c					; decrement bytes in line counter					;8346	0d
1274  8347 20 F8        	jr nz,CMSJ_CLEAR_BYTE 	; repeat for all 3 bytes							;8347	20 f8
1275  8349 D5           	push de					; save de											;8349	d5
1276  834A 11 1D 00     	ld de,29				; 29 bytes per line (3 covered in loop)				;834a	11 1d 00
1277  834D 19           	add hl,de				; hl - 1st byte in next line 						;834d	19
1278  834E D1           	pop de					; restore de										;834e	d1
1279  834F 10 EE        	djnz CMSJ_CLEAR_LINE 	; repeat for all 7 lines							;834f	10 ee
1280  8351 C9           	ret						; --------- End Of Proc ----------------			;8351	c9
1281  8352
1282  8352
1283  8352              ;*******************************************************************************************
1284  8352              ; Draws Frame content
1285  8352              ; Baloons, Player and Jumpers will be drawn at current positions
1286  8352              DRAW_FRAME:
1287  8352 3A 05 78     	ld a,(BALOONS_DRAW_NEXT); get Ballons Group to update						;8352	3a 05 78
1288  8355 E6 03        	and $03					; modulo 4 (seq: RED,YEL,BLU,none)					;8355	e6 03
1289  8357 28 0A        	jr z,REDRAW_BALOONS_RED	; 0 - Baloons Group Red								;8357	28 0a
1290  8359 FE 01        	cp 1					; check if Ballons Group Yellow						;8359	fe 01
1291  835B 28 13        	jr z,REDRAW_BALOONS_YEL	; yes - redraw Baloons Group Yellow					;835b	28 13
1292  835D FE 02        	cp 2					; check if Baloons Group Blue						;835d	fe 02
1293  835F 28 1C        	jr z,REDRAW_BALOONS_BLU	; yes - redraw Baloons Group Blue					;835f	28 1c
1294  8361              ; -- redraw counter = 3 - skip drawing Baloons
1295  8361 18 25        	jr REDRAW_PLAYER_N_MEN	; continue redraw player and Jumpers				;8361	18 25
1296  8363
1297  8363              ; -- draw Red Baloons screen part
1298  8363              REDRAW_BALOONS_RED:
1299  8363 21 80 78     	ld hl,SPR_BUF_BALOONS_RED	; src - buffer for Baloons Red (sprite)			;8363	21 80 78
1300  8366 11 20 70     	ld de,VRAM+(1*32)+0		; dst - screen coord (0,1)px [$7020]				;8366	11 20 70
1301  8369 01 80 00     	ld bc,128				; 128 bytes buffer (4 screen lines)					;8369	01 80 00
1302  836C ED B0        	ldir					; copy buffer to screen 							;836c	ed b0
1303  836E 18 18        	jr REDRAW_PLAYER_N_MEN	; continue redraw player and Jumpers sprites		;836e	18 18
1304  8370
1305  8370              ; -- draw Yellow Baloons screen part
1306  8370              REDRAW_BALOONS_YEL:
1307  8370 21 00 79     	ld hl,SPR_BUF_BALOONS_YEL	; src - buffer for Baloons Yellow (sprite)		;8370	21 00 79
1308  8373 11 E0 70     	ld de,VRAM+(7*32)+0		; dst - screen coord (0,7)px [$70e0]				;8373	11 e0 70
1309  8376 01 80 00     	ld bc,128				; 128 bytes buffer (4 screen lines)					;8376	01 80 00
1310  8379 ED B0        	ldir					; copy buffer to screen								;8379	ed b0
1311  837B 18 0B        	jr REDRAW_PLAYER_N_MEN	; continue redraw player and Jumpers sprites		;837b	18 0b
1312  837D
1313  837D              ; -- draw Blue Baloons screen part
1314  837D              REDRAW_BALOONS_BLU:
1315  837D 21 80 79     	ld hl,SPR_BUF_BALOONS_BLU	; src - buffer for Baloons Blue (sprite)		;837d	21 80 79
1316  8380 11 A0 71     	ld de,VRAM+(13*32)+0    ; src - screen coord (0,13)px [$71a0]				;8380	11 a0 71
1317  8383 01 80 00     	ld bc,128				; 128 bytes buffer (4 screen lines)					;8383	01 80 00
1318  8386 ED B0        	ldir					; copy buffer to screen								;8386	ed b0
1319  8388
1320  8388              ; --- continue ... redraw screen - player unit, Jumper W(aiting) and Jumper
1321  8388              REDRAW_PLAYER_N_MEN:
1322  8388 2A 09 78     	ld hl,(PLAYER_POS_VADR)	; current player unit position 						;8388	2a 09 78
1323  838B DD 21 01 7A  	ld ix,SPR_BUF_PLAYER	; sprite from buffer								;838b	dd 21 01 7a
1324  838F 06 08        	ld b,8  				; 8 lines - sprite height               			;838f	06 08
1325  8391 0E 07        	ld c,7  				; 7 bytes (28px) - sprite width         			;8391	0e 07
1326  8393 CD 71 7F     	call DRAW_SPRITE		; draw player unit sprite	            			;8393	cd 71 7f
1327  8396              ; -- draw JUMPER W(aiting) sprite at current position
1328  8396 2A 0B 78     	ld hl,(JUMPER_W_VADR)	; current position on screen						;8396	2a 0b 78
1329  8399 DD 21 39 7A  	ld ix,SPR_BUF_JUMPER_W	; sprite JUMPER_W from buffer (12x7)px				;8399	dd 21 39 7a
1330  839D 06 07        	ld b,7					; 7 lines - sprite height							;839d	06 07
1331  839F 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;839f	0e 03
1332  83A1 CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;83a1	cd 8c 7f  
1333  83A4              ; -- draw JUMPER sprite at current position
1334  83A4 2A 0D 78     	ld hl,(JUMPER_VADR)		; current position on screen						;83a4	2a 0d 78
1335  83A7 DD 21 4E 7A  	ld ix,SPR_BUF_JUMPER	; sprite JUMPER from buffer (12x7)px				;83a7	dd 21 4e 7a
1336  83AB 06 07        	ld b,7					; 7 lines - sprite height							;83ab	06 07
1337  83AD 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;83ad	0e 03
1338  83AF CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;83af	cd 8c 7f
1339  83B2
1340  83B2              ; -- redraw Vertical Stand left and right
1341  83B2              DRAW_STANDS_LR:
1342  83B2              ; -- draw Vertical Stand left on screen
1343  83B2 21 60 73     	ld hl,VRAM+(27*32)+0    ; screen coord 0,27 [$7360] 						;83b2	21 60 73
1344  83B5 DD 21 C0 7F  	ld ix,SPR_STAND_LEFT 	; sprite 8x30px Vertical Stand Left   				;83b5	dd 21 c0 7f
1345  83B9 06 1E        	ld b,30 				; 30 lines - sprite height              			;83b9	06 1e
1346  83BB 0E 02        	ld c,2  				; 2 bytes (8px) - sprite width          			;83bb	0e 02
1347  83BD CD 71 7F     	call DRAW_SPRITE		; draw sprite	                        			;83bd	cd 71 7f
1348  83C0              ; -- draw Vertical Stand right on screen
1349  83C0 21 7E 73     	ld hl,VRAM+(27*32)+30   ; screen coord (120,27)px [$737e]					;83c0	21 7e 73
1350  83C3 DD 21 FC 7F  	ld ix,SPR_STAND_RIGHT	; sprite 8x30px Vertical Right Stand (b,c unchanged);83c3	dd 21 fc 7f
1351  83C7 C3 71 7F     	jp DRAW_SPRITE			; draw sprite and return to caller					;83c7	c3 71 7f
1352  83CA
1353  83CA              ;*******************************************************************************************
1354  83CA              ; Update Positions
1355  83CA              ; Calculate new positions for moving sprites
1356  83CA              UPDATE_POSITIONS:
1357  83CA CD 9A 84     	call UPDATE_PLAYER_POS	; check keys/joystick and move player unit			;83ca	cd 9a 84
1358  83CD CD B4 85     	call UPDATE_JUMPER_POS	; calculate new position for JUMPER					;83cd	cd b4 85
1359  83D0 3A 05 78     	ld a,(BALOONS_DRAW_NEXT)	; get last updated Baloons Group				;83d0	3a 05 78
1360  83D3 3C           	inc a					; next group to update 								;83d3	3c
1361  83D4 32 05 78     	ld (BALOONS_DRAW_NEXT),a; store counter										;83d4	32 05 78
1362  83D7 E6 03        	and $03					; modulo 4 (seq RED,YEL,BLU,none)					;83d7	e6 03
1363  83D9 28 09        	jr z,UPDATE_BALOONS_RED	; 0 - Baloons Group Red								;83d9	28 09
1364  83DB FE 01        	cp 1					; 1 - Baloons Group Yellow							;83db	fe 01
1365  83DD 28 22        	jr z,UPDATE_BALOONS_YEL	; yes - update Baloons Group position				;83dd	28 22
1366  83DF FE 02        	cp 2					; 2 - Baloons Group Blue							;83df	fe 02
1367  83E1 28 3B        	jr z,UPDATE_BALOONS_BLU	; yes - update Baloons Group position				;83e1	28 3b
1368  83E3 C9           	ret						; 3 - none of Groups to update 						;83e3	c9
1369  83E4
1370  83E4              ; --- update Baloons Group Red
1371  83E4              UPDATE_BALOONS_RED:
1372  83E4 3A 06 78     	ld a,(BALOONS_RED_X_FRAC)	; a - Baloons Group position X (px fraction)	;83e4	3a 06 78
1373  83E7 C6 E0        	add a,$e0				; add velocity (7/8 px)								;83e7	c6 e0
1374  83E9 32 06 78     	ld (BALOONS_RED_X_FRAC),a	; store new value								;83e9	32 06 78
1375  83EC D0           	ret nc					; return if pixel pos didn't changed				;83ec	d0
1376  83ED              ; -- Carry = 1 means that sprite needs to be moved by 1px
1377  83ED 11 02 78     	ld de,BALOONS_RED_DIR	; move direction flag for this Baloons				;83ed	11 02 78
1378  83F0 1A           	ld a,(de)				; a - direction flag (0 or $80) 					;83f0	1a
1379  83F1 B7           	or a					; check if 0 (right) 								;83f1	b7
1380  83F2 FA FB 83     	jp m,UBR_MOVE_LEFT		; no - move 1px left 								;83f2	fa fb 83
1381  83F5              ; -- moving sprite right must be started from last byte in line
1382  83F5 21 9F 78     	ld hl,SPR_BUF_BALOONS_RED+31	; last byte of first line 					;83f5	21 9f 78
1383  83F8 C3 3B 84     	jp MOVE_BALOONS_RIGHT	; move sprite 1px right								;83f8	c3 3b 84
1384  83FB              ; -- moving sprite left must be started from first byte in line
1385  83FB              UBR_MOVE_LEFT:
1386  83FB 21 80 78     	ld hl,SPR_BUF_BALOONS_RED	; first byte of first line 						;83fb	21 80 78
1387  83FE C3 6B 84     	jp MOVE_BALOONS_LEFT	; move sprite 1px left								;83fe	c3 6b 84
1388  8401
1389  8401              ; --- update Baloons Group Yellow
1390  8401              UPDATE_BALOONS_YEL:
1391  8401 3A 07 78     	ld a,(BALOONS_YEL_X_FRAC)	; Baloons Group position X (px fraction)		;8401	3a 07 78
1392  8404 C6 80        	add a,$80				; add velocity (1/2 px)								;8404	c6 80
1393  8406 32 07 78     	ld (BALOONS_YEL_X_FRAC),a	; store new value								;8406	32 07 78
1394  8409 D0           	ret nc					; return if pixel pos didn't changed				;8409	d0
1395  840A              ; -- Carry = 1 means that sprite needs to be moved by 1px
1396  840A 11 03 78     	ld de,BALOONS_YEL_DIR	; move direction flag for this Baloons				;840a	11 03 78
1397  840D 1A           	ld a,(de)				; a - direction flag (0 or $80) 					;840d	1a
1398  840E B7           	or a					; check 0 (right) 									;840e	b7
1399  840F FA 18 84     	jp m,UBY_MOVE_LEFT		; no - move 1px left 								;840f	fa 18 84
1400  8412              ; -- moving sprite right must be started from last byte in first line
1401  8412 21 1F 79     	ld hl,SPR_BUF_BALOONS_YEL+31	; last byte of first line 					;8412	21 1f 79
1402  8415 C3 3B 84     	jp MOVE_BALOONS_RIGHT	; move sprite 1px right								;8415	c3 3b 84
1403  8418              ; -- moving sprite left must be started from first byte in first line
1404  8418              UBY_MOVE_LEFT:
1405  8418 21 00 79     	ld hl,SPR_BUF_BALOONS_YEL	; first byte of first line 						;8418	21 00 79
1406  841B C3 6B 84     	jp MOVE_BALOONS_LEFT	; move sprite 1px left								;841b	c3 6b 84
1407  841E
1408  841E              ; --- update Baloons Group Blue
1409  841E              UPDATE_BALOONS_BLU:
1410  841E 3A 08 78     	ld a,(BALOONS_BLU_X_FRAC)	; Baloons Group position X (px fraction)		;841e	3a 08 78
1411  8421 C6 38        	add a,038h				; add velocity (7/32 px)							;8421	c6 38
1412  8423 32 08 78     	ld (BALOONS_BLU_X_FRAC),a	; store new value								;8423	32 08 78
1413  8426 D0           	ret nc					; return if pixel pos didn't changed				;8426	d0
1414  8427              ; -- Carry = 1 means that sprite needs to be moved by 1px
1415  8427 11 04 78     	ld de,BALOONS_BLU_DIR	; move direction flag for this Baloons				;8427	11 04 78
1416  842A 1A           	ld a,(de)				; a - direction flag (0 or $80) 					;842a	1a
1417  842B B7           	or a					; check 0 (right) 									;842b	b7
1418  842C FA 35 84     	jp m,UBB_MOVE_LEFT		; no - move 1px left 								;842c	fa 35 84
1419  842F              ; -- moving sprite right must be started from last byte in first line
1420  842F 21 9F 79     	ld hl,SPR_BUF_BALOONS_BLU+31	; last byte of first line 					;842f	21 9f 79
1421  8432 C3 3B 84     	jp MOVE_BALOONS_RIGHT	; move sprite 1px right								;8432	c3 3b 84
1422  8435              ; -- moving sprite left must be started from first byte in first line
1423  8435              UBB_MOVE_LEFT:
1424  8435 21 80 79     	ld hl,SPR_BUF_BALOONS_BLU	; first byte of first line 						;8435	21 80 79
1425  8438 C3 6B 84     	jp MOVE_BALOONS_LEFT		; move sprite 1px left							;8438	c3 6b 84
1426  843B
1427  843B              ;************************************************************************************
1428  843B              ; Shift Baloons Group offscreen buffer by 1 pixel right
1429  843B              ; IN: de - address of Baloons Group direction variable
1430  843B              ;     hl - points to last byte of first line in Baloons' buffer
1431  843B              MOVE_BALOONS_RIGHT:
1432  843B D5           	push de					; save de											;843b	d5
1433  843C 0E 04        	ld c,4					; 4 lines - sprite height							;843c	0e 04
1434  843E              MBR_NEXT_LINE:
1435  843E E5           	push hl					; save hl - start address in sprite buffer			;843e	e5
1436  843F 06 1F        	ld b,31					; 31 bytes to process (1 screen line)				;843f	06 1f
1437  8441              MBR_NEXT_BYTE:
1438  8441              ; -- read 2 bytes of sprite into de
1439  8441 5E           	ld e,(hl)				; e - byte from buffer (4px)						;8441	5e
1440  8442 2B           	dec hl					; address of previous byte							;8442	2b
1441  8443 56           	ld d,(hl)				; d - prev byte (left side)							;8443	56
1442  8444 23           	inc hl					; restore hl - address of current byte				;8444	23
1443  8445              ; -- shift right sprite byte by 2 bits (1px) with lowest bits form left byte
1444  8445 CB 3A        	srl d					; shift right 1 bit (left byte)						;8445	cb 3a
1445  8447 CB 1B        	rr e					; shift right 1 bit (this byte) with CY				;8447	cb 1b
1446  8449 CB 3A        	srl d					; shift right 1 bit (left byte)						;8449	cb 3a
1447  844B CB 1B        	rr e					; shift right 1 bit (this byte) with CY				;844b	cb 1b
1448  844D              ; -- store sprite byte
1449  844D 73           	ld (hl),e				; store shifted value								;844d	73
1450  844E 2B           	dec hl					; next sprite byte to the left						;844e	2b
1451  844F 10 F0        	djnz MBR_NEXT_BYTE		; repeat for 31 bytes								;844f	10 f0
1452  8451              ; -- first byte must be shifted slightly different way
1453  8451 7E           	ld a,(hl)				; first byte in this line							;8451	7e
1454  8452 CB 3F        	srl a					; shift right 1 bit									;8452	cb 3f
1455  8454 CB 3F        	srl a					; shift right 1 bit (2 bits total - 1px)			;8454	cb 3f
1456  8456 77           	ld (hl),a				; store shifted value								;8456	77
1457  8457 E1           	pop hl					; restore address of last buffer byte				;8457	e1
1458  8458 11 20 00     	ld de,32				; 32 bytes per sprite line							;8458	11 20 00
1459  845B 19           	add hl,de				; hl next sprite line (last byte in line)			;845b	19
1460  845C 0D           	dec c					; dec line counter									;845c	0d
1461  845D 20 DF        	jr nz,MBR_NEXT_LINE		; repeat for all 4 lines							;845d	20 df
1462  845F              ; -- all bytes in sprite buffer are shifted by 2 bits (1px) right
1463  845F B7           	or a					; clear Carry flag									;845f	b7
1464  8460 ED 52        	sbc hl,de				; hl points to first byte in line					;8460	ed 52
1465  8462 D1           	pop de					; de - address of Direction variable				;8462	d1
1466  8463 7E           	ld a,(hl)				; a - 1st byte in line								;8463	7e
1467  8464 E6 0C        	and %00001100			; check 3rd pixel is set							;8464	e6 0c
1468  8466 C8           	ret z					; no - next time we will still shift right			;8466	c8
1469  8467              ; -- 3rd pixel of sprite is set - next time we should shift to the left
1470  8467 3E 80        	ld a,$80				; direction flag - to left							;8467	3e 80
1471  8469 12           	ld (de),a				; store direction flag								;8469	12
1472  846A C9           	ret						; ------------ End Of Proc --------------			;846a	c9
1473  846B
1474  846B              ;************************************************************************************
1475  846B              ; Shift BAloons Group offscreen buffer by 1 pixel left
1476  846B              ; IN: de - address of Baloons Group direction variable
1477  846B              ;     hl - points to first byte of first line in Baloons' buffer
1478  846B              MOVE_BALOONS_LEFT:
1479  846B D5           	push de					; save de											;846b	d5
1480  846C 0E 04        	ld c,4					; 4 lines - sprite height							;846c	0e 04
1481  846E              MBL_NEXT_LINE:
1482  846E E5           	push hl					; save hl - start address in sprite buffer			;846e	e5
1483  846F 06 1F        	ld b,31					; 31 bytes to process (1 screen line)				;846f	06 1f
1484  8471              MBL_NEXT_BYTE:
1485  8471              ; -- read 2 bytes of sprite into de
1486  8471 56           	ld d,(hl)				; d - byte from buffer (4px);						;8471	56
1487  8472 23           	inc hl					; address of next byte								;8472	23
1488  8473 5E           	ld e,(hl)				; e - next byte (right side)						;8473	5e
1489  8474 2B           	dec hl					; restore hl - address of current byte				;8474	2b
1490  8475              ; -- shift left sprite byte by 2 bits (1px) with highest bits form right byte
1491  8475 CB 23        	sla e					; shift left 1 bit (right byte)						;8475	cb 23
1492  8477 CB 12        	rl d					; shift left 1 bit (this byte) with CY				;8477	cb 12
1493  8479 CB 23        	sla e					; shift left 1 bit (right byte)						;8479	cb 23
1494  847B CB 12        	rl d					; shift left 1 bit (this byte) with CY				;847b	cb 12
1495  847D              ; -- store sprite byte
1496  847D 72           	ld (hl),d				; store shifted value								;847d	72
1497  847E 23           	inc hl					; next sprite byte to the right						;847e	23
1498  847F 10 F0        	djnz MBL_NEXT_BYTE		; repeat for 31 bytes								;847f	10 f0
1499  8481              ; -- last byte must be shifted slightly different way
1500  8481 7E           	ld a,(hl)				; last byte in this line							;8481	7e
1501  8482 CB 27        	sla a					; shift left 1 bit									;8482	cb 27
1502  8484 CB 27        	sla a					; shift left 1 bit (2 bits total - 1px)				;8484	cb 27
1503  8486 77           	ld (hl),a				; store shifted value								;8486	77
1504  8487 E1           	pop hl					; restore address of first byte in line				;8487	e1
1505  8488 11 20 00     	ld de,32				; 32 bytes per sprite line							;8488	11 20 00
1506  848B 19           	add hl,de				; hl next sprite line (first byte in line)			;848b	19
1507  848C 0D           	dec c					; dec line counter									;848c	0d
1508  848D 20 DF        	jr nz,MBL_NEXT_LINE		; repeat for all 4 lines							;848d	20 df
1509  848F              ; -- all bytes in sprite buffer are shifted by 2 bits (1px) left
1510  848F B7           	or a					; clear Carry flag									;848f	b7
1511  8490 ED 52        	sbc hl,de				; hl points to first byte of last line				;8490	ed 52
1512  8492 D1           	pop de					; de - address of Direction variable 				;8492	d1
1513  8493 7E           	ld a,(hl)				; a - 1st byte in line								;8493	7e
1514  8494 E6 30        	and %00110000			; check 2nd pixel is set							;8494	e6 30
1515  8496 C8           	ret z					; no - next time we will still shift left 			;8496	c8
1516  8497              ; -- 2nd pixel of sprite is set - next time we should shift to the right
1517  8497 AF           	xor a					; direction flag - to right							;8497	af
1518  8498 12           	ld (de),a				; store direction flag								;8498	12
1519  8499 C9           	ret						; ------------ End Of Proc ---------------			;8499	c9
1520  849A
1521  849A              ;*****************************************************************************************
1522  849A              ; Move Player Unit according to keys/joystick inputs.
1523  849A              ; In Demo Mode it skips checking input and moves player scripted way
1524  849A              UPDATE_PLAYER_POS:
1525  849A 3A 2F 78     	ld a,(GAME_MODE)		; a - Game Mode										;849a	3a 2f 78
1526  849D B7           	or a					; check if Running or Demo Mode						;849d	b7
1527  849E 20 3C        	jr nz,DEMO_UPDATE_PLAYER_POS	; Demo - skip input checks					;849e	20 3c
1528  84A0
1529  84A0              ; ---- check C or B pressed
1530  84A0 3A FB 68     	ld a,(068fbh)			; read keys: V|Z|C|SHIFT|X|B						;84a0	3a fb 68
1531  84A3 2F           	cpl						; inverse logic										;84a3	2f
1532  84A4 E6 09        	and %00001001			; mask keys: C or B									;84a4	e6 09
1533  84A6 20 5B        	jr nz,PLAYER_MOVE_RIGHT	; yes - C or B is pressed							;84a6	20 5b
1534  84A8              ; -- check M is pressed
1535  84A8 3A EF 68     	ld a,(068efh)			; read keys: M|SPACE|,| |.|N						;84a8	3a ef 68
1536  84AB CB 6F        	bit 5,a					; is M pressed										;84ab	cb 6f
1537  84AD 28 54        	jr z,PLAYER_MOVE_RIGHT	; yes - move player unit to the right				;84ad	28 54
1538  84AF              ; -- check V or X is pressed
1539  84AF 3A FB 68     	ld a,(068fbh)			; read keys: V|Z|C|SHIFT|X|B						;84af	3a fb 68
1540  84B2 2F           	cpl						; inverse logic										;84b2	2f
1541  84B3 E6 22        	and $22					; mask keys: V or X									;84b3	e6 22
1542  84B5 C2 84 85     	jp nz,PLAYER_MOVE_LEFT	; V or X is pressed									;84b5	c2 84 85
1543  84B8              ; -- check N is pressed
1544  84B8 3A EF 68     	ld a,(068efh)			; read keys: M|SPACE|,| |.|N 						;84b8	3a ef 68
1545  84BB CB 47        	bit 0,a					; is N pressed										;84bb	cb 47
1546  84BD CA 84 85     	jp z,PLAYER_MOVE_LEFT	; yes - move player unit to the left				;84bd	ca 84 85
1547  84C0              ; -- if input mode is set to joystick
1548  84C0 3A 12 78     	ld a,(INPUT_FLAG)		; input Keyboard/Joystick							;84c0	3a 12 78
1549  84C3 B7           	or a					; is Joystick input mode							;84c3	b7
1550  84C4 C8           	ret z					; no ------- End of Proc --------------------		;84c4	c8
1551  84C5              ; -- check 1st joystick
1552  84C5 DB 2E        	in a,(JOY1_PORT)		; read 1st joystick value							;84c5	db 2e
1553  84C7 CB 57        	bit 2,a					; is Move Left										;84c7	cb 57
1554  84C9 CA 84 85     	jp z,PLAYER_MOVE_LEFT	; yes - move plater unit to the left				;84c9	ca 84 85
1555  84CC CB 5F        	bit 3,a					; is Move Right										;84cc	cb 5f
1556  84CE 28 33        	jr z,PLAYER_MOVE_RIGHT	; yes - move player unit to the right				;84ce	28 33
1557  84D0              ; -- check 2nd joystick
1558  84D0 DB 2B        	in a,(JOY2_PORT)		; read 2nd joystick									;84d0	db 2b
1559  84D2 CB 57        	bit 2,a					; is Move Left										;84d2	cb 57
1560  84D4 CA 84 85     	jp z,PLAYER_MOVE_LEFT	; yes - move player unit to the left				;84d4	ca 84 85
1561  84D7 CB 5F        	bit 3,a					; is Move Right										;84d7	cb 5f
1562  84D9 28 28        	jr z,PLAYER_MOVE_RIGHT	; yes - move player unit to the right				;84d9	28 28
1563  84DB              ; -- no joystick input
1564  84DB C9           	ret						; --------- End of Proc	--------------------		;84db	c9
1565  84DC
1566  84DC              ;******************************************************************************************
1567  84DC              ; In Demo Mode move player unit to follow JUMPER position
1568  84DC              DEMO_UPDATE_PLAYER_POS:
1569  84DC 3A 1B 78     	ld a,(BAR_FLIP_FLAG)	; player unit bar flip flag 	 					;84dc	3a 1b 78
1570  84DF B7           	or a					; check not flipped (left up)						;84df	b7
1571  84E0 3A 10 78     	ld a,(PLAYER_X_INT)		; player X position (in pixels)						;84e0	3a 10 78
1572  84E3 28 10        	jr z,DEMO_FOLLOW_LEFT	; bar not flipped 									;84e3	28 10
1573  84E5
1574  84E5              DEMO_FOLLOW_RIGHT:
1575  84E5              ; -- player unit bar is flipped (right-up) - when bar is flipped we need to aim right side of unit
1576  84E5 C6 16        	add a,22				; add 22px aim JUMPER with right side of unit 		;84e5	c6 16
1577  84E7 47           	ld b,a					; b - player unit position X in pixels				;84e7	47 	G
1578  84E8 3A 15 78     	ld a,(JUMPER_X_INT)		; JUMPER position X in pixels						;84e8	3a 15 78
1579  84EB 90           	sub b					; check JUMPER position relative to player  		;84eb	90
1580  84EC F2 03 85     	jp p,PLAYER_MOVE_RIGHT	; a > b - move player right							;84ec	f2 03 85
1581  84EF C6 03        	add a,3					; check if JUMPER bounces right (pos X > 125)		;84ef	c6 03
1582  84F1 FA 84 85     	jp m,PLAYER_MOVE_LEFT	; yes -> bounce - move player left					;84f1	fa 84 85
1583  84F4 C9           	ret						; no move --------- End of Proc ---- 				;84f4	c9
1584  84F5
1585  84F5              ; -- player unit bar is not flipped (left-up)
1586  84F5              DEMO_FOLLOW_LEFT:
1587  84F5 47           	ld b,a					; b - player unit position X in pixels				;84f5	47
1588  84F6 3A 15 78     	ld a,(JUMPER_X_INT)		; JUMPER position X in pixels						;84f6	3a 15 78
1589  84F9 90           	sub b					; check JUMPER position relative to player 			;84f9	90
1590  84FA FA 84 85     	jp m,PLAYER_MOVE_LEFT	; a < b - move player left							;84fa	fa 84 85
1591  84FD D6 03        	sub 3					; check if JUMPER bounces left (pos X < 3)			;84fd	d6 03
1592  84FF F2 03 85     	jp p,PLAYER_MOVE_RIGHT	; yes -> bounce - move player right					;84ff	f2 03 85
1593  8502 C9           	ret						; no move --------- End of Proc ----				;8502	c9
1594  8503
1595  8503              ;************************************************************************************
1596  8503              ; Player Move Right
1597  8503              PLAYER_MOVE_RIGHT:
1598  8503 3A 10 78     	ld a,(PLAYER_X_INT)		; player X position (in pixels)						;8503	3a 10 78
1599  8506 FE 5F        	cp 95					; check if already max X position					;8506	fe 5f
1600  8508 D0           	ret nc					; yes - ------ End of Proc 	--------				;8508	d0
1601  8509
1602  8509              ; -- player unit can be moved right
1603  8509 ED 5B 1C 78  	ld de,(PLAYER_X_VEL)	; player unit velocity ($00ff) almost pixel			;8509	ed 5b 1c 78
1604  850D 2A 0F 78     	ld hl,(PLAYER_X_FRAC)	; current player X position							;850d	2a 0f 78
1605  8510 44           	ld b,h					; current player X position in pixels				;8510	44
1606  8511 19           	add hl,de				; add velocity factor								;8511	19
1607  8512
1608  8512              ;************************************************************************************
1609  8512              ; Redraw player unit on new position after move. No drawing needed if X pixel didn't change
1610  8512              DRAW_MOVED_PLAYER:
1611  8512 22 0F 78     	ld (PLAYER_X_FRAC),hl	; store new player X position						;8512	22 0f 78
1612  8515 7C           	ld a,h					; a - X position in integral pixels					;8515	7c
1613  8516 B8           	cp b					; is pixel changed?	(CY - which way)				;8516	b8
1614  8517 C8           	ret z					; no - ------- No need to update ---------			;8517	c8
1615  8518
1616  8518              ; -- player unit moved 1px at least
1617  8518 F5           	push af					; save a - player unit X position in pixels			;8518	f5
1618  8519              ; -- JUMPER W(aiting) needs to be moved along with Player Unit
1619  8519 3A 11 78     	ld a,(JUMPER_W_X_INT)	; JUMPER W(aiting) pos X in pixels					;8519	3a 11 78
1620  851C 32 26 78     	ld (JUMPER_W_CLR_X_INT),a	; store pos X for clear routines				;851c	32 26 78
1621  851F 38 03        	jr c,DMP_LEFT			; jump if move left 								;851f	38 03
1622  8521              ; -- move right
1623  8521 3C           	inc a					; add 1px 											;8521	3c
1624  8522 18 01        	jr DMP_MOVE				; continue											;8522	18 01
1625  8524              ; -- move left
1626  8524              DMP_LEFT:
1627  8524 3D           	dec a					; sub 1px											;8524	3d
1628  8525              DMP_MOVE:
1629  8525 32 11 78     	ld (JUMPER_W_X_INT),a	; store new X position								;8525	32 11 78
1630  8528              ; -- update VRAM address for new player position
1631  8528 F1           	pop af					; a - target Palyer Unit X position					;8528	f1
1632  8529 CB 3F        	srl a					; a = a*2											;8529	cb 3f
1633  852B CB 3F        	srl a					; a = a*2 - total a*4 pixels per screen byte 		;852b	cb 3f
1634  852D F6 20        	or $20					; adjust low byte of address to target line			;852d	f6 20
1635  852F 32 09 78     	ld (PLAYER_POS_VADR),a	; store low byte (high byte won't change)			;852f	32 09 78
1636  8532
1637  8532              ;*****************************************************************************************
1638  8532              ; Update Offscreen Buffers for Player and Jumper Waiting (the one standing on player Unit)
1639  8532              ; IN: h - new player X position (integral pixels)
1640  8532              UPDATE_OFFSCREEN_BUFFERS:
1641  8532 7C           	ld a,h					; a - player sprite X position (integral pixel)		;8532	7c
1642  8533 E6 03        	and $03					; pixel X position in byte screen (0..3)			;8533	e6 03
1643  8535 47           	ld b,a					; sprite variant depending on pixel shift 			;8535	47
1644  8536 20 05        	jr nz,UOB_SKIP			; skip marking player Unit Bar for clear			;8536	20 05
1645  8538              ; -- no shift in byte - we need clear 1px to the left (bar area)
1646  8538 3E 80        	ld a,$80				; $80 - bar need update 							;8538	3e 80
1647  853A 32 1A 78     	ld (BAR_CLEAR_FLAG),a	; set bar update flag								;853a	32 1a 78
1648  853D              UOB_SKIP:
1649  853D 04           	inc b					; b - sprite variant (1..4)							;853d	04
1650  853E 3A 1B 78     	ld a,(BAR_FLIP_FLAG)	; player unit bar state 							;853e	3a 1b 78
1651  8541 B7           	or a					; check bar is flipped (left up)					;8541	b7
1652  8542 20 05        	jr nz,UOB_BAR_IS_FLIPPED; yes - use another sprites (FB variants)			;8542	20 05
1653  8544              ; -- player unit bar is not flipped (left-up) - use base sprites
1654  8544 21 00 80     	ld hl,SPR_PLAYER_S0-56	; sprites base address (offset beacuse b is 1..4)	;8544	21 00 80
1655  8547 18 03        	jr UPDATE_PLAYER_BUF	; continue - update offscreen sprite buffer  		;8547	18 03
1656  8549
1657  8549              ; -- player unit bar is flipped (right-up) - use FB sprites
1658  8549              UOB_BAR_IS_FLIPPED:
1659  8549 21 96 81     	ld hl,SPR_PLAYER_FB_S0-56 ; sprites base address (offset beacuse b is 1..4)	;8549	21 96 81
1660  854C
1661  854C              ;*************************************************************************************
1662  854C              ; Update Player Offsceen Buffer
1663  854C              ; -- hl is pointing 56 bytes before either base or FB sprites table (4 variants)
1664  854C              ; -- b - index in table (1..4) depending on shift position relative to screen byte
1665  854C              UPDATE_PLAYER_BUF:
1666  854C 11 38 00     	ld de,56				; 56 bytes per sprite data							;854c	11 38 00
1667  854F              UPB_NEXT:
1668  854F 19           	add hl,de				; add 56 bytes - address of sprite variant			;854f	19
1669  8550 10 FD        	djnz UPB_NEXT			; repeat adding b times								;8550	10 fd
1670  8552              ; -- hl - address of sprite data in variant depends on b
1671  8552 11 01 7A     	ld de,SPR_BUF_PLAYER	; dst - sprite buffer to store current data			;8552	11 01 7a
1672  8555 01 38 00     	ld bc,56				; 56 bytes per sprite data							;8555	01 38 00
1673  8558 ED B0        	ldir					; copy sprite data to buffer 						;8558	ed b0
1674  855A
1675  855A              ; -- calculate new address and determine new variant for JUMPER W(aiting) sprite
1676  855A 2A 0B 78     	ld hl,(JUMPER_W_VADR)	; current screen position of JUMPER W(aiting)		;855a	2a 0b 78
1677  855D 22 24 78     	ld (JUMPER_W_CLR_VADR),hl; save for clear routine							;855d	22 24 78
1678  8560 3A 11 78     	ld a,(JUMPER_W_X_INT)	; JUMPER W(aiting) position X in pixels				;8560	3a 11 78
1679  8563 4F           	ld c,a					; save position X									;8563	4f
1680  8564 3A 13 78     	ld a,(JUMPER_W_Y_INT)	; JUMPER W(aiting) Y position (bottom up)			;8564	3a 13 78
1681  8567 CD 98 85     	call CALC_VRAM_ADDRESS	; hl - VRAM address of JUMPER W(aiting) sprite		;8567	cd 98 85
1682  856A 22 0B 78     	ld (JUMPER_W_VADR),hl	; store current VRAM address						;856a	22 0b 78
1683  856D 79           	ld a,c					; a - JUMPER W position X in pixels					;856d	79
1684  856E E6 03        	and $03					; pixel X position in byte screen (0..3)			;856e	e6 03
1685  8570 47           	ld b,a					; b - sprite variant depending on pixel shift		;8570	47
1686  8571 04           	inc b					; variant index range 1..4							;8571	04
1687  8572              ; -- b - index in table (1..4) depending on shift position relative to screen byte
1688  8572 21 11 81     	ld hl,SPR_JUMPER_S0-21	; address of sprite data table - offset (21)		;8572	21 11 81
1689  8575 11 15 00     	ld de,21				; 21 bytes per sprite variant						;8575	11 15 00
1690  8578              UPB_NEXT_J:
1691  8578 19           	add hl,de				; add size of sprite data							;8578	19
1692  8579 10 FD        	djnz UPB_NEXT_J			; keep adding b times								;8579	10 fd
1693  857B
1694  857B              ;*******************************************************************************************
1695  857B              ; Update Jumper Waiting Offsceen Buffer
1696  857B              ; -- hl is pointing 21 bytes before either base or FB sprites table (4 variants)
1697  857B              ; -- b - index in table (1..4) depending on shift position relative to screen byte
1698  857B 11 39 7A     	ld de,SPR_BUF_JUMPER_W	; dst - offscreen buffer for JUMPER W(aiting)		;857b	11 39 7a
1699  857E 01 15 00     	ld bc,21				; 21 bytes of sprite data							;857e	01 15 00
1700  8581 ED B0        	ldir					; copy sprite data to buffer						;8581	ed b0
1701  8583 C9           	ret						; ------------- End of Proc -------------			;8583	c9
1702  8584
1703  8584              ;*******************************************************************************************
1704  8584              ; Player Move Left
1705  8584              ; moves player's unit to the left with boundary checking
1706  8584              ; Called if user press key or move joystick left
1707  8584              PLAYER_MOVE_LEFT:
1708  8584 3A 10 78     	ld a,(PLAYER_X_INT)		; player X position (in pixels)						;8584	3a 10 78
1709  8587 FE 09        	cp 9					; check if already minimum X position				;8587	fe 09
1710  8589 D8           	ret c					; yes - --------- End of Proc ----------			;8589	d8
1711  858A              ; -- player unit can be moved left
1712  858A ED 5B 1C 78  	ld de,(PLAYER_X_VEL)	; player unit velocity ($00ff) almost pixel			;858a	ed 5b 1c 78
1713  858E 2A 0F 78     	ld hl,(PLAYER_X_FRAC)	; player X position (with pixel fraction)			;858e	2a 0f 78
1714  8591 44           	ld b,h					; b - X position in whole pixels					;8591	44
1715  8592 B7           	or a					; clear Carry flag									;8592	b7
1716  8593 ED 52        	sbc hl,de				; subtract velocity factor							;8593	ed 52
1717  8595 C3 12 85     	jp DRAW_MOVED_PLAYER	; draw player on new position						;8595	c3 12 85
1718  8598
1719  8598              ;*******************************************************************************************
1720  8598              ; Calculate VRAM address from pixel coordinates (Cartesian Plane Coordinates)
1721  8598              ; IN: a - Y coord (number lines to bottom of screen)
1722  8598              ;     c - X coord (number of pixels from left edge)
1723  8598              ; OUT hl - VRAM address
1724  8598              ;     b - X position in pixels
1725  8598              CALC_VRAM_ADDRESS:
1726  8598 5F           	ld e,a					; e - Y coordinate									;8598	5f
1727  8599 16 00        	ld d,0					; de - Y coordinate as 16bit value					;8599	16 00
1728  859B              ; -- multiply Y * 32 bytes per screen line
1729  859B 06 05        	ld b,5					; shift counter - (32 = 2^5)						;859b	06 05
1730  859D              CVA_MUX_2:
1731  859D CB 23        	sla e					; e = e * 2											;859d	cb 23
1732  859F CB 12        	rl d					; de = de * 2										;859f	cb 12
1733  85A1 10 FA        	djnz CVA_MUX_2				; repeat 5 times -> de = a * 32					;85a1	10 fa
1734  85A3              ; -- de is address offset from last line (in screeen bytes)
1735  85A3 21 E0 77     	ld hl,VRAM+(63*32)+0	; last line screen coord (0,63)px [$77e0]			;85a3	21 e0 77
1736  85A6 B7           	or a					; clear Carry flagfor substract						;85a6	b7
1737  85A7 ED 52        	sbc hl,de				; calculate VRAM address where target line starts	;85a7	ed 52
1738  85A9 79           	ld a,c					; a - X coordinate in pixels						;85a9	79
1739  85AA 47           	ld b,a					; b - X coordinate in pixels						;85aa	47
1740  85AB CB 3F        	srl a					; a = X/2											;85ab	cb 3f
1741  85AD CB 3F        	srl a					; a = X/2 (total X/4 pixels per screen byte)		;85ad	cb 3f
1742  85AF 5F           	ld e,a					; e - X coord in bytes								;85af	5f
1743  85B0 16 00        	ld d,0					; de - X offset in screen bytes						;85b0	16 00
1744  85B2 19           	add hl,de				; calculate final address of requested (X,Y)		;85b2	19
1745  85B3 C9           	ret						; -------------- End of Proc ----------				;85b3	c9
1746  85B4
1747  85B4              ;*******************************************************************************************
1748  85B4              ; Update JUMPER Positions
1749  85B4              ; Calculate new X and Y JUMPER position with Velocity and Gravity factors
1750  85B4              UPDATE_JUMPER_POS:
1751  85B4              ; -- update X position for clear routines
1752  85B4 3A 15 78     	ld a,(JUMPER_X_INT)		; JUMPER position X in pixels						;85b4	3a 15 78
1753  85B7 32 29 78     	ld (JUMPER_CLR_X_INT),a	; store position X for clear routines				;85b7	32 29 78
1754  85BA
1755  85BA              ; -- calculate new Y position with Velocity and Gravity
1756  85BA 2A 22 78     	ld hl,(JUMPER_Y_VEL)	; JUMPER Y velocity 								;85ba	2a 22 78
1757  85BD ED 5B 1E 78  	ld de,(WORLD_GRAVITY)	; de - Wrorld Gravity factor						;85bd	ed 5b 1e 78
1758  85C1 B7           	or a					; clear Carry flag for substract					;85c1	b7
1759  85C2 ED 52        	sbc hl,de				; JUMPER Y velocity with Gravity correction			;85c2	ed 52
1760  85C4 22 22 78     	ld (JUMPER_Y_VEL),hl	; store as new Y velocity							;85c4	22 22 78
1761  85C7 EB           	ex de,hl				; de - new Y velocity								;85c7	eb
1762  85C8 2A 16 78     	ld hl,(JUMPER_Y_FRAC)	; JUMPER position Y (with fractions)				;85c8	2a 16 78
1763  85CB 19           	add hl,de				; add velocity -> new Y position					;85cb	19
1764  85CC 44           	ld b,h					; b - JUMPER position Y in pixels					;85cc	44
1765  85CD
1766  85CD              ; -- calculate new X position with Velocity
1767  85CD 22 16 78     	ld (JUMPER_Y_FRAC),hl	; store new Y position (with fractions)				;85cd	22 16 78
1768  85D0 2A 14 78     	ld hl,(JUMPER_X_FRAC)	; JUMPER position X (with fraction)					;85d0	2a 14 78
1769  85D3 ED 5B 20 78  	ld de,(JUMPER_X_VEL)	; JUMPER X velocity									;85d3	ed 5b 20 78
1770  85D7 19           	add hl,de				; add velocity -> new X position					;85d7	19
1771  85D8 22 14 78     	ld (JUMPER_X_FRAC),hl	; store new X position (with fractions)				;85d8	22 14 78
1772  85DB 4C           	ld c,h					; c - JUMPER position X in pixels					;85db	4c
1773  85DC
1774  85DC              ; -- update VRAM address for clear routine
1775  85DC 2A 0D 78     	ld hl,(JUMPER_VADR)		; JUMPER screen address 							;85dc	2a 0d 78
1776  85DF 22 27 78     	ld (JUMPER_CLR_VADR),hl; store address for clear routines					;85df	22 27 78
1777  85E2
1778  85E2              ;************************************************************************************************
1779  85E2              ; First check collision of two JUMPERs - case when flying Jumper landed on waiting Jumper
1780  85E2              ; -- b - JUMPER Y position (in pixels), c - JUMPER X position (in pixels)
1781  85E2 3A 13 78     	ld a,(JUMPER_W_Y_INT)	; JUMPER W(aiting) position Y (bottom up)			;85e2	3a 13 78
1782  85E5 90           	sub b					; difference Y pos of both JUMPERs 					;85e5	90
1783  85E6 FC FB 85     	call m,NEG_A			; normalize Y difference (make it positive number)	;85e6	fc fb 85
1784  85E9 FE 07        	cp 7					; check if less than 7 px							;85e9	fe 07
1785  85EB 30 11        	jr nc,CHECK_JUMPER_Y	; no - continue checking (Y position)				;85eb	30 11
1786  85ED              ; -- Y difference is less than 7
1787  85ED 3A 11 78     	ld a,(JUMPER_W_X_INT)	; JUMPER W(aiting) position X in pixels				;85ed	3a 11 78
1788  85F0 91           	sub c					; difference X pos of both JUMPERs					;85f0	91
1789  85F1 FC FB 85     	call m,NEG_A			; normalize X difference (make it positive number)	;85f1	fc fb 85
1790  85F4 FE 07        	cp 7					; check if less than 7								;85f4	fe 07
1791  85F6 30 06        	jr nc,CHECK_JUMPER_Y	; no - continue checking (Y position)	 			;85f6	30 06 	0 .
1792  85F8              ; -- both X and Y difference is less than 7 px - Jumper landed on another Jumper
1793  85F8 C3 65 86     	jp JUMPER_IS_DEAD		; set Game Event 1 (Jumper Died) and return			;85f8	c3 65 86
1794  85FB
1795  85FB              ;***********************************************************************************************
1796  85FB              ; A = A * (-1) Called when A is negative. Technically performs ABS(a)
1797  85FB              NEG_A:
1798  85FB ED 44        	neg						; negate a											;85fb	ed 44
1799  85FD C9           	ret						; ------------------- End of Proc -----------		;85fd	c9
1800  85FE
1801  85FE              ;***********************************************************************************************
1802  85FE              ; Next check Y position - case when there is colision of Jumper and Player
1803  85FE              ; -- X and Y positions difference beetween both JUMPERs is bigger than 7 px
1804  85FE              CHECK_JUMPER_Y:
1805  85FE 78           	ld a,b					; JUMPER position Y in pixels						;85fe	78
1806  85FF FE 12        	cp 18					; check if less than 18 px (from bottom)			;85ff	fe 12
1807  8601 30 5D        	jr nc,CHECK_JUMPER_Y_13	; no - continue checking 							;8601	30 5d
1808  8603
1809  8603              ; -- JUMPER Y position is less than 18px - possible collision with PLAYER
1810  8603 3A 10 78     	ld a,(PLAYER_X_INT)		; PLAYER X position (in pixels)						;8603	3a 10 78
1811  8606 91           	sub c					; subtract JUMPER X position 						;8606	91
1812  8607 5F           	ld e,a					; e - positions X difference						;8607	5f
1813  8608 D6 07        	sub 7					; check if diffrence is less than 7 px				;8608	d6 07
1814  860A F2 60 86     	jp p,CHECK_JUMPER_Y_13	; no - continue checking 							;860a	f2 60 86
1815  860D
1816  860D              ; -- X pos difference beetween PLAYER and JUMPER is less than 7 px and JUMPER Y pos < 18px
1817  860D              ; -- 0 < diff < 7px -- JUMPER is on the LEFT but no more than 7 px (JUMPER sprite width) - collision
1818  860D              ; -- -23 < diff < 0 -- JUMPER is on the RIGHT, PLAYER is on the lLEFT -- collision
1819  860D              ; -- diff < -23 -- JUMPER is on the RIGHT, PLAYER is on the LEFT (too far) -- no collision
1820  860D C6 1E        	add a,30				; check if X diff is less than (-23)				;860d	c6 1e
1821  860F FA 60 86     	jp m,CHECK_JUMPER_Y_13	; yes - too far - continue checking					;860f	fa 60 86
1822  8612              ; -- collision of PLAYER and JUMPER
1823  8612 3A 1B 78     	ld a,(BAR_FLIP_FLAG)	; player unit bar state 							;8612	3a 1b 78
1824  8615 B7           	or a					; check not flipped (left up)						;8615	b7
1825  8616 20 38        	jr nz,PLA_JUM_COLL_BAR_R; bar is flipped (right up)							;8616	20 38
1826  8618 C3 1B 86     	jp PLA_JUM_COLL_BAR_L	; bar is not flipper (left up)						;8618	c3 1b 86
1827  861B
1828  861B              ;**************************************************************************************************
1829  861B              ; Player and Jumper collision - bar is not flipped (left up)
1830  861B              ; -- player unit bar is not flipped (left up)
1831  861B              PLA_JUM_COLL_BAR_L:
1832  861B              ; -- exchange positions for 2 Jumpers
1833  861B 3A 11 78     	ld a,(JUMPER_W_X_INT)	; JUMPER W(aiting) X position in pixels				;861b	3a 11 78
1834  861E 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER new X position 					;861e	32 15 78
1835  8621              ; -- place JUMPER W(aiting) on the left side of Player Unit
1836  8621 3A 10 78     	ld a,(PLAYER_X_INT)		; PLAYER X position in pixels						;8621	3a 10 78
1837  8624 32 11 78     	ld (JUMPER_W_X_INT),a	; store as JUMPER W(aiting) new X position			;8624	32 11 78
1838  8627              BOUNCE_JUMPERS:
1839  8627 3E 12        	ld a,18					; startup Y position for JUMPER						;8627	3e 12
1840  8629 32 17 78     	ld (JUMPER_Y_INT),a		; sore new Y position in lines (bottom up)			;8629	32 17 78
1841  862C CD 22 87     	call FLIP_JUMPER_VEL_Y_56	; invert Y velocity and add 56 (jump up)		;862c	cd 22 87
1842  862F 3E 0F        	ld a,15					; startup Y position for JUMPER W(aiting) 			;862f	3e 0f
1843  8631 32 13 78     	ld (JUMPER_W_Y_INT),a	; sore new Y position in lines (bottom up)			;8631	32 13 78
1844  8634 3A 1B 78     	ld a,(BAR_FLIP_FLAG)	; a - Player unit bar state 						;8634	3a 1b 78
1845  8637 EE 01        	xor $01					; flip bar to opposite state						;8637	ee 01
1846  8639 32 1B 78     	ld (BAR_FLIP_FLAG),a	; save new state of bar								;8639	32 1b 78
1847  863C CD 30 89     	call PLAY_SND_LOW		; play low beep sound								;863c	cd 30 89
1848  863F 2A 0F 78     	ld hl,(PLAYER_X_FRAC)	; PLAYER X position (with fraction)					;863f	2a 0f 78
1849  8642 CD 32 85     	call UPDATE_OFFSCREEN_BUFFERS	; update offscreen draw buffers 			;8642	cd 32 85
1850  8645 3A 15 78     	ld a,(JUMPER_X_INT)		; JUMPER position X in pixels						;8645	3a 15 78
1851  8648 4F           	ld c,a					; store to c										;8648	4f
1852  8649 3A 17 78     	ld a,(JUMPER_Y_INT)		; JUMPER position Y in pixels						;8649	3a 17 78
1853  864C 47           	ld b,a					; store to b										;864c	47
1854  864D C3 BB 86     	jp UPDATE_JUMPER_SPRITE	; update JUMPER VRAM address and sprite data in buf	;864d	c3 bb 86
1855  8650
1856  8650              ;**************************************************************************************************
1857  8650              ; Player and Jumper collision - bar is flipped (right up)
1858  8650              ; -- player unit bar is flipped (right up)
1859  8650              PLA_JUM_COLL_BAR_R:
1860  8650              ; -- exchange positions for 2 Jumpers
1861  8650 3A 11 78     	ld a,(JUMPER_W_X_INT)	; JUMPER W(aiting) X position in pixels				;8650	3a 11 78
1862  8653 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER new X position					;8653	32 15 78
1863  8656              ; -- place JUMPER W(aiting) on the right side of Player Unit
1864  8656 3A 10 78     	ld a,(PLAYER_X_INT)		; PLAYER X position in pixels						;8656	3a 10 78
1865  8659 C6 12        	add a,18				; add 18px - JUMPER must be placed on right side	;8659	c6 12
1866  865B 32 11 78     	ld (JUMPER_W_X_INT),a	; store as JUMPER W(aiting) new X position			;865b	32 11 78
1867  865E              ; --
1868  865E 18 C7        	jr BOUNCE_JUMPERS		; bounce Jumpers and flip Player Unit Bar 			;865e	18 c7
1869  8660
1870  8660              ;**************************************************************************************************
1871  8660              ; Jumper and Floor collision
1872  8660              ; Jumper is Dead if Y position is less or equal to 13
1873  8660              CHECK_JUMPER_Y_13:
1874  8660 78           	ld a,b					; JUMPER position Y in pixels					;8660	78 	x
1875  8661 FE 0D        	cp 13					; check if less than 13 px						;8661	fe 0d
1876  8663 30 07        	jr nc,CHECK_MAX_Y		; no - continue check (max Y position)			;8663	30 07
1877  8665
1878  8665              ;*******************************************************************************************
1879  8665              ; JUMPER is Dead
1880  8665              ; Landed on Jumper W(aiting) -- X and Y positions difference beetween both JUMPERs is less than 7 px
1881  8665              ; Landed on floor - Y position of JUMPER is less than 13 px
1882  8665              JUMPER_IS_DEAD:
1883  8665 E1           	pop hl					; take out return address							;8665	e1
1884  8666 3E 01        	ld a,1					; a - Game Event - Player Died						;8666	3e 01
1885  8668 32 18 78     	ld (GAME_EVENT),a		; store to Game Event variable						;8668	32 18 78
1886  866B C9           	ret						; return to parent caller ---------------			;866b	c9
1887  866C
1888  866C              ; IN: a - JUMPER position Y in pixels (bottom up)
1889  866C              CHECK_MAX_Y:
1890  866C FE 3F        	cp 63					; check if Y >= 63 (maximum)						;866c	fe 3f
1891  866E 38 09        	jr c,CHECK_MIDDLE_X		; no - continue checking							;866e	38 09
1892  8670
1893  8670              ; -- set maximum Y position
1894  8670 3E 3F        	ld a,63					; 63 - max Y position								;8670	3e 3f
1895  8672 47           	ld b,a					; store to b - JUMPER Y position					;8672	47
1896  8673 32 17 78     	ld (JUMPER_Y_INT),a		; store as JUMPER position Y in pixels				;8673	32 17 78
1897  8676 CD FB 86     	call FLIP_JUMPER_VEL_Y	; flip Y velocity for JUMPER						;8676	cd fb 86
1898  8679
1899  8679              ; -- b - Y position less than 63 (max)
1900  8679              CHECK_MIDDLE_X:
1901  8679 78           	ld a,b					; a - JUMPER position Y in pixels					;8679	78
1902  867A FE 2B        	cp 43					; check Y position 									;867a	fe 2b
1903  867C 28 5B        	jr z,CHECK_MIN_X_43				; Y = 43 ;867c	28 5b 	( [
1904  867E 38 1E        	jr c,CHECK_MIN_X_S		; Y < 43 - Stands constrains horizontal range 		;867e	38 1e
1905  8680
1906  8680              ; -- JUMPER Y position is bigger than 43 (above stands) - bounces from edge of screen
1907  8680              ; -- check if JUMPER is at maximum left
1908  8680 79           	ld a,c					; JUMPER X position in pixels						;8680	79
1909  8681 B7           	or a					; check if less than 0								;8681	b7
1910  8682 F2 8F 86     	jp p,CHECK_MAX_X		; no - skip horizontal bounce - check right max		;8682	f2 8f 86
1911  8685
1912  8685              ; -- JUMPER X position <= 0 so bounce
1913  8685 AF           	xor a					; 0 - minimum X position for JUMPER					;8685	af
1914  8686 4F           	ld c,a					; replace c with new value							;8686	4f
1915  8687 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER new X position X in pixels		;8687	32 15 78
1916  868A CD 09 87     	call FLIP_JUMPER_VEL_X	; invert X velocity value							;868a	cd 09 87
1917  868D 18 2C        	jr UPDATE_JUMPER_SPRITE	; update VRAM addres and sprite in buffer			;868d	18 2c
1918  868F
1919  868F              ; -- JUMPER X position > 0 (and < 127)
1920  868F              CHECK_MAX_X:
1921  868F FE 79        	cp 121					; check if X < 121 (max X position)					;868f	fe 79
1922  8691 38 28        	jr c,UPDATE_JUMPER_SPRITE	; yes - update VRAM addres and sprite in buffer	;8691	38 28
1923  8693
1924  8693              ; -- X >= 121 - set max X position and bounce
1925  8693 3E 79        	ld a,121				; 121 - maximum X position for JUMPER				;8693	3e 79
1926  8695 4F           	ld c,a					; replace c with new value							;8695	4f
1927  8696 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER new X position in pixels			;8696	32 15 78
1928  8699 CD 09 87     	call FLIP_JUMPER_VEL_X	; invert X velocity value							;8699	cd 09 87
1929  869C 18 1D        	jr UPDATE_JUMPER_SPRITE	; update VRAM addres and sprite in buffer			;869c	18 1d
1930  869E
1931  869E              ; -- JUMPER Y position < 43 - bounces from Stands
1932  869E              ; -- check if JUMPER is at maximum left
1933  869E              CHECK_MIN_X_S:
1934  869E 79           	ld a,c					; a - JUMPER X position in pixels					;869e	79
1935  869F FE 08        	cp 8					; check if X < 8 (min X position)					;869f	fe 08
1936  86A1 30 0B        	jr nc,CHECK_MAX_X_S		; no - check if maximum X							;86a1	30 0b
1937  86A3
1938  86A3              ; -- X < 8 - set min X position and bounce
1939  86A3 3E 08        	ld a,8					; 8 - minimum X position for JUMPER 				;86a3	3e 08
1940  86A5 4F           	ld c,a					; replace c with new value							;86a5	4f
1941  86A6 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER new X position in pixels			;86a6	32 15 78
1942  86A9 CD 09 87     	call FLIP_JUMPER_VEL_X	; invert X velocity value							;86a9	cd 09 87
1943  86AC 18 0D        	jr UPDATE_JUMPER_SPRITE	; update VRAM addres and sprite in buffer			;86ac	18 0d
1944  86AE
1945  86AE              ; -- JUMPER Y position >= 8 - bounces from Stands
1946  86AE              ; -- check if JUMPER is at maximum right
1947  86AE              CHECK_MAX_X_S:
1948  86AE FE 71        	cp 113					; check if X < 113 (min X position)					;86ae	fe 71
1949  86B0 38 09        	jr c,UPDATE_JUMPER_SPRITE	; yes - update VRAM addres and sprite in buffer	;86b0	38 09
1950  86B2
1951  86B2              ; -- X > 113 - set max X position and bounce
1952  86B2 3E 71        	ld a,113				; 113 - maximum X position for JUMPER				;86b2	3e 71
1953  86B4 4F           	ld c,a					; replace c with new value							;86b4	4f
1954  86B5 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER new X position in pixels			;86b5	32 15 78
1955  86B8 CD 09 87     	call FLIP_JUMPER_VEL_X	; invert X velocity value							;86b8	cd 09 87
1956  86BB              							; update VRAM addres and sprite in buffer
1957  86BB
1958  86BB              ;*****************************************************************************************************
1959  86BB              ; Update JUMPER VRAM address and copy to buffer sprite data depend on X position
1960  86BB              ; IN - b - JUMPER Y position
1961  86BB              ;      c - JUMPER X position
1962  86BB              UPDATE_JUMPER_SPRITE:
1963  86BB 78           	ld a,b					; JUMPER position Y in pixels						;86bb	78
1964  86BC CD 98 85     	call CALC_VRAM_ADDRESS	; calculate VRAM address (hl) 						;86bc	cd 98 85
1965  86BF 22 0D 78     	ld (JUMPER_VADR),hl		; store new JUMPER VRAM address						;86bf	22 0d 78
1966  86C2 79           	ld a,c					; JUMPER position X in pixels						;86c2	79
1967  86C3 E6 03        	and $03					; pixel X position in byte screen (0..3)			;86c3	e6 03
1968  86C5 47           	ld b,a					; b - sprite variant depending on pixel shift		;86c5	47
1969  86C6 04           	inc b					; variant index (1..4)								;86c6	04
1970  86C7 21 11 81     	ld hl,SPR_JUMPER_S0-21	; address of sprite data table - 21 (size of data)	;86c7	21 11 81
1971  86CA 11 15 00     	ld de,21				; 21 bytes per sprite variant						;86ca	11 15 00
1972  86CD              UJS_NEXT:
1973  86CD 19           	add hl,de				; calculate address of sprite data					;86cd	19
1974  86CE 10 FD        	djnz UJS_NEXT			; repeat adding b times								;86ce	10 fd
1975  86D0              ; -- copy sprite data to offscreen buffer
1976  86D0 11 4E 7A     	ld de,SPR_BUF_JUMPER	; offscreen draw buffer address						;86d0	11 4e 7a
1977  86D3 01 15 00     	ld bc,21				; 21 bytes of sprite data to copy					;86d3	01 15 00
1978  86D6 ED B0        	ldir					; copy to sprite buffer								;86d6	ed b0
1979  86D8 C9           	ret						; ----------- End of Proc ------------------		;86d8	c9
1980  86D9
1981  86D9              ; -- JUMPER Y position = 43
1982  86D9              CHECK_MIN_X_43:
1983  86D9 79           	ld a,c					; JUMPER X position in pixels						;86d9	79
1984  86DA B7           	or a					; check if X < 0									;86da	b7
1985  86DB F2 F3 86     	jp p,CHECK_MAX_X_43		; no - check maximum X value 						;86db	f2 f3 86
1986  86DE              ; -- JUMPER X position > 127 - end of right side of screen
1987  86DE AF           	xor a					; a - reset JUMPER X position						;86de	af
1988  86DF
1989  86DF              ;*******************************************************************************************
1990  86DF              ; IN: a - new X position for JUMPER
1991  86DF              ; -- a - JUMPER X position
1992  86DF              JUMPER_BOUNCE_A:
1993  86DF 4F           	ld c,a					; replace c with new value							;86df	4f
1994  86E0 32 15 78     	ld (JUMPER_X_INT),a		; store as JUMPER position X in pixels				;86e0	32 15 78
1995  86E3 CD 09 87     	call FLIP_JUMPER_VEL_X	; flip X velocity value								;86e3	cd 09 87
1996  86E6 79           	ld a,c					; a - JUMPER X position								;86e6	79
1997  86E7
1998  86E7              ; -- a - JUMPER X position
1999  86E7              CHECK_MIN_MAX_X:
2000  86E7 FE 08        	cp 8					; check if X position < 8 (minimum)					;86e7	fe 08
2001  86E9 DC 17 87     	call c,FLIP_JUMPER_VEL_Y_16	; yes - flip Y velocity and add 16 (bounce)		;86e9	dc 17 87
2002  86EC FE 72        	cp 114					; check if X position >= 114 (maximum)				;86ec	fe 72
2003  86EE D4 17 87     	call nc,FLIP_JUMPER_VEL_Y_16; yes - flip Y velocity and add 16 (bounce)		;86ee	d4 17 87
2004  86F1
2005  86F1              ; -- JUMPER X position in range (8..113)
2006  86F1 18 C8        	jr UPDATE_JUMPER_SPRITE	; update VRAM addres and sprite in buffer			;86f1	18 c8
2007  86F3
2008  86F3              CHECK_MAX_X_43:
2009  86F3 FE 79        	cp 121					; check if X position < 121 (maximum)				;86f3	fe 79
2010  86F5 38 F0        	jr c,CHECK_MIN_MAX_X	; check if accelerated bounce needed				;86f5	38 f0
2011  86F7
2012  86F7              ; -- JUMPER X position >= 121 - set maximum and bounce
2013  86F7 3E 79        	ld a,121				; 121 - maximum X position for JUMPER				;86f7	3e 79
2014  86F9 18 E4        	jr JUMPER_BOUNCE_A		; set new X position and bounce						;86f9	18 e4
2015  86FB
2016  86FB              ;****************************************************************************************
2017  86FB              ; Changes sign of Y velocity for JUMPER sprite moves
2018  86FB              FLIP_JUMPER_VEL_Y:
2019  86FB ED 5B 22 78  	ld de,(JUMPER_Y_VEL)	; JUMPER Y velocity									;86fb	ed 5b 22 78
2020  86FF 21 00 00     	ld hl,0					; 0 to subtract from								;86ff	21 00 00
2021  8702 B7           	or a					; clear Carry flag									;8702	b7
2022  8703 ED 52        	sbc hl,de				; negate velocity 									;8703	ed 52
2023  8705 22 22 78     	ld (JUMPER_Y_VEL),hl	; store new Y velocity for JUMPER					;8705	22 22 78
2024  8708 C9           	ret						; ------------- End of Proc --------				;8708	c9
2025  8709
2026  8709              ;****************************************************************************************
2027  8709              ; Changes sign of X velocity for JUMPER sprite moves
2028  8709              FLIP_JUMPER_VEL_X:
2029  8709 ED 5B 20 78  	ld de,(JUMPER_X_VEL)	; JUMPER X velocity									;8709	ed 5b 20 78
2030  870D 21 00 00     	ld hl,0					; 0 to subtract from								;870d	21 00 00
2031  8710 B7           	or a					; clear Carry flag									;8710	b7
2032  8711 ED 52        	sbc hl,de				; negate velocity									;8711	ed 52
2033  8713 22 20 78     	ld (JUMPER_X_VEL),hl	; store new X velocity for Jumping Man				;8713	22 20 78
2034  8716 C9           	ret						; ------------- End of Proc --------				;8716	c9
2035  8717
2036  8717              ;****************************************************************************************
2037  8717              ; Changes sign of Y velocity for JUMPER sprite moves and adds 16 to it
2038  8717              FLIP_JUMPER_VEL_Y_16:
2039  8717 CD FB 86     	call FLIP_JUMPER_VEL_Y	; change sing of Y velocity value					;8717	cd fb 86
2040  871A 11 10 00     	ld de,16				; 16 - delta to add to velocity						;871a	11 10 00
2041  871D 19           	add hl,de				; incrase velocity value							;871d	19
2042  871E 22 22 78     	ld (JUMPER_Y_VEL),hl	; store new velocity								;871e	22 22 78
2043  8721 C9           	ret						; ------------ End of Proc ----------				;8721	c9
2044  8722
2045  8722              ;****************************************************************************************
2046  8722              ; Changes sign of Y velocity for JUMPER sprite moves and adds 56 to it
2047  8722              FLIP_JUMPER_VEL_Y_56:
2048  8722 CD FB 86     	call FLIP_JUMPER_VEL_Y	; change sing of Y velocity value					;8722	cd fb 86
2049  8725 11 38 00     	ld de,56				; 56 - delta to add to velocity						;8725	11 38 00
2050  8728 19           	add hl,de				; incrase velocity value							;8728	19
2051  8729 22 22 78     	ld (JUMPER_Y_VEL),hl	; store new velocity								;8729	22 22 78
2052  872C C9           	ret						; ------------ End of Proc ----------				;872c	c9
2053  872D
2054  872D              ;****************************************************************************************
2055  872D              ; Plays long high note
2056  872D              PLAY_SND_HIGH:
2057  872D 21 FF 01     	ld hl,511				; sound freq (half cycle time)						;872d	21 ff 01
2058  8730 01 0A 00     	ld bc,10				; sound length (cycles to play)						;8730	01 0a 00
2059  8733
2060  8733              ;****************************************************************************************
2061  8733              ; Paly Sound Wave
2062  8733              ; IN: bc - number of cycles to play (related to sound length)
2063  8733              ;     hl - length of half cycle of sound (related to sound frequency)
2064  8733              PLAY_SND_WAVE:
2065  8733 3A 2B 78     	ld a,(IOLATCH_SHADOW)	; a - current IOLATCH value							;8733	3a 2b 78
2066  8736 57           	ld d,a					; d - procedure parameter							;8736	57
2067  8737              PSW_REPEAT:
2068  8737 CD 40 87     	call PLAY_SND_CYCLE		; play 1 cycle of sound								;8737	cd 40 87
2069  873A 0B           	dec bc					; dec cycles countr									;873a	0b
2070  873B 79           	ld a,c					; check if 0										;873b	79
2071  873C B0           	or b					; a = b|c											;873c	b0
2072  873D 20 F8        	jr nz,PSW_REPEAT		; repeat until 0									;873d	20 f8
2073  873F C9           	ret						; --------- End of Proc ------						;873f	c9
2074  8740
2075  8740
2076  8740              ;****************************************************************************************
2077  8740              ; Play 1 sound cycle on Speaker
2078  8740              ; IN: d - current IOLATCH value from shadow register
2079  8740              ;     hl - half cycle length
2080  8740              PLAY_SND_CYCLE:
2081  8740 C5           	push bc					; save bc											;8740	c5
2082  8741              ; -- set (+) half cycle
2083  8741 7A           	ld a,d					; a - current IOLATCH value							;8741	7a
2084  8742 EE 21        	xor SPEAKER_PINS		; invert Speaker Pins								;8742	ee 21
2085  8744 32 00 68     	ld (IOLATCH),a			; store in hardware register						;8744	32 00 68
2086  8747              ; -- delay
2087  8747 E5           	push hl					; hl - delay counter - half cycle					;8747	e5
2088  8748 C1           	pop bc					; bc - value to countdown 							;8748	c1
2089  8749              PSC_DELAY_1:
2090  8749 0B           	dec bc					; dec delay counter									;8749	0b
2091  874A 79           	ld a,c					; check if 0										;874a	79
2092  874B B0           	or b					; a = b|c											;874b	b0
2093  874C 20 FB        	jr nz,PSC_DELAY_1		; jump until 0										;874c	20 fb
2094  874E              ; -- set (-) half cycle
2095  874E 7A           	ld a,d					; a - oryginal Speaker Pins							;874e	7a
2096  874F 32 00 68     	ld (IOLATCH),a			; store in hardware register						;874f	32 00 68
2097  8752              ; -- delay
2098  8752 E5           	push hl					; hl - delay counter - half cycle					;8752	e5
2099  8753 C1           	pop bc					; bc - value to countdown 							;8753	c1
2100  8754              PSC_DELAY_2:
2101  8754 0B           	dec bc					; dec delay counter									;8754	0b
2102  8755 79           	ld a,c					; check if 0										;8755	79
2103  8756 B0           	or b					; a = b|c											;8756	b0
2104  8757 20 FB        	jr nz,PSC_DELAY_2		; jump until 0										;8757	20 fb
2105  8759              ; -- end of proc
2106  8759 C1           	pop bc					; restore bc 										;8759	c1
2107  875A C9           	ret						;----------- End of Proc							;875a	c9
2108  875B
2109  875B              ;************************************************************************************************
2110  875B              ; Predefined table with points player can earn for collect Baloon
2111  875B              TAB_POINTS:
2112  875B 10 30 50     	defb	$10,$30,$50		; Note: values stored in BCD format					;875b	10 30 50
2113  875E
2114  875E              ;************************************************************************************************
2115  875E              ; Check if there is collision beetween JUMPER and any BALLON
2116  875E              CHECK_BALOON_COLLISION:
2117  875E              ; -- check Y position and return if too small to have collision
2118  875E 3A 17 78     	ld a,(JUMPER_Y_INT)		; JUMPER position Y in pixels						;875e	3a 17 78
2119  8761 FE 2F        	cp 47					; check if Y < 47 									;8761	fe 2f
2120  8763 D8           	ret c					; yes - no chance for collision with Balloon		;8763	d8
2121  8764              ; -- determine sprite mask variant base on pixel in byte shift
2122  8764 3A 15 78     	ld a,(JUMPER_X_INT)		; current position X in pixels						;8764	3a 15 78
2123  8767 E6 03        	and $03					; pixel X position in byte screen (0..3)			;8767	e6 03
2124  8769 3C           	inc a					; index range (1..4)								;8769	3c
2125  876A 47           	ld b,a					; sprite variant index 1..4							;876a	47
2126  876B 11 15 00     	ld de,21				; 21 bytes per sprite								;876b	11 15 00
2127  876E 21 65 81     	ld hl,SPR_JUMPER_S0_MASK-21 ; address of table with sprite masks -21		;876e	21 65 81
2128  8771              CC_ADDOFFSET:
2129  8771 19           	add hl,de				; add 21 bytes - next sprite mask					;8771	19
2130  8772 10 FD        	djnz CC_ADDOFFSET		; calculate sprite mask address from index			;8772	10 fd
2131  8774 EB           	ex de,hl				; sprite mask address into de						;8774	eb
2132  8775              ; -- check overlap with anything but background
2133  8775 2A 0D 78     	ld hl,(JUMPER_VADR)		; JUMPER VRAM address								;8775	2a 0d 78
2134  8778 06 07        	ld b,7					; 7 lines - sprite/mask height						;8778	06 07
2135  877A              CC_CHECK_LINE:
2136  877A 0E 03        	ld c,3					; 3 bytes - sprite/mask width (12px)				;877a	0e 03
2137  877C              CC_CHECK_BYTE:
2138  877C 1A           	ld a,(de)				; a - mask byte										;877c	1a
2139  877D 2F           	cpl						; inverse bits - 1 means foreground pixel			;877d	2f
2140  877E A6           	and (hl)				; check overlap on screen							;877e	a6
2141  877F 20 0E        	jr nz,COLL_DETECTED		; there is collision with something					;877f	20 0e
2142  8781              ; -- no collision
2143  8781 23           	inc hl					; next screen byte									;8781	23
2144  8782 13           	inc de					; next mask byte									;8782	13
2145  8783 0D           	dec c					; decrement bytes in line counter 					;8783	0d
2146  8784 20 F6        	jr nz,CC_CHECK_BYTE		; repeat for all 3 bytes in line					;8784	20 f6
2147  8786 D5           	push de					; save de											;8786	d5
2148  8787 11 1D 00     	ld de,29				; 29 bytes per line (3 covered in loop)				;8787	11 1d 00
2149  878A 19           	add hl,de				; addres of first sprite byte in next line			;878a	19
2150  878B D1           	pop de					; restore de - next mask byte						;878b	d1
2151  878C 10 EC        	djnz CC_CHECK_LINE		; repeat for all 7 lines							;878c	10 ec
2152  878E C9           	ret						; no collision detected --- End of Proc ---			;878e	c9
2153  878F
2154  878F              ;*********************************************************************************************
2155  878F              ; JUMPER Collision detected
2156  878F              ; IN: hl - screen address where collision detected
2157  878F              COLL_DETECTED:
2158  878F              ; -- calculate byte offset from left edge of screen
2159  878F 7D           	ld a,l					; a - low byte of collision screen address			;878f	7d
2160  8790 E6 1F        	and $1f					; we're only interested in range (0..31) 			;8790	e6 1f
2161  8792 4F           	ld c,a					; X coord (in screen bytes)							;8792	4f
2162  8793 06 00        	ld b,0					; bc - X coord 	- byte in this line					;8793	06 00
2163  8795
2164  8795              ; -- check if collision was in Baloons Blue Groups screen area
2165  8795 11 80 71     	ld de,VRAM+(12*32)+0	; screen coord (0,12)px [$7180]						;8795	11 80 71
2166  8798 B7           	or a					; clear Carry flag									;8798	b7
2167  8799 E5           	push hl					; save hl - collision screen address				;8799	e5
2168  879A ED 52        	sbc hl,de				; check if collision with Balloon Blue 				;879a	ed 52
2169  879C E1           	pop hl					; restore hl - collision screen address				;879c	e1
2170  879D 38 37        	jr c,COLL_CHECK_YEL		; no - check next Balloon Group						;879d	38 37
2171  879F
2172  879F              ; -- Carry = 0 means collision addres > (0,12)px coordinate - only Blue Ballon in this area
2173  879F 21 A0 79     	ld hl,SPR_BUF_BALOONS_BLU+32	; 2nd line in Ballons Blue buffer			;879f	21 a0 79
2174  87A2 CD F4 87     	call DELETE_BALLOON		; find balloon and remove it from sprite buffer		;87a2	cd f4 87
2175  87A5 3E 80        	ld a,$80				; Balloons Blue Group changed Game Event			;87a5	3e 80
2176  87A7
2177  87A7              SET_BAL_CHANGED:
2178  87A7              ; -- raise Event to handle
2179  87A7 32 18 78     	ld (GAME_EVENT),a		; store to Game Event variable						;87a7	32 18 78
2180  87AA
2181  87AA              ; -- set return address to Interrupt Exit proc
2182  87AA E1           	pop hl					; take out current return address					;87aa	e1
2183  87AB 21 EF 82     	ld hl,INT_EXIT			; hl address of Interrupt Exit routine				;87ab	21 ef 82
2184  87AE E5           	push hl					; set Exit routine as return address				;87ae	e5
2185  87AF
2186  87AF              ; -- update cleanup variables for both JUMPER sprites
2187  87AF 2A 0B 78     	ld hl,(JUMPER_W_VADR)	; JUMPER W(aiting) VRAM address						;87af	2a 0b 78
2188  87B2 22 24 78     	ld (JUMPER_W_CLR_VADR),hl	; store address for clear routines				;87b2	22 24 78
2189  87B5 2A 0D 78     	ld hl,(JUMPER_VADR)		; JUMPER VRAM address								;87b5	2a 0d 78
2190  87B8 22 27 78     	ld (JUMPER_CLR_VADR),hl	; store address for clear routines					;87b8	22 27 78
2191  87BB 3A 11 78     	ld a,(JUMPER_W_X_INT)	; JUMPER W(aiting) X position in pixels				;87bb	3a 11 78
2192  87BE 32 26 78     	ld (JUMPER_W_CLR_X_INT),a	; store X position for clear routines			;87be	32 26 78
2193  87C1 3A 15 78     	ld a,(JUMPER_X_INT)		; JUMPER X position X in pixels						;87c1	3a 15 78
2194  87C4 32 29 78     	ld (JUMPER_CLR_X_INT),a	; store X position for clear routines				;87c4	32 29 78
2195  87C7
2196  87C7              ; -- redraw Balloons Group which changed
2197  87C7 3A 18 78     	ld a,(GAME_EVENT)		; a - Balloons Group changed Game Event				;87c7	3a 18 78
2198  87CA E6 7F        	and $7f					; mask out bit 7 - range 0..3 						;87ca	e6 7f
2199  87CC CA 7D 83     	jp z,REDRAW_BALOONS_BLU ; was $80 - redraw Balloons Blue Group 				;87cc	ca 7d 83
2200  87CF 3D           	dec a					; check if was $81									;87cf	3d
2201  87D0 CA 70 83     	jp z,REDRAW_BALOONS_YEL	; was #81 - redraw Balloons Yellow Group 			;87d0	ca 70 83
2202  87D3 C3 63 83     	jp REDRAW_BALOONS_RED	; was $82 - redraw Balloons Red Group 				;87d3	c3 63 83
2203  87D6
2204  87D6              COLL_CHECK_YEL:
2205  87D6              ; -- check if collision was in Balloons Yellow Group screen area
2206  87D6 11 C0 70     	ld de,VRAM+(6*32)+0		; screen coord (0,6)px								;87d6	11 c0 70
2207  87D9 B7           	or a					; clear Carry flag									;87d9	b7
2208  87DA E5           	push hl					; save hl - collision screen address	 			;87da	e5
2209  87DB ED 52        	sbc hl,de				; check if collision with Balloon Yellow			;87db	ed 52
2210  87DD E1           	pop hl					; restore hl - collision screen address				;87dd	e1
2211  87DE 38 0A        	jr c,COLL_CHECK_RED		; no - must be Balloons Red Group 					;87de	38 0a
2212  87E0
2213  87E0              ; -- Carry = 0 means collision addres > (0,6)px coordinate - only Yellow Balloons in this area
2214  87E0 21 20 79     	ld hl,SPR_BUF_BALOONS_YEL+32	; 2nd line in Balloons Blue buffer			;87e0	21 20 79
2215  87E3 CD F4 87     	call DELETE_BALLOON		; find balloon and remove it from sprite buffer		;87e3	cd f4 87
2216  87E6 3E 81        	ld a,$81				; Balloons Yellow Group changed Game Event			;87e6	3e 81
2217  87E8 18 BD        	jr SET_BAL_CHANGED		; store Game Event and continue						;87e8	18 bd
2218  87EA
2219  87EA              COLL_CHECK_RED:
2220  87EA 21 A0 78     	ld hl,SPR_BUF_BALOONS_RED+32	; 2nd line in Balloons Red buffer			;87ea	21 a0 78
2221  87ED CD F4 87     	call DELETE_BALLOON		; find balloon and remove it from sprite buffer		;87ed	cd f4 87
2222  87F0 3E 82        	ld a,$82				; Balloons Red Group changed Game Event				;87f0	3e 82
2223  87F2 18 B3        	jr SET_BAL_CHANGED		; store Game Event and continue						;87f2	18 b3
2224  87F4
2225  87F4              ;*****************************************************************************************
2226  87F4              ; IN: hl - address of 2nd line in Balloons Group buffer
2227  87F4              ;     bc - X coord in screen bytes
2228  87F4              DELETE_BALLOON:
2229  87F4 09           	add hl,bc				; hl - address in buffer of collision point			;87f4	09
2230  87F5 79           	ld a,c					; a - byte index in line (X coord)					;87f5	79
2231  87F6 B7           	or a					; check if 0										;87f6	b7
2232  87F7 28 07        	jr z,CLEAR_BALLOON_AREA	; yes - skip searching for Balloon left edge		;87f7	28 07
2233  87F9              ; -- find left edge of collided Balloon sprite
2234  87F9              DB_CHECK_NEXT:
2235  87F9 7E           	ld a,(hl)				; a - byte of sprite data							;87f9	7e
2236  87FA 2B           	dec hl					; adres of next left byte							;87fa	2b
2237  87FB E6 F0        	and $f0					; check 2 left pixels of byte 						;87fb	e6 f0
2238  87FD 20 FA        	jr nz,DB_CHECK_NEXT		; not empty - check next byte						;87fd	20 fa
2239  87FF 23           	inc hl					; hl - address of left edge of Balloon sprite		;87ff	23
2240  8800              ; -- hl - address of collided Balloon sprite
2241  8800              CLEAR_BALLOON_AREA:
2242  8800 01 20 00     	ld bc,32				; 32 bytes in sprite line							;8800	01 20 00
2243  8803 B7           	or a					; clear Carry flag for substract					;8803	b7
2244  8804 ED 42        	sbc hl,bc				; now hl points to start of sprite first line		;8804	ed 42
2245  8806 11 1D 00     	ld de,29				; 29 bytes per line (3 covered in loop)				;8806	11 1d 00
2246  8809 AF           	xor a					; 0 - 4 green (background) pixels					;8809	af
2247  880A 06 04        	ld b,4					; 4 lines - sprite height							;880a	06 04
2248  880C              DB_CLEAR_NEXT_LINE:
2249  880C 0E 03        	ld c,3					; 3 bytes (12px) sprite width						;880c	0e 03
2250  880E              DB_CLEAR_NEXT_BYTE:
2251  880E 77           	ld (hl),a				; clear pixels in buffer							;880e	77
2252  880F 23           	inc hl					; address of next byte in buffer					;880f	23
2253  8810 0D           	dec c					; dec byte counter									;8810	0d
2254  8811 20 FB        	jr nz,DB_CLEAR_NEXT_BYTE; clear next byte in this line						;8811	20 fb
2255  8813 19           	add hl,de				; add 29 bytes - next sprite line 					;8813	19
2256  8814 10 F6        	djnz DB_CLEAR_NEXT_LINE	; repeat for 4 lines								;8814	10 f6
2257  8816 C9           	ret						; ----------- End of Proc -----------				;8816	c9
2258  8817
2259  8817
2260  8817              ;********************************************************************************************
2261  8817              ; Game INT Handler
2262  8817              ; Update Game Score after player collected Baloon
2263  8817              INT_BALOON_COLLECTED:
2264  8817 DD E5        	push ix					; save ix											;8817	dd e5
2265  8819              ; -- determine score points base on which Balloon was Collected
2266  8819 3A 18 78     	ld a,(GAME_EVENT)		; a - Balloon Collected Event ($80,$81,$82)			;8819	3a 18 78
2267  881C E6 7F        	and $7f					; ignore 7th bit - (index 0..2)						;881c	e6 7f
2268  881E 4F           	ld c,a					; c - table offset low byte 						;881e	4f
2269  881F 06 00        	ld b,0					; bc - table offset									;881f	06 00
2270  8821 21 5B 87     	ld hl,TAB_POINTS		; hl - address of predefined table (10,30,50)		;8821	21 5b 87
2271  8824 09           	add hl,bc				; calculate final addres with points				;8824	09
2272  8825 7E           	ld a,(hl)				; a - points to add to score (BCD format)			;8825	7e
2273  8826              ; -- add earned Score (BCD format) and draw it
2274  8826 2A 00 78     	ld hl,(CUR_SCORE)		; current score value								;8826	2a 00 78
2275  8829 85           	add a,l					; add points										;8829	85
2276  882A 27           	daa						; correction for BCD format							;882a	27
2277  882B 6F           	ld l,a					; store to l										;882b	6f
2278  882C 3E 00        	ld a,0					; 0 value - add only CY flag (if any)				;882c	3e 00
2279  882E 8C           	adc a,h					; add Carry flag									;882e	8c
2280  882F 27           	daa						; correction for BCD format							;882f	27
2281  8830 67           	ld h,a					; store to h - hl = new score						;8830	67
2282  8831 22 00 78     	ld (CUR_SCORE),hl		; save new score value								;8831	22 00 78
2283  8834 CD 72 7E     	call DRAW_CURRENT_SCORE	; draw updated score on screen						;8834	cd 72 7e
2284  8837              ; -- reset Game Events - nothing to handle
2285  8837 AF           	xor a					; 0 - no game events to handle						;8837	af
2286  8838 32 18 78     	ld (GAME_EVENT),a		; store to Game Event variable						;8838	32 18 78
2287  883B 01 FF 4F     	ld bc,$4fff				; delay counter -> 532 461 T -> 148.75 ms 			;883b	01 ff 4f
2288  883E C3 9F 88     	jp INT_EXIT_DELAY		; ------ exit INT proc with Delay ----				;883e	c3 9f 88
2289  8841
2290  8841              ;****************************************************************************
2291  8841              ; Game interrupt proc - Player Died variant
2292  8841              ; Clears both JUMPER sprites from screen, redraws Player Unit, JUMPER W(aiting) and Death sprite
2293  8841              INT_GAME_DEATH:
2294  8841 DD E5        	push ix					; save ix											;8841	dd e5
2295  8843              ; -- clear both Man sprites from screen
2296  8843 CD F9 82     	call CLEAR_JUMPER_SPRITES	; clear JUMPER sprite at old position			;8843	cd f9 82
2297  8846              ; -- draw Player Unit on screen
2298  8846 2A 09 78     	ld hl,(PLAYER_POS_VADR)	; PLAYER VRAM address 								;8846	2a 09 78
2299  8849 DD 21 01 7A  	ld ix,SPR_BUF_PLAYER	; PLAYER sprite offscreen buffer					;8849	dd 21 01 7a
2300  884D 06 08        	ld b,8					; 8 lines - sprite height							;884d	06 08
2301  884F 0E 07        	ld c,7					; 7 bytes - sprite width (28px) 					;884f	0e 07
2302  8851 CD 71 7F     	call DRAW_SPRITE		; draw sprite 										;8851	cd 71 7f
2303  8854              ; -- draw JUMPER W(aiting) on screen
2304  8854 2A 0B 78     	ld hl,(JUMPER_W_VADR)	; JUMPER W(aiting) VRAM address						;8854	2a 0b 78
2305  8857 DD 21 39 7A  	ld ix,SPR_BUF_JUMPER_W	; JUMPER W(aiting) offscreen buffer					;8857	dd 21 39 7a
2306  885B 06 07        	ld b,7					; 7 lines - sprite height							;885b	06 07
2307  885D 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;885d	0e 03
2308  885F CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;885f	cd 8c 7f
2309  8862              ; -- calculate Player Death screen position
2310  8862 3A 15 78     	ld a,(JUMPER_X_INT)		; JUMPER X position in pixels						;8862	3a 15 78
2311  8865 CB 3F        	srl a					; a = a *2											;8865	cb 3f
2312  8867 CB 3F        	srl a					; a = a *2 (total a*4 pikels/byte)					;8867	cb 3f
2313  8869 C6 C0        	add a,$c0				; low byte of VRAM - line 54 (top-down)				;8869	c6 c0
2314  886B 6F           	ld l,a					; store in l										;886b	6f
2315  886C 26 76        	ld h,$76				; hl = VRAM address (0,54) + a*4					;886c	26 76
2316  886E E5           	push hl					; address VRAM to draw Player Death					;886e	e5
2317  886F 22 2D 78     	ld (PLAYER_DEATH_VADR),hl; store new address for PLAYER DEATH sprite		;886f	22 2d 78
2318  8872              ; -- clear pixels of death sprite from screen (leave player unit below)
2319  8872 11 B0 88     	ld de,SPR_DEATH_MASK	; Death sprite mask to draw							;8872	11 b0 88
2320  8875 06 03        	ld b,3					; 3 lines - sprite height							;8875	06 03
2321  8877              IGD_NEXT_LINE:
2322  8877 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;8877	0e 03
2323  8879              IGD_NEXT_BYTE:
2324  8879 1A           	ld a,(de)				; a - mask byte										;8879	1a
2325  887A A6           	and (hl)				; apply mask - clear foreground pixels				;887a	a6
2326  887B 77           	ld (hl),a				; draw on screen									;887b	77
2327  887C 23           	inc hl					; next byte on screen								;887c	23
2328  887D 13           	inc de					; next byte from sprite mask						;887d	13
2329  887E 0D           	dec c					; dec bytes counter									;887e	0d
2330  887F 20 F8        	jr nz,IGD_NEXT_BYTE		; repeat for 3 bytes								;887f	20 f8
2331  8881 D5           	push de					; save de											;8881	d5
2332  8882 11 1D 00     	ld de,29				; 29 bytes per line (3 covered in loop)				;8882	11 1d 00
2333  8885 19           	add hl,de				; hl - next line on screen							;8885	19
2334  8886 D1           	pop de					; restore de										;8886	d1
2335  8887 10 EE        	djnz IGD_NEXT_LINE		; repeat for 3 lines								;8887	10 ee
2336  8889              ; -- draw Death sprite on screen
2337  8889 E1           	pop hl					; address VRAM to draw sprite						;8889	e1
2338  888A DD 21 A7 88  	ld ix,SPR_DEATH			; Player Death sprite (12x3)px						;888a	dd 21 a7 88
2339  888E 06 03        	ld b,3					; 3 lines - sprite height							;888e	06 03
2340  8890 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;8890	0e 03
2341  8892 CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;8892	cd 8c 7f
2342  8895              ; -- draw left and right stands on screen
2343  8895 CD B2 83     	call DRAW_STANDS_LR		; draw both stands (left and right)					;8895	cd b2 83
2344  8898              ; -- clear game events
2345  8898 AF           	xor a					; 0 - no Game Events to handle						;8898	af
2346  8899 32 18 78     	ld (GAME_EVENT),a		; store to Game Event variable						;8899	32 18 78
2347  889C              ;-- delay
2348  889C 01 FF 01     	ld bc,511				; delay counter -> 3.7ms 13293T						;889c	01 ff 01
2349  889F              ;**************************************************************
2350  889F              ; Delay routine time = (26T * bc) + 7T --> (7263.5 * bc) + 1955.6 ns
2351  889F              ; IN: bc - delay counter
2352  889F              INT_EXIT_DELAY:
2353  889F 0B           	dec bc					; dec delay counter	         - 6T					;889f	0b
2354  88A0 78           	ld a,b					; check bc			         - 4T					;88a0	78
2355  88A1 B1           	or c					; a = b|c			         - 4T					;88a1	b1
2356  88A2 20 FB        	jr nz,INT_EXIT_DELAY	; repeat until 0 			 - 12T					;88a2	20 fb
2357  88A4 C3 EF 82     	jp INT_EXIT				; clean stack and exit interrupt handler			;88a4	c3 ef 82
2358  88A7
2359  88A7              ;***********************************************************
2360  88A7              ; Player Death Sprite (12x3)px (3x3) bytes
2361  88A7              SPR_DEATH:
2362  88A7 00 40 00     	defb	$00,$40,$00		;88a7	00 40 00
2363  88AA 40 45 40     	defb	$40,$45,$40		;88aa	40 45 40
2364  88AD 55 55 40     	defb	$55,$55,$40		;88ad	55 55 40
2365  88B0
2366  88B0              ;************************************************************
2367  88B0              ; Player Death Sprite mask (12x3)px (3x3 bytes)
2368  88B0              SPR_DEATH_MASK:
2369  88B0 FF 3F FF     	defb	$ff,$3f,$ff		;88b0	ff 3f ff
2370  88B3 3F 30 3F     	defb	$3f,$30,$3f		;88b3	3f 30 3f
2371  88B6 00 00 3F     	defb	$00,$00,$3f		;88b6	00 00 3f
2372  88B9
2373  88B9              ;***********************************************************************************************
2374  88B9              ; Game Interrupt Proc - Cleanup variant
2375  88B9              ; Erase from screen Player Unit and Death, area where is last Life Icon.
2376  88B9              ; Reset position and draw Player Unit and JUMPER W(aiting). Finally redraw Stands and clear Dirty Flag
2377  88B9              INT_CLEANUP:
2378  88B9 DD E5        	push ix					; save ix											;88b9	dd e5
2379  88BB              ; -- erase Player Unit sprite from screen
2380  88BB 2A 09 78     	ld hl,(PLAYER_POS_VADR)	; current player position on screen					;88bb	2a 09 78
2381  88BE AF           	xor a					; clear Carry flag and 0 as 4 green pixels			;88be	af
2382  88BF 11 20 00     	ld de,32				; 32 bytes per screen line							;88bf	11 20 00
2383  88C2 ED 52        	sbc hl,de				; address of 1 line above player unit				;88c2	ed 52
2384  88C4 11 19 00     	ld de,25				; 25 bytes as line increment (7 in loop)			;88c4	11 19 00
2385  88C7 06 09        	ld b,9					; 9 lines to clear - sprite height					;88c7	06 09
2386  88C9              GIAH_CLR_NEXT_LINE:
2387  88C9 0E 07        	ld c,7					; 7 bytes (28px) to clear - sprite width			;88c9	0e 07
2388  88CB              GIAH_CLR_NEXT_BYTE:
2389  88CB 77           	ld (hl),a				; clear (draw green) 4 pixels on screen				;88cb	77
2390  88CC 23           	inc hl					; next VRAM address									;88cc	23
2391  88CD 0D           	dec c					; decrement byte counter							;88cd	0d
2392  88CE 20 FB        	jr nz,GIAH_CLR_NEXT_BYTE; repeat for all 7 bytes							;88ce	20 fb
2393  88D0 19           	add hl,de				; adres of left pixel in next line 					;88d0	19
2394  88D1 10 F6        	djnz GIAH_CLR_NEXT_LINE	; repeat for all 9 lines							;88d1	10 f6
2395  88D3
2396  88D3              ; -- erase Player Death sprite from screen
2397  88D3 2A 2D 78     	ld hl,(PLAYER_DEATH_VADR); Player Death VRAM address 						;88d3	2a 2d 78
2398  88D6 AF           	xor a					; 0 as 4 green pixels								;88d6	af
2399  88D7 11 1D 00     	ld de,29				; 29 bytes for line increment (3 in loop)			;88d7	11 1d 00
2400  88DA 06 03        	ld b,3					; 3 lines - sprite height							;88da	06 03
2401  88DC              GIAH_CLR_NEXT_LINE2:
2402  88DC 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;88dc	0e 03
2403  88DE              GTAH_CLR_NEXT_BYTE2:
2404  88DE 77           	ld (hl),a				; clear (draw green) 4 pixels on screen				;88de	77
2405  88DF 23           	inc hl					; next VRAM address									;88df	23
2406  88E0 0D           	dec c					; decrement byte counter							;88e0	0d
2407  88E1 20 FB        	jr nz,GTAH_CLR_NEXT_BYTE2	; repeat for all 3 bytes						;88e1	20 fb
2408  88E3 19           	add hl,de				; address of left pixel in next line				;88e3	19
2409  88E4 10 F6        	djnz GIAH_CLR_NEXT_LINE2; repeat for all 3 lines							;88e4	10 f6
2410  88E6
2411  88E6              ; -- reset dirty flag - screen is clean
2412  88E6 AF           	xor a					; 0 - screen is clean								;88e6	af
2413  88E7 32 2C 78     	ld (SCR_DIRTY_FLAG),a	; reset dirty flag									;88e7	32 2c 78
2414  88EA
2415  88EA              ; -- reinitialize Player Unit position and draw on screen
2416  88EA 21 2D 76     	ld hl,VRAM+(49*32)+13   ; screen coord (52,49)px [$762d]					;88ea	21 2d 76
2417  88ED 22 09 78     	ld (PLAYER_POS_VADR),hl	; store coord as current							;88ed	22 09 78
2418  88F0 DD 21 01 7A  	ld ix,SPR_BUF_PLAYER	; player unit sprite from buffer 					;88f0	dd 21 01 7a
2419  88F4 06 08        	ld b,8					; 8 lines - sprite height							;88f4	06 08
2420  88F6 0E 07        	ld c,7					; 7 bytes - sprite width (28px)						;88f6	0e 07
2421  88F8 CD 71 7F     	call DRAW_SPRITE		; draw player sprite								;88f8	cd 71 7f
2422  88FB
2423  88FB              ; -- draw JUMPER W(aiting) sprite on screen
2424  88FB 2A 0B 78     	ld hl,(JUMPER_W_VADR)	; JUMPER W(aiting) VRAM address						;88fb	2a 0b 78
2425  88FE DD 21 39 7A  	ld ix,SPR_BUF_JUMPER_W	; JUMPER W(aiting) sprite buffer					;88fe	dd 21 39 7a
2426  8902 06 07        	ld b,7					; 7 lines - sprite height							;8902	06 07
2427  8904 0E 03        	ld c,3					; 3 bytes - sprite width (12px)						;8904	0e 03
2428  8906 CD 8C 7F     	call DRAW_SPRITE_T		; draw sprite with transparency						;8906	cd 8c 7f
2429  8909
2430  8909              ; -- clear (draw red) screen area next to Life Icon sprites
2431  8909 3A 2A 78     	ld a,(LIFE_COUNTER)		; a - life counter									;8909	3a 2a 78
2432  890C 3D           	dec a					; decrement by 1									;890c	3d
2433  890D CB 27        	sla a					; lives left * 2 bytes width sprite					;890d	cb 27
2434  890F 4F           	ld c,a					; c - X offset on screen for Life Icon to delete	;890f	4f
2435  8910 06 00        	ld b,0					; bc - offset on screen								;8910	06 00
2436  8912 21 20 77     	ld hl,VRAM+(57*32)+0 	; base VRAM address at coord (0,57)px [$7720]		;8912	21 20 77
2437  8915 09           	add hl,bc				; VRAM address of area to cleanup					;8915	09
2438  8916 11 1E 00     	ld de,30				; de - 30 bytes per line (2 covered in loop)		;8916	11 1e 00
2439  8919 3E FF        	ld a,%11111111			; a - 4 red pixels									;8919	3e ff
2440  891B 06 07        	ld b,7					; 7 lines - sprite height							;891b	06 07
2441  891D              GIAH_CLR_NEXT_LINE3:
2442  891D 0E 02        	ld c,2					; 2 bytes (8px) - sprite width						;891d	0e 02
2443  891F              GTAH_CLR_NEXT_BYTE3:
2444  891F 77           	ld (hl),a				; draw 4 red pixels									;891f	77
2445  8920 23           	inc hl					; next screen byte									;8920	23
2446  8921 0D           	dec c					; decrement bytes counter							;8921	0d
2447  8922 20 FB        	jr nz,GTAH_CLR_NEXT_BYTE3	; repeat for all 2 bytes (8px)					;8922	20 fb
2448  8924 19           	add hl,de				; address of next screen line						;8924	19
2449  8925 10 F6        	djnz GIAH_CLR_NEXT_LINE3; repeat for all 7 lines							;8925	10 f6
2450  8927
2451  8927              ; -- darw left and right Stand on screen
2452  8927 CD B2 83     	call DRAW_STANDS_LR		; redraw left and right stands						;8927	cd b2 83
2453  892A
2454  892A              ; -- delay ~150 ms ----
2455  892A 01 FF 4F     	ld bc,$4fff				; delay counter (532461T) (148.75 ms) 				;892a	01 ff 4f
2456  892D C3 9F 88     	jp INT_EXIT_DELAY		; ------ wait delay and return						;892d	c3 9f 88
2457  8930
2458  8930              ;******************************************************************************************
2459  8930              ; Play short low note sound
2460  8930              ; Played when jumped down. Either on floor on trampoline
2461  8930              PLAY_SND_LOW:
2462  8930 21 FF 03     	ld hl,1023				; sound freq (half cycle time)						;8930	21 ff 03
2463  8933 01 03 00     	ld bc,3					; sound length (cycles to play)						;8933	01 03 00
2464  8936 C3 33 87     	jp PLAY_SND_WAVE		; ----- End of proc ----							;8936	c3 33 87
2465  8939
2466  8939              ;**************************************************************************************
2467  8939              ; Play Start Game Melody
2468  8939              ; Plays records contains 2 bytes each - tone byte and duration byte
2469  8939              ; Bytes these are indexes to tables with predefined values of duration and frequency (half period time)
2470  8939              ; of waves produced.
2471  8939              PLAY_MEL_START:
2472  8939 21 0E 8A     	ld hl,MELODY_GAME_START	; Game Start Melody data 							;8939	21 0e 8a
2473  893C 06 13        	ld b,19					; 19 notes to play									;893c	06 13
2474  893E              PLAY_MELODY:
2475  893E 56           	ld d,(hl)				; d - tone byte										;893e	56
2476  893F 23           	inc hl					; next address in note definition					;893f	23
2477  8940 5E           	ld e,(hl)				; e - note duration									;8940	5e
2478  8941 1D           	dec e					; dec e												;8941	1d
2479  8942 23           	inc hl					; hl - address of next note to play					;8942	23
2480  8943 CD 50 89     	call PLAY_SND_NOTE		; play note or pause depending on d,e				;8943	cd 50 89
2481  8946 10 F6        	djnz PLAY_MELODY		; repeat for all notes								;8946	10 f6
2482  8948 C9           	ret						; ---------- End of Proc -------					;8948	c9
2483  8949
2484  8949              ;**************************************************************************************
2485  8949              ; Play Game Over Melody
2486  8949              ; Just define hl to points to last 9 notes of main melody and use PLAY_MELODY code
2487  8949              PLAY_MEL_GAME_OVER:
2488  8949 21 22 8A     	ld hl,MELODY_GAME_OVER	; Game Over Melody									;8949	21 22 8a
2489  894C 06 09        	ld b,9					; 9 notes to play									;894c	06 09
2490  894E 18 EE        	jr PLAY_MELODY			; play melody and return							;894e	18 ee
2491  8950
2492  8950              ;***************************************************************************************
2493  8950              ; Plays one Sound/Note from predefined tables
2494  8950              ; IN: e - note length byte (as index from defined table)
2495  8950              ;     d - note frequency byte (as index from defined table) - 0 means pause note
2496  8950              PLAY_SND_NOTE:
2497  8950 E5           	push hl					; save hl											;8950	e5
2498  8951 D5           	push de					; save de											;8951	d5
2499  8952 C5           	push bc					; save bc											;8952	c5
2500  8953              ; -- determine sound (or pause) length
2501  8953 7B           	ld a,e					; note length byte (as table index)					;8953	7b
2502  8954 3D           	dec a					; valid values 0..xx								;8954	3d
2503  8955 F5           	push af					; save a 											;8955	f5
2504  8956              ; -- determine sound frequency (0 means pause note)
2505  8956 7A           	ld a,d					; note frequency byte (as table index)				;8956	7a
2506  8957 B7           	or a					; check if pause note to play						;8957	b7
2507  8958 28 36        	jr z,PLAY_PAUSE_NOTE	; yes - play pause note								;8958	28 36
2508  895A              ; -- valid note
2509  895A 3D           	dec a					; valid table index 0..xx							;895a	3d
2510  895B CB 27        	sla a					; a = a * 2	- 16bit freq values						;895b	cb 27
2511  895D 4F           	ld c,a					; c - offset for current sound/note					;895d	4f
2512  895E AF           	xor a					; a - 0 											;895e	af
2513  895F 47           	ld b,a					; bc - offset for note freq 						;895f	47
2514  8960 F1           	pop af					; a - offset for note length  						;8960	f1
2515  8961              ; -- get frequency (half period time) for current note
2516  8961 21 A8 89     	ld hl,TAB_SND_FREQ		; table with frequency related values				;8961	21 a8 89
2517  8964 09           	add hl,bc				; address of freq for current sound					;8964	09
2518  8965 5E           	ld e,(hl)				; e - low byte of frequency							;8965	5e
2519  8966 23           	inc hl					; points to high byte of data						;8966	23
2520  8967 56           	ld d,(hl)				; de - sound frequency								;8967	56
2521  8968 D5           	push de					; de - sound frequency (half period time)			;8968	d5
2522  8969              ; -- get duration for current note
2523  8969 21 E6 89     	ld hl,TAB_SND_DUR_BASE	; sound length table								;8969	21 e6 89
2524  896C CB 39        	srl c					; bc - offset * 2									;896c	cb 39
2525  896E 09           	add hl,bc				; address of of current sound length				;896e	09
2526  896F 5E           	ld e,(hl)				; e - sound length									;896f	5e
2527  8970 16 00        	ld d,0					; de - sound length									;8970	16 00
2528  8972              ; -- calculate sound
2529  8972 21 05 8A     	ld hl,TAB_SND_DUR_MUL	; table with sound length multiplers				;8972	21 05 8a
2530  8975 4F           	ld c,a					; bc - offset to sound length factor				;8975	4f
2531  8976 09           	add hl,bc				; hl - address of sound length factor				;8976	09
2532  8977 46           	ld b,(hl)				; b - sound length multiply factor					;8977	46
2533  8978              ; -- calculate sound length -> hl = b * de
2534  8978 D5           	push de					; sound base length									;8978	d5
2535  8979 E1           	pop hl					; copy de to hl										;8979	e1
2536  897A              PSN_MULTIPLY:
2537  897A 19           	add hl,de				; hl = de * b (sound length)						;897a	19
2538  897B 10 FD        	djnz PSN_MULTIPLY		; keep adding hl+de (b times)						;897b	10 fd
2539  897D E5           	push hl					; copy sound length to bc							;897d	e5
2540  897E C1           	pop bc					; bc - sound length (cycles to play)				;897e	c1
2541  897F E1           	pop hl					; hl - sound freq (half cycle time)					;897f	e1
2542  8980              ;-- play sound (hl freq, bc time)
2543  8980              PSN_PLAY_CYCLE:
2544  8980 3A 2B 78     	ld a,(IOLATCH_SHADOW)	; a - current IOLATCH value							;8980	3a 2b 78
2545  8983 57           	ld d,a					; d - procedure parameter							;8983	57
2546  8984 CD 40 87     	call PLAY_SND_CYCLE		; play 1 cycle of sound								;8984	cd 40 87
2547  8987 0B           	dec bc					; dec cycle counter									;8987	0b
2548  8988 79           	ld a,c					; check if 0										;8988	79
2549  8989 B0           	or b					; a = b|c											;8989	b0
2550  898A 20 F4        	jr nz,PSN_PLAY_CYCLE	; repeat until 0									;898a	20 f4
2551  898C              PLAY_SND_EXIT:
2552  898C C1           	pop bc					; restore bc										;898c	c1
2553  898D D1           	pop de					; restore de										;898d	d1
2554  898E E1           	pop hl					; restore hl										;898e	e1
2555  898F C9           	ret						; ---------- End of Proc							;898f	c9
2556  8990
2557  8990              ;***************************************************************************************
2558  8990              ; Plays Pause (silent) Sound/Note
2559  8990              ; IN: a (on stack) - note duration byte (as index from defined table)
2560  8990              ;     bc,de,hl saved on stack
2561  8990              PLAY_PAUSE_NOTE:
2562  8990 F1           	pop af					; a - note length byte (as index)					;8990	f1
2563  8991 4F           	ld c,a					; c - offset to note length table					;8991	4f
2564  8992 AF           	xor a					; a = 0												;8992	af
2565  8993 47           	ld b,a					; bc - offset to note length table					;8993	47
2566  8994 21 05 8A     	ld hl,TAB_SND_DUR_MUL	; table with sound length multiplers				;8994	21 05 8a
2567  8997 09           	add hl,bc				; hl - address of sound length factor				;8997	09
2568  8998 46           	ld b,(hl)				; b - sound length multiply factor					;8998	46
2569  8999 21 36 19     	ld hl,01936h			; constant for base length							;8999	21 36 19
2570  899C              ; -- calculate sound length -> hl = b * de
2571  899C E5           	push hl					; pause base length									;899c	e5
2572  899D D1           	pop de					; copy hl to de										;899d	d1
2573  899E              PPN_MULTIPLY:
2574  899E 19           	add hl,de				; hl = de * b (pause length)						;899e	19
2575  899F 10 FD        	djnz PPN_MULTIPLY		; keep adding hl+de (b times)						;899f	10 fd
2576  89A1              ; -- wait calculated delay as if this was note
2577  89A1              PPN_FAKE_PLAY:
2578  89A1 2B           	dec hl					; dec delay counter									;89a1	2b
2579  89A2 7D           	ld a,l					; check if 0										;89a2	7d
2580  89A3 B4           	or h					; a = h|l											;89a3	b4
2581  89A4 20 FB        	jr nz,PPN_FAKE_PLAY		; repeat until 0									;89a4	20 fb
2582  89A6 18 E4        	jr PLAY_SND_EXIT		; jum to proc exit with restore bc,de,hl			;89a6	18 e4
2583  89A8
2584  89A8
2585  89A8              ;***************************************************************************
2586  89A8              ; Sound Data - sound frequency (half period time) table - 16 bit values
2587  89A8              ; Bigger value means lower sound note
2588  89A8              TAB_SND_FREQ:
2589  89A8 72 02        	defw	$0272			;89a8	72 02
2590  89AA 4F 02        	defw	$024f			;89aa	4f 02
2591  89AC 2E 02        	defw	$022e			;89ac	2e 02
2592  89AE 0E 02        	defw	$020e			;89ae	0e 02
2593  89B0 F1 01        	defw	$01f1			;89b0	f1 01
2594  89B2 D5 01        	defw	$01d5			;89b2	d5 01
2595  89B4 B7 01        	defw	$01b7			;89b4	b7 01
2596  89B6 9E 01        	defw	$019e			;89b6	9e 01
2597  89B8 86 01        	defw	$0186			;89b8	86 01
2598  89BA 70 01        	defw	$0170			;89ba	70 01
2599  89BC 5B 01        	defw	$015b			;89bc	5b 01
2600  89BE 48 01        	defw	$0148			;89be	48 01
2601  89C0 35 01        	defw	$0135			;89c0	35 01
2602  89C2 23 01        	defw	$0123			;89c2	23 01
2603  89C4 13 01        	defw	$0113			;89c4	13 01
2604  89C6 03 01        	defw	$0103			;89c6	03 01
2605  89C8 F4 00        	defw	$00f4			;89c8	f4 00
2606  89CA E6 00        	defw	$00e6			;89ca	e6 00
2607  89CC D9 00        	defw	$00d9			;89cc	d9 00
2608  89CE CD 00        	defw	$00cd			;89ce	cd 00
2609  89D0 C1 00        	defw	$00c1			;89d0	c1 00
2610  89D2 B6 00        	defw	$00b6			;89d2	b6 00
2611  89D4 AB 00        	defw	$00ab			;89d4	ab 00
2612  89D6 A1 00        	defw	$00a1			;89d6	a1 00
2613  89D8 98 00        	defw	$0098			;89d8	98 00
2614  89DA 8F 00        	defw	$008f			;89da	8f 00
2615  89DC 87 00        	defw	$0087			;89dc	87 00
2616  89DE 7F 00        	defw	$007f			;89de	7f 00
2617  89E0 78 00        	defw	$0078			;89e0	78 00
2618  89E2 70 00        	defw	$0070			;89e2	70 00
2619  89E4 6A 00        	defw	$006a			;89e4	6a 00
2620  89E6
2621  89E6              ;****************************************************************************************************
2622  89E6              ; Sound Data - base sound length table
2623  89E6              ; This values multiplied by factor (TAB_SND_DUR_MUL) determine time of played notes
2624  89E6              ; Sound length must be adjusted for every note because higher note wave "plays faster"
2625  89E6              TAB_SND_DUR_BASE:
2626  89E6 0A           	defb	$0a				;89e6	0a
2627  89E7 0B           	defb	$0b				;89e7	0b
2628  89E8 0C           	defb	$0c				;89e8	0c
2629  89E9 0C           	defb	$0c				;89e9	0c
2630  89EA 0D           	defb	$0d				;89ea	0d
2631  89EB 0E           	defb	$0e				;89eb	0e
2632  89EC 0F           	defb	$0f				;89ec	0f
2633  89ED 0F           	defb	$0f				;89ed	0f
2634  89EE 10           	defb	$10				;89ee	10
2635  89EF 11           	defb	$11				;89ef	11
2636  89F0 12           	defb	$12				;89f0	12
2637  89F1 13           	defb	$13				;89f1	13
2638  89F2 15           	defb	$15				;89f2	15
2639  89F3 16           	defb	$16				;89f3	16
2640  89F4 17           	defb	$17				;89f4	17
2641  89F5 19           	defb	$19				;89f5	19
2642  89F6 1A           	defb	$1a				;89f6	1a
2643  89F7 1C           	defb	$1c				;89f7	1c
2644  89F8 1D           	defb	$1d				;89f8	1d
2645  89F9 1F           	defb	$1f				;89f9	1f
2646  89FA 21           	defb	$21				;89fa	21
2647  89FB 23           	defb	$23				;89fb	23
2648  89FC 25           	defb	$25				;89fc	25
2649  89FD 27           	defb	$27				;89fd	27
2650  89FE 29           	defb	$29				;89fe	29
2651  89FF 2C           	defb	$2c				;89ff	2c
2652  8A00 2E           	defb	$2e				;8a00	2e
2653  8A01 31           	defb	$31				;8a01	31
2654  8A02 34           	defb	$34				;8a02	34
2655  8A03 35           	defb	$35				;8a03	35
2656  8A04 3A           	defb	$3a				;8a04	3a
2657  8A05
2658  8A05              ;******************************************************************************************
2659  8A05              ; Sound Data - sound length multiply factor table
2660  8A05              ; This values multiplied by base length (from TAB_SND_DUR_BASE) determine time of played notes
2661  8A05              TAB_SND_DUR_MUL:
2662  8A05 01 02 03 04  	defb	$01,$02,$03,$04,$06,$08,$0c,$10,$18		;8a05	01 02 03 04 06 08 0c 10 18
2662  8A09 06 08 0C 10
2662  8A0D 18
2663  8A0E
2664  8A0E              ;******************************************************************************************
2665  8A0E              ; Melody Data - played at Start of Game - 2 x 8 bit value for every note (tone,length)
2666  8A0E              ; 19 Notes
2667  8A0E              ; 1st value - frequency byte, 0 - means pause note
2668  8A0E              ; 2nd value - sound length byte
2669  8A0E              MELODY_GAME_START:
2670  8A0E 15 04        	defb	$15,$04			;8a0e	15 04
2671  8A10 1E 05        	defb	$1e,$05			;8a10	1e 05
2672  8A12 1C 02        	defb	$1c,$02			;8a12	1c 02
2673  8A14 1A 04        	defb	$1a,$04			;8a14	1a 04
2674  8A16 1C 04        	defb	$1c,$04			;8a16	1c 04
2675  8A18 1A 04        	defb	$1a,$04			;8a18	1a 04
2676  8A1A 17 04        	defb	$17,$04			;8a1a	17 04
2677  8A1C 15 04        	defb	$15,$04			;8a1c	15 04
2678  8A1E 12 07        	defb	$12,$07			;8a1e	12 07
2679  8A20 00 04        	defb	$00,$04			;8a20	00 04
2680  8A22              ;******************************************************************************************
2681  8A22              ; Melody Data - played at End of Game - 2 x 8 bit value for every note (tone,length)
2682  8A22              ; 9 Notes
2683  8A22              ; 1st value - frequency byte, 0 - means pause note
2684  8A22              ; 2nd value - sound length byte
2685  8A22              MELODY_GAME_OVER:
2686  8A22 15 04        	defb	$15,$04		;8a22	15 04
2687  8A24 17 04        	defb	$17,$04		;8a24	17 04
2688  8A26 1C 04        	defb	$1c,$04		;8a26	1c 04
2689  8A28 1A 04        	defb	$1a,$04		;8a28	1a 04
2690  8A2A 19 04        	defb	$19,$04		;8a2a	19 04
2691  8A2C 17 04        	defb	$17,$04		;8a2c	17 04
2692  8A2E 19 04        	defb	$19,$04		;8a2e	19 04
2693  8A30 1A 08        	defb	$1a,$08		;8a30	1a 08
2694  8A32 00           	defb	$00			;8a32	00
2695  8A33
# file closed: l:\vz-dis-games\Circus\CIRCUS.asm
