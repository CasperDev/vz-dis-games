# file opened: l:\vz-dis-games\GhostHunter\ghost-hunter.asm
   1  0000              ;***********************************************************************************************
   2  0000              ;
   3  0000              ; 	Ghost Hunter aka PAC
   4  0000              ;   Disect by Casper 08.01.2020
   5  0000              ;
   6  0000              ;	Verified with SjASMPlus Z80 Cross-Assembler v1.14.3 (https://github.com/z00m128/sjasmplus)
   7  0000              ;-----------------------------------------------------------------------------------------------
   8  0000              ;
   9  0000              ;   Structure (used only at startup - overriden later):
  10  0000              ;      	7ae9	BASIC_START - Basic Program with USR(0)
  11  0000              ;      	7b0c	Basic garbage data. Used latter as Collision Map
  12  0000              ;
  13  0000              ;       --------------------------------------------------------
  14  0000              ;
  15  0000              ; 	Structure
  16  0000              ;      	7800	CMAP - Collision Map - keeps track of Game Objects positions
  17  0000              ;
  18  0000              ;		8000	Main Entry Point. Jump to Game Init routine
  19  0000              ;      	8003 	Game Global Variables
  20  0000              ;       8034	Sound generation routines
  21  0000              ;		806f	IOLATCH Shadow variable (usual system variable is not used)
  22  0000              ;		8070	Game Score maitenance routines
  23  0000              ; 		80d5	Game Init. Sets Input preferences (using Joystick or Keys only)
  24  0000              ;
  25  0000              ;		80fa	Game Start. Initialize Game and wait for user to start.
  26  0000              ;		8132	Game Level Init. Initialize Game Global Variables and Collision Map for this Level
  27  0000              ;		8187	Game Level Start. Draws screen, resets data for Player, Ghosts and Heart (Bonus)
  28  0000
  29  0000              ;		81fc	Main Game Loop. Indefinitelly calls update/draw subroutines
  30  0000
  31  0000              ;		821a	Game Loop Subroutine - Update Heart.
  32  0000              ;		827e	Init Heart Properties. Initialize Heart related timers and flag.
  33  0000              ;		8291	Game Over Screen
  34  0000              ;		82ad	Print Text related helper routines. Also clear screen proc (text mode).
  35  0000              ;		8329	Text Data. Texts data to print on screen (text mode)
  36  0000              ;		83ea	Draw Ghosts helper routines.
  37  0000              ; 		8403	Random (not really) generate function.
  38  0000              ;		840a	Game Loop Subroutine - Update screen colors when Player chases Ghosts
  39  0000              ;		844d	Game Loop Subroutine - Update Ghosts (except Red 2) moves and check collision with Player.
  40  0000              ;		844d	Game Loop Subroutine - Update Ghost Red 2 moves and check collision with Player.
  41  0000              ;		84eb	Local variables for Update Ghosts routines.
  42  0000              ;		84ef	Subroutines for Update Ghosts (drawing and move logic)
  43  0000              ;		8678	Collision Map helper routines.
  44  0000              ;		86a6	Subroutines for Update Ghosts (drawing and move logic) cont.
  45  0000              ;		86dc	Kill Player routine - end of Game or just decrement Life Counter and start over.
  46  0000              ;		8731	Flash Screen routine. Inverts all pixels on screen.
  47  0000              ;		875d	Delay helper procedure.
  48  0000              ;		8764	Game Loop Subroutine - Update Player moves, check input and collision with Dots,
  49  0000              ;				Power Pills, Heart and also Ghosts if game is in Chase Mode.
  50  0000              ;		8815	Test Kill Ghost. Test collision beetween Player and Ghost (only in Chase Mode)
  51  0000              ;		883a	Kill Ghost. Reward Player and respawn killed Ghost with random delay (Freeze)
  52  0000              ;		88e3	Test Eat Dot, Power Pill or Heart.
  53  0000              ;		88fd	Eat Power Pill. Reward Player and play Sound
  54  0000              ;		891a	Eat Dot. Reward Player and Speed Up Ghost Red 2 in certain cases
  55  0000              ;		8949	Eat Heart. Reward Player and reinitialize Heart properties
  56  0000              ;		8975	Update Player routines - (cont.)
  57  0000              ;		8a22	Game Loop Subroutine - Draw Freezed Ghost (with decrement freeze timer)
  58  0000              ;		8a5d	Game Loop Subroutine - Draw Dots and Pills. Also check if Level is Completed (no Dots left).
  59  0000              ;		8ae2	Level Up entry point.
  60  0000              ;		8aec	Local variables for above routines.
  61  0000              ;		8aee	Draw Level Screen including clear screen and set Graphics Mode
  62  0000              ;
  63  0000              ;		8af5	Collision Map - Fill Passages base on data in Screen Data Blocks
  64  0000              ;		8b52	Collision Map - Fill Dots and Pills base on data in Screen Data Blocks
  65  0000              ;		8bc5	Draw Maze Walls base on data in Screen Data Blocks (with clear screen first)
  66  0000              ;		8bc8	Draw Maze Walls base on data in Screen Data Blocks
  67  0000              ;
  68  0000              ;		8c2b	Update Show Walls Flag base on current Level
  69  0000              ;		8c34	Clear Screen Gfx Mode
  70  0000              ;
  71  0000              ;		8c4a	Data for Levels 1-5. Tweeked parameters for every Game Level
  72  0000              ;		8c5f	Screen Data Block - Horizontal Lines
  73  0000              ;		8cf0	Screen Data Block - Vertical Lines
  74  0000              ; 		8d41	Screen Data Block - Dots
  75  0000              ;		8d87	Screen Data Block - Power Pills
  76  0000              ;		8d91	Screen Data Block - Passages (Walls)
  77  0000              ;
  78  0000              ;		8ec9	Sprite Data - Player
  79  0000              ;		8ef1	Sprite Data - Empty
  80  0000              ;		8ef9	Not Used
  81  0000              ; 		8efa	Sprite Data - Player (cont)
  82  0000              ;		8f0a	Sprite Data - Ghosts
  83  0000              ;		8f3a	Sprite Data - Heart (Bonus)
  84  0000              ;
  85  0000              ;		8f42	Input Functions
  86  0000              ;		8f7c	Joystick Enabled Flag
  87  0000              ;
  88  0000              ;***********************************************************************************************
  89  0000
  90  0000              	MACRO	FNAME 	filename
  91  0000 ~            .beg		defb 	filename
  92  0000 ~            			block 	16-$+.beg
  93  0000 ~            			defb	0
  94  0000              	ENDM
  95  0000
  96  0000              	STRUCT 	TProps
  97  0000 ~            DIR			defb	0				; current move direction: UP (1), RIGHT (2), DOWN (3), LEFT (4)
  98  0000 ~            SHF			defb	0				; current sprite variant: 0 - regular, 1 - shifted 2px right
  99  0000              	ENDS
 100  0000
 101  0000              	STRUCT 	TGhost
 102  0000 ~            VADR		defw	0				; VRAM address of sprite
 103  0000 ~            PROPS		TProps	0,0				; Properties - Move Direction and Sprite Shift Flag
 104  0000 ~            FREEZE		defb	0				; Ghost Freeze Timer
 105  0000              	ENDS
 106  0000
 107  0000              	STRUCT	TPlayer
 108  0000 ~            SADR		defw	0				; adres of current used Sprite
 109  0000 ~            VADR		defw	0				; VRAM address of sprite
 110  0000 ~            PROPS		TProps	0,0				; Properties - Move Direction and Sprite Shift Flag
 111  0000 ~            ANIM		defb	0				; use animated sprite flag
 112  0000              	ENDS
 113  0000
 114  0000              ; Relative address 7AD1
 115  0000              ;***********************************************************************************************
 116  0000              ; File Header Block
 117  0000 56 5A 46 4F  	defb 	"VZFO"                  			; [0000] Magic
 118  0004              	FNAME	"PAC"
 118  0004 50 41 43    >.beg		defb 	"PAC"
 118  0007 00 00 00... >			block 	16-$+.beg
 118  0014 00          >			defb	0
 119  0015 F0           	defb	$F0             					; File Type
 120  0016 E9 7A            defw    BASIC_START        					; Destination/Basic Start address
 121  0018
 122  0018              ;***********************************************************************************************
 123  0018              ;
 124  0018              ;  B A S I C   S T A R T
 125  0018
 126  0018              	org		$7ae9
 127  7AE9
 128  7AE9              BASIC_START
 129  7AE9
 130  7AE9              ;***********************************************************************************************
 131  7AE9
 132  7AE9              ; 10 POKE30862,0:POKE30863,128:X=USR(0)
 133  7AE9              BASIC_10
 134  7AE9 08 7B        	defw	BASIC_END							; next basic line				;7ae9	08 7b
 135  7AEB 0A 00        	defw	10									; basic line number				;7aeb	0a 00
 136  7AED B1 33 30 38  	defb	$b1,"30862,0"						; POKE30862,0					;7aed	b1 33 30 38 36 32 2c 30
 136  7AF1 36 32 2C 30
 137  7AF5 3A           	defb	$3a									; instruction end				;7af5	3a
 138  7AF6 B1 33 30 38  	defb	$b1,"30863,128"						; POKE30863,128					;7af6	b1 33 30 38 36 33 2c 31 32 38
 138  7AFA 36 33 2C 31
 138  7AFE 32 38
 139  7B00 3A           	defb	$3a									; instruction end				;7b00	3a
 140  7B01 58 D5 C1 28  	defb	"X",$d5,$c1,"(0)"					; X=USR(0)						;7b01	58 d5 c1 28 30 29
 140  7B05 30 29
 141  7B07 00           	defb	0									; end of line					;7b07	00
 142  7B08
 143  7B08              BASIC_END
 144  7B08 00 00        	defw	0									; next line 0 means end 		;7b08	00 00
 145  7B0A 0A 00        	defw	10									; basic line number				;7b0a	0a 00
 146  7B0C
 147  7B0C
 148  7B0C              ;***********************************************************************************************
 149  7B0C              ; SYSTEM CONSTANTS
 150  7B0C              IOLATCH         	equ     $6800       		; (WR) Hardware IO Latch, (RD) Keyboard all Keys
 151  7B0C              VDG_GFX_COLORS_0	equ		%00001000 			; GFX MODE, background Green
 152  7B0C              VDG_GFX_COLORS_1	equ		%00011000 			; GFX MODE, background Buff
 153  7B0C              VDG_MODE_CSS_MASK	equ		%00011000  			; mask to keep current Gfx settings
 154  7B0C              BIT_SPK_MINUS   	equ     00100000b   		; Speake Pin (-)
 155  7B0C              BIT_SPK_PLUS   		equ     00000001b   		; Speake Pin (+)
 156  7B0C              SPEAKER_PINS		equ		BIT_SPK_MINUS|BIT_SPK_PLUS
 157  7B0C              VRAM            	equ     $7000       		; Video RAM GAME_INIT address
 158  7B0C
 159  7B0C
 160  7B0C              ;***********************************************************************************************
 161  7B0C              ; GAME CONSTANTS
 162  7B0C              CMAP_ADR			equ		$7800				; 2kb Buffer for Collision Map
 163  7B0C
 164  7B0C
 165  7B0C              ;***********************************************************************************************
 166  7B0C              ; Garbage (BASIC) Data
 167  7B0C              ; This area is used as part of Collision Map latter after Game initialization
 168  7B0C              ;
 169  7B0C              	org		$7b0c
 170  7B0C              ;---------------------------------------------------------------------------------------------
 171  7B0C
 172  7B0C              	include "basic_garbage.asm"
# file opened: l:\vz-dis-games\GhostHunter\basic_garbage.asm
   1+ 7B0C 64           	defb		$64		; garbage			;7b0c	64
   2+ 7B0D
   3+ 7B0D              BASIC_120:
   4+ 7B0D              ; 120 N1=N
   5+ 7B0D 16 7B        	defw		BASIC_130					; next line address		;7b0d	16 7b
   6+ 7B0F 78 00        	defw		120							; line number			;7b0f	78 00
   7+ 7B11 4E 31 D5 4E  	defb		"N1",$d5,"N",0				; Basic body			;7b11	4e 31 d5 4e 00
   7+ 7B15 00
   8+ 7B16
   9+ 7B16              BASIC_130:
  10+ 7B16              ; 130 GOSUB1000
  11+ 7B16 20 7B        	defw		BASIC_140					; next line address		;7b16	20 7b
  12+ 7B18 82 00        	defw		130							; line number			;7b18	82 00
  13+ 7B1A 91 31 30 30  	defb		$91,"1000",0				; Basic body			;7b1a	91 31 30 30 30 00
  13+ 7B1E 30 00
  14+ 7B20
  15+ 7B20              BASIC_140:
  16+ 7B20              ; 140 SA=N*256+N1
  17+ 7B20 30 7B        	defw		BASIC_150					; next line address		;7b20	30 7b
  18+ 7B22 8C 00        	defw		140							; line number			;7b22	8c 00
  19+ 7B24 53 41 D5 4E  	defb		"SA",$d5,"N",$cf,"256",$cd,"N1",0; Basic Body		;7b24	53 41 d5 4e cf 32 35 36 cd 4e 31 00
  19+ 7B28 CF 32 35 36
  19+ 7B2C CD 4E 31 00
  20+ 7B30
  21+ 7B30              BASIC_150:
  22+ 7B30              ; 150 PRINT"STAR 1 1A ??????
  23+ 7B30 4D 7B        	defw		BASIC_160					; next line address		;7b30	4d 7b
  24+ 7B32 96 00        	defw		150							; line number			;7b32	96 00
  25+ 7B34 B2 22 53 54  	defb		$b2,$22,"STAR",$09,"1",$09,"1A"	; Basic body		;7b34	b2 22 53 54 41 52 09 31 09 31 41
  25+ 7B38 41 52 09 31
  25+ 7B3C 09 31 41
  26+ 7B3F 03 03 80 B2  	defb		$03,$03,$80,$b2,$00,$44,$1f,$8f,$1b,$fc,0,0,0,0 ; corrupted data		;7b3f	03 03 80 b2 00 44 1f 8f 1b fc 00 00 00 00
  26+ 7B43 00 44 1F 8F
  26+ 7B47 1B FC 00 00
  26+ 7B4B 00 00
  27+ 7B4D
  28+ 7B4D              BASIC_160:
  29+ 7B4D              ; 160 GOSUB1000
  30+ 7B4D 57 7B        	defw		BASIC_170					; next line address		;7b4d	57 7b
  31+ 7B4F A0 00        	defw		160							; line number			;7b4f	a0 00
  32+ 7B51 91 31 30 30  	defb		$91,"1000",0				; Basic body			;7b51	91 31 30 30 30 00
  32+ 7B55 30 00
  33+ 7B57
  34+ 7B57              BASIC_170:
  35+ 7B57              ; 170 N1=N
  36+ 7B57 60 7B        	defw		BASIC_180					; next line address		;7b57	60 7b
  37+ 7B59 AA 00        	defw		170							; line number			;7b59	aa 00
  38+ 7B5B 4E 31 D5 4E  	defb      "N1",$d5,"N",0  		    ; Basic body            ;7b5b	4e 31 d5 4e 00
  38+ 7B5F 00
  39+ 7B60
  40+ 7B60              BASIC_180:
  41+ 7B60              ; 180 GOSUB1000
  42+ 7B60 6A 7B        	defw      BASIC_190			        ; next line addtess     ;7b60	6a 7b
  43+ 7B62 B4 00        	defw		180							; line number			;7b62	b4 00
  44+ 7B64 91 31 30 30  	defb      $91,"1000",0    	        ; Basic body            ;7b64	91 31 30 30 30 00
  44+ 7B68 30 00
  45+ 7B6A
  46+ 7B6A              BASIC_190:
  47+ 7B6A              ; 190 TF=N*256+N1
  48+ 7B6A 7A 7B        	defw      BASIC_200                   ; next line address		;7b6a	7a 7b
  49+ 7B6C BE 00        	defw		190							; line number			;7b6c	be 00
  50+ 7B6E 54 46 D5 4E  	defb      "TF",$d5,"N",$cf,"256",$cd,"N1",0   ; Basic body    ;7b6e	54 46 d5 4e cf 32 35 36 cd 4e 31 00
  50+ 7B72 CF 32 35 36
  50+ 7B76 CD 4E 31 00
  51+ 7B7A
  52+ 7B7A              BASIC_200:
  53+ 7B7A              ; 200 PRINT"NO. OF BYTES TO TRANS :-?"TF
  54+ 7B7A 9D 7B        	defw      BASIC_210			        ; next line address     ;7b7a	9d 7b
  55+ 7B7C C8 00        	defw      200			                ; line number           ;7b7c	c8 00
  56+ 7B7E B2 22 4E 4F  	defb      $b2,$22,"NO. OF BYTES TO TRANS :-?",$22,"TF",0      ;7b7e	b2 22 4e 4f 2e 20 4f 46 20 42 59 54 45 53 20 54 4f 20 54 52 41 4e 53 20 3a 2d 3f 22 54 46 00
  56+ 7B82 2E 20 4F 46
  56+ 7B86 20 42 59 54
  56+ 7B8A 45 53 20 54
  56+ 7B8E 4F 20 54 52
  56+ 7B92 41 4E 53 20
  56+ 7B96 3A 2D 3F 22
  56+ 7B9A 54 46 00
  57+ 7B9D
  58+ 7B9D              BASIC_210:
  59+ 7B9D              ; 210 GOSUB1000
  60+ 7B9D A7 7B        	defw      BASIC_220			        ; next line address     ;7b9d	a7 7b
  61+ 7B9F D2 00        	defw      210                         ; line number   		;7b9f	d2 00
  62+ 7BA1 91 31 30 30  	defb      $91,"1000",0	            ; Basic body            ;7ba1	91 31 30 30 30 00
  62+ 7BA5 30 00
  63+ 7BA7
  64+ 7BA7              BASIC_220:
  65+ 7BA7              ; 220 N1=N
  66+ 7BA7 B0 7B        	defw      BASIC_230                   ; nexy line address     ;7ba7	b0 7b
  67+ 7BA9 DC 00        	defw      220                         ; line number		    ;7ba9	dc 00
  68+ 7BAB 4E 31 D5 4E  	defb      "N1",$d5,"N",0              ; Basic body		    ;7bab	4e 31 d5 4e 00
  68+ 7BAF 00
  69+ 7BB0
  70+ 7BB0              BASIC_230:
  71+ 7BB0              ; 230 GOSUB1000
  72+ 7BB0 BA 7B            defw      BASIC_240                   ; nexy line address     ;7bb0	ba 7b
  73+ 7BB2 E6 00        	defw      230                         ; line number		    ;7bb2	e6 00
  74+ 7BB4 91 31 30 30  	defb      $91,"1000",0	            ; Basic body            ;7bb4	91 31 30 30 30 00
  74+ 7BB8 30 00
  75+ 7BBA
  76+ 7BBA              BASIC_240:
  77+ 7BBA              ; 240 EX=N*256+N1
  78+ 7BBA CA 7B        	defw      BASIC_250                   ; nexy line address     ;7bba	ca 7b
  79+ 7BBC F0 00        	defw      240                         ; line number		    ;7bbc	f0 00
  80+ 7BBE 45 58 D5 4E  	defb      "EX",$d5,"N",$cf,"256",$cd,"N1",0 ; Basic body		;7bbe	45 58 d5 4e cf 32 35 36 cd 4e 31 00
  80+ 7BC2 CF 32 35 36
  80+ 7BC6 CD 4E 31 00
  81+ 7BCA
  82+ 7BCA              BASIC_250:
  83+ 7BCA              ; 250 PRINT"EXECUTION ADRESS :- "EX
  84+ 7BCA E8 7B        	defw      BASIC_255                   ; nexy line address     ;7bca	e8 7b
  85+ 7BCC FA 00        	defw      250                         ; line number		    ;7bcc	fa 00
  86+ 7BCE B2 22 45 58  	defb      $b2,$22,"EXECUTION ADRESS :- ",$22,"EX",0	        ;7bce	b2 22 45 58 45 43 55 54 49 4f 4e 20 41 44 52 45 53 53 20 3a 2d 20 22 45 58 00
  86+ 7BD2 45 43 55 54
  86+ 7BD6 49 4F 4E 20
  86+ 7BDA 41 44 52 45
  86+ 7BDE 53 53 20 3A
  86+ 7BE2 2D 20 22 45
  86+ 7BE6 58 00
  87+ 7BE8
  88+ 7BE8              BASIC_255:
  89+ 7BE8              ; 255 PRINT:PRINT"LOADIND DATA"
  90+ 7BE8 FE 7B        	defw      BASIC_260                   ; next line address     ;7be8	fe 7b
  91+ 7BEA FF 00        	defw      255                         ; line number		    ;7bea	ff 00
  92+ 7BEC B2 3A        	defb      $b2,":"			            ; Basic body            ;7bec	b2 3a
  93+ 7BEE B2 22 4C 4F  	defb      $b2,$22,"LOADIND DATA",$22,0; Basic body            ;7bee	b2 22 4c 4f 41 44 49 4e 44 20 44 41 54 41 22 00
  93+ 7BF2 41 44 49 4E
  93+ 7BF6 44 20 44 41
  93+ 7BFA 54 41 22 00
  94+ 7BFE
  95+ 7BFE              BASIC_260:
  96+ 7BFE              ; 260 FOR L=1 TO TF
  97+ 7BFE 0A 7C        	defw      BASIC_270                   ; next line address     ;7bfe	0a 7c
  98+ 7C00 04 01        	defw      260                         ; line number		    ;7c00	04 01
  99+ 7C02 81 4C D5 31  	defb      $81,"L",$d5,"1",$bd,"TF",0  ; Basic body            ;7c00	81 4c d5 31 bd 54 46 00
  99+ 7C06 BD 54 46 00
 100+ 7C0A
 101+ 7C0A              BASIC_270:
 102+ 7C0A              ; 270 GOSUB 1000
 103+ 7C0A 14 7C        	defw      BASIC_280                   ; next line address     ;7c0a	14 7c
 104+ 7C0C 0E 01        	defw      270                         ; line number		    ;7c0c	0e 01
 105+ 7C0E 91 31 30 30  	defb      $91,"1000",0	            ; Basic body            ;7c0e	91 31 30 30 30 00
 105+ 7C12 30 00
 106+ 7C14
 107+ 7C14              BASIC_280:
 108+ 7C14              ; 280 POKE SA,N
 109+ 7C14 1E 7C        	defw      BASIC_290                   ; next line address     ;7c14	1e 7c
 110+ 7C16 18 01        	defw      280                         ; line number		    ;7c16	18 01
 111+ 7C18 B1 53 41 2C  	defb      $b1,"SA,N",0		        ; Basic body            ;7c18	b1 53 41 2c 4e 00
 111+ 7C1C 4E 00
 112+ 7C1E
 113+ 7C1E              BASIC_290:
 114+ 7C1E              ; 290 SA = SA + 1
 115+ 7C1E 2A 7C            defw      BASIC_300                   ; next line address     ;7c1e	2a 7c
 116+ 7C20 22 01        	defw      290                         ; line number		    ;7c20	22 01
 117+ 7C22 53 41 D5 53  	defb      "SA",$d5,"SA",$cd,"1",0		; Basic body            ;7c22	53 41 d5 53 41 cd 31 00
 117+ 7C26 41 CD 31 00
 118+ 7C2A
 119+ 7C2A              BASIC_300:
 120+ 7C2A              ; 300 NEXT
 121+ 7C2A 30 7C            defw      BASIC_310                   ; next line address     ;7c2a	30 7c
 122+ 7C2C 2C 01        	defw      300                         ; line number		    ;7c2c	2c 01
 123+ 7C2E 87 00        	defb      $87,0		                ; Basic body            ;7c2e	87 00
 124+ 7C30
 125+ 7C30              BASIC_310:
 126+ 7C30              ; 310 N=INT(EX/256) : N2=EX-N1*256
 127+ 7C30 4E 7C        	defw      BASIC_320                   ; next line address     ;7c30	4e 7c
 128+ 7C32 36 01        	defw      310                         ; line number		    ;7c32	36 01
 129+ 7C34 4E 31 D5 D8  	defb      "N1",$d5,$d8,"(EX",$d0,"256)",$3a    ; Basic body   ;7c34	4e 31 d5 d8 28 45 58 d0 32 35 36 29 3a
 129+ 7C38 28 45 58 D0
 129+ 7C3C 32 35 36 29
 129+ 7C40 3A
 130+ 7C41 4E 32 D5 45  	defb      "N2",$d5,"EX",$ce,"N1",$cf,"256",0  ; Basic body	;7c41	4e 32 d5 45 58 ce 4e 31 cf 32 35 36 00
 130+ 7C45 58 CE 4E 31
 130+ 7C49 CF 32 35 36
 130+ 7C4D 00
 131+ 7C4E
 132+ 7C4E              BASIC_320:
 133+ 7C4E              ; 320 POKE 30862,N2 : POKE 30863,N1
 134+ 7C4E 66 7C            defw      BASIC_325                   ; next line address     ;7c4e	66 7c
 135+ 7C50 40 01        	defw      320                         ; line number		    ;7c50	40 01
 136+ 7C52 B1 33 30 38  	defb      $b1,"30862,N2",$3a          ; Basic body		    ;7c52	b1 33 30 38 36 32 2c 4e 32 3a
 136+ 7C56 36 32 2C 4E
 136+ 7C5A 32 3A
 137+ 7C5C B1 33 30 38  	defb      $b1,"30863,N1",0		    ; Basic body            ;7c5c	b1 33 30 38 36 33 2c 4e 31 00
 137+ 7C60 36 33 2C 4E
 137+ 7C64 31 00
 138+ 7C66              BASIC_325:
 139+ 7C66              ; 325 STOP
 140+ 7C66 6C 7C        	defw      BASIC_330                   ; next line address     ;7c66	6c 7c
 141+ 7C68 45 01        	defw      325                         ; line number		    ;7c68	45 01
 142+ 7C6A 94 00        	defb      $94,0               		; Basic body            ;7c6a	94 00
 143+ 7C6C
 144+ 7C6C              BASIC_330:
 145+ 7C6C              ; 330 X=USR(0)
 146+ 7C6C 77 7C        	defw      BASIC_990                   ; next line address     ;7c6c	77 7c
 147+ 7C6E 4A 01        	defw      330                         ; line number		    ;7c6e	4a 01
 148+ 7C70 58 D5 C1 28  	defb      "X",$d5,$c1,"(0)",0		    ; Basic body            ;7c70	58 d5 c1 28 30 29 00
 148+ 7C74 30 29 00
 149+ 7C77
 150+ 7C77              BASIC_990:
 151+ 7C77              ; 990 STOP
 152+ 7C77 7D 7C        	defw      BASIC_1000                  ; next line address     ;7c77	7d 7c
 153+ 7C79 DE 03        	defw      990                         ; line number		    ;7c79	de 03
 154+ 7C7B 94 00        	defb      $94,0			            ; Basic body            ;7c7b	94 00
 155+ 7C7D
 156+ 7C7D              BASIC_1000:
 157+ 7C7D              ; 1000 OUT 224,128
 158+ 7C7D 8A 7C        	defw      BASIC_1010                  ; next line address     ;7c7d	8a 7c
 159+ 7C7F E8 03        	defw      1000                        ; line number		    ;7c7f	e8 03
 160+ 7C81 A0 32 32 34  	defb      $a0,"224,128",0			    ; Basic body            ;7c81	a0 32 32 34 2c 31 32 38 00
 160+ 7C85 2C 31 32 38
 160+ 7C89 00
 161+ 7C8A
 162+ 7C8A              BASIC_1010:
 163+ 7C8A              ; 1010 A=INP(224) AND 128
 164+ 7C8A 9B 7C            defw      BASIC_1020                  ; next line address     ;7c8a	9b 7c
 165+ 7C8C F2 03        	defw      1010                        ; line number		    ;7c8c	f2 03
 166+ 7C8E 41 D5 DB 28  	defb      "A",$d5,$db,"(224)",$d2,"128",0    ; Basic body		;7c8e	41 d5 28 32 32 34 29 d2 31 32 38 00
 166+ 7C92 32 32 34 29
 166+ 7C96 D2 31 32 38
 166+ 7C9A 00
 167+ 7C9B
 168+ 7C9B              BASIC_1020:
 169+ 7C9B              ; 1020 IF A=0 THEN 1010
 170+ 7C9B A9 7C        	defw      BASIC_1030                  ; next line address     ;7c9b	a9 7c
 171+ 7C9D FC 03        	defw      1020		                ; line number           ;7c9d	fc 03
 172+ 7C9F 8F 41 D5 30  	defb      $8f,"A",$d5,"0",$ca,"1010",0  ; Basic body			;7c9f	8f 41 d5 30 ca 31 30 31 30 00
 172+ 7CA3 CA 31 30 31
 172+ 7CA7 30 00
 173+ 7CA9
 174+ 7CA9              BASIC_1030:
 175+ 7CA9              ; 1030 N=INP(224) AND 15
 176+ 7CA9 B9 7C        	defw      BASIC_1040                  ; next line address     ;7ca9	b9 7c
 177+ 7CAB 06 04        	defw      1030		                ; line number           ;7cab	06 04
 178+ 7CAD 4E D5 DB 28  	defb      "N",$d5,$db,"(224)",$d2,"15",0  ; Basic body		;7cad	4e d5 defb 28 32 32 34 29 d2 31 35 00
 178+ 7CB1 32 32 34 29
 178+ 7CB5 D2 31 35 00
 179+ 7CB9
 180+ 7CB9              BASIC_1040:
 181+ 7CB9              ; 1040 OUT 224,0
 182+ 7CB9 C4 7C        	defw      BASIC_1050                  ; next line address     ;7cb9	c4 7c
 183+ 7CBB 10 04        	defw      1040		                ; line number           ;7cbb	10 04
 184+ 7CBD A0 32 32 34  	defb      $a0,"224,0",0			    ; Basic body            ;7cbd	a0 32 32 34 2c 30 00
 184+ 7CC1 2C 30 00
 185+ 7CC4
 186+ 7CC4              BASIC_1050:
 187+ 7CC4              ; 1050 A=INP(224) AND 128
 188+ 7CC4 D5 7C        	defw      BASIC_1060                  ; next line address     ;7cc4	d5 7c
 189+ 7CC6 1A 04        	defw      1050		                ; line number           ;7cc6	1a 04
 190+ 7CC8 41 D5 DB 28  	defb      "A",$d5,$db,"(224)",$d2,"128",0 ; Basic body		;7cc8	41 d5 defb 28 32 32 34 29 d2 31 32 38 00
 190+ 7CCC 32 32 34 29
 190+ 7CD0 D2 31 32 38
 190+ 7CD4 00
 191+ 7CD5
 192+ 7CD5              BASIC_1060:
 193+ 7CD5              ; 1060 IF A=128 THAN 1050
 194+ 7CD5 E5 7C        	defw      BASIC_1070                  ; next line address     ;7cd5	e5 7c
 195+ 7CD7 24 04        	defw      1060		                ; line number           ;7cd7	24 04
 196+ 7CD9 8F 41 D5 31  	defb      $8f,"A",$d5,"128",$ca,"1050",0	; Basic body		;7cd9	8f 41 d5 31 32 38 ca 31 30 35 30 00
 196+ 7CDD 32 38 CA 31
 196+ 7CE1 30 35 30 00
 197+ 7CE5
 198+ 7CE5              BASIC_1070:
 199+ 7CE5              ; 1070 A=INP(224) AND 15
 200+ 7CE5 F5 7C        	defw      BASIC_1080                  ; next line address     ;7ce5	f5 7c
 201+ 7CE7 2E 04        	defw      1070		                ; line number           ;7ce7	2e 04
 202+ 7CE9 41 D5 DB 28  	defb      "A",$d5,$db,"(224)",$d2,"15",0 ; Basic body		    ;7ce9	41 d5 defb 28 32 32 34 29 d2 31 35 00
 202+ 7CED 32 32 34 29
 202+ 7CF1 D2 31 35 00
 203+ 7CF5
 204+ 7CF5              BASIC_1080:
 205+ 7CF5              ; 1080 N=N+A*16
 206+ 7CF5 02 7D            defw      BASIC_1090                  ; next line address     ;7cf5	02 7d
 207+ 7CF7 38 04        	defw      1080		                ; line number           ;7cf7	38 04
 208+ 7CF9 4E D5 4E CD  	defb      "N",$d5,"N",$cd,"A",$cf,"16",0	; Basic body		;7cf9	4e d5 4e cd 41 cf 31 36 00
 208+ 7CFD 41 CF 31 36
 208+ 7D01 00
 209+ 7D02
 210+ 7D02              BASIC_1090:
 211+ 7D02              ; 1090 RETURN
 212+ 7D02 08 7D        	defw      BASIC_0004                  ; next line address     ;7d02	08 7d
 213+ 7D04 42 04        	defw      1090		                ; line number           ;7d04	42 04
 214+ 7D06 92 00        	defb      $92,0                       ; Basic body			;7d06	92 00
 215+ 7D08
 216+ 7D08              BASIC_0004:
 217+ 7D08              ; 4 A
 218+ 7D08 00 00        	defw      0                           ; next line address     ;7d08	00 00
 219+ 7D0A 04 00        	defw      4			                ; line number           ;7d0a	04 00
 220+ 7D0C 41 00        	defb      "A",0		                ; Basic data	        ;7d0c	41 00
 221+ 7D0E
 222+ 7D0E 00           	nop			;7d0e	00 	.
 223+ 7D0F 00           	nop			;7d0f	00 	.
 224+ 7D10 83           	add a,e			;7d10	83 	.
 225+ 7D11 04           	inc b			;7d11	04 	.
 226+ 7D12 00           	nop			;7d12	00 	.
 227+ 7D13 4E           	ld c,(hl)			;7d13	4e 	N
 228+ 7D14 00           	nop			;7d14	00 	.
 229+ 7D15 00           	nop			;7d15	00 	.
 230+ 7D16 16 87        	ld d,087h		;7d16	16 87 	. .
 231+ 7D18 04           	inc b			;7d18	04 	.
 232+ 7D19 31 4E 00     	ld sp,0004eh		;7d19	31 4e 00 	1 N .
 233+ 7D1C 00           	nop			;7d1c	00 	.
 234+ 7D1D 7C           	ld a,h			;7d1d	7c 	|
 235+ 7D1E 87           	add a,a			;7d1e	87 	.
 236+ 7D1F 04           	inc b			;7d1f	04 	.
 237+ 7D20 41           	ld b,c			;7d20	41 	A
 238+ 7D21 53           	ld d,e			;7d21	53 	S
 239+ 7D22 00           	nop			;7d22	00 	.
 240+ 7D23 E8           	ret pe			;7d23	e8 	.
 241+ 7D24 7F           	ld a,a			;7d24	7f 	
 242+ 7D25 8F           	adc a,a			;7d25	8f 	.
 243+ 7D26 04           	inc b			;7d26	04 	.
 244+ 7D27 46           	ld b,(hl)			;7d27	46 	F
 245+ 7D28 54           	ld d,h			;7d28	54 	T
 246+ 7D29 00           	nop			;7d29	00 	.
 247+ 7D2A 00           	nop			;7d2a	00 	.
 248+ 7D2B 00           	nop			;7d2b	00 	.
 249+ 7D2C 89           	adc a,c			;7d2c	89 	.
 250+ 7D2D 04           	inc b			;7d2d	04 	.
 251+ 7D2E 58           	ld e,b			;7d2e	58 	X
 252+ 7D2F 45           	ld b,l			;7d2f	45 	E
 253+ 7D30 00           	nop			;7d30	00 	.
 254+ 7D31 E8           	ret pe			;7d31	e8 	.
 255+ 7D32 7D           	ld a,l			;7d32	7d 	}
 256+ 7D33 8F           	adc a,a			;7d33	8f 	.
 257+ 7D34 04           	inc b			;7d34	04 	.
 258+ 7D35 00           	nop			;7d35	00 	.
 259+ 7D36 4C           	ld c,h			;7d36	4c 	L
 260+ 7D37 00           	nop			;7d37	00 	.
 261+ 7D38 80           	add a,b			;7d38	80 	.
 262+ 7D39 00           	nop			;7d39	00 	.
 263+ 7D3A 89           	adc a,c			;7d3a	89 	.
 264+ 7D3B 04           	inc b			;7d3b	04 	.
 265+ 7D3C 32 4E 00     	ld (0004eh),a		;7d3c	32 4e 00 	2 N .
 266+ 7D3F 00           	nop			;7d3f	00 	.
 267+ 7D40 74           	ld (hl),h			;7d40	74 	t
 268+ 7D41 88           	adc a,b			;7d41	88 	.
 269+ 7D42 04           	inc b			;7d42	04 	.
 270+ 7D43 45           	ld b,l			;7d43	45 	E
 271+ 7D44 44           	ld b,h			;7d44	44 	D
 272+ 7D45 00           	nop			;7d45	00 	.
 273+ 7D46 00           	nop			;7d46	00 	.
 274+ 7D47 00           	nop			;7d47	00 	.
 275+ 7D48 00           	nop			;7d48	00 	.
 276+ 7D49 4E           	ld c,(hl)			;7d49	4e 	N
 277+ 7D4A 00           	nop			;7d4a	00 	.
 278+ 7D4B FF           	rst 38h			;7d4b	ff 	.
 279+ 7D4C 00           	nop			;7d4c	00 	.
 280+ 7D4D FF           	rst 38h			;7d4d	ff 	.
 281+ 7D4E 00           	nop			;7d4e	00 	.
 282+ 7D4F FF           	rst 38h			;7d4f	ff 	.
 283+ 7D50 10 FF        	djnz $+1		;7d50	10 ff 	. .
 284+ 7D52 00           	nop			;7d52	00 	.
 285+ 7D53 FF           	rst 38h			;7d53	ff 	.
 286+ 7D54 00           	nop			;7d54	00 	.
 287+ 7D55 FF           	rst 38h			;7d55	ff 	.
 288+ 7D56 00           	nop			;7d56	00 	.
 289+ 7D57 FF           	rst 38h			;7d57	ff 	.
 290+ 7D58 00           	nop			;7d58	00 	.
 291+ 7D59 FF           	rst 38h			;7d59	ff 	.
 292+ 7D5A 00           	nop			;7d5a	00 	.
 293+ 7D5B FF           	rst 38h			;7d5b	ff 	.
 294+ 7D5C 00           	nop			;7d5c	00 	.
 295+ 7D5D FF           	rst 38h			;7d5d	ff 	.
 296+ 7D5E 00           	nop			;7d5e	00 	.
 297+ 7D5F FF           	rst 38h			;7d5f	ff 	.
 298+ 7D60 00           	nop			;7d60	00 	.
 299+ 7D61 BF           	cp a			;7d61	bf 	.
 300+ 7D62 00           	nop			;7d62	00 	.
 301+ 7D63 FF           	rst 38h			;7d63	ff 	.
 302+ 7D64 00           	nop			;7d64	00 	.
 303+ 7D65 FF           	rst 38h			;7d65	ff 	.
 304+ 7D66 00           	nop			;7d66	00 	.
 305+ 7D67 FF           	rst 38h			;7d67	ff 	.
 306+ 7D68 20 FF        	jr nz,$+1		;7d68	20 ff 	  .
 307+ 7D6A 00           	nop			;7d6a	00 	.
 308+ 7D6B FF           	rst 38h			;7d6b	ff 	.
 309+ 7D6C 00           	nop			;7d6c	00 	.
 310+ 7D6D FF           	rst 38h			;7d6d	ff 	.
 311+ 7D6E 00           	nop			;7d6e	00 	.
 312+ 7D6F FF           	rst 38h			;7d6f	ff 	.
 313+ 7D70 00           	nop			;7d70	00 	.
 314+ 7D71 FF           	rst 38h			;7d71	ff 	.
 315+ 7D72 00           	nop			;7d72	00 	.
 316+ 7D73 FF           	rst 38h			;7d73	ff 	.
 317+ 7D74 00           	nop			;7d74	00 	.
 318+ 7D75 FF           	rst 38h			;7d75	ff 	.
 319+ 7D76 00           	nop			;7d76	00 	.
 320+ 7D77 FF           	rst 38h			;7d77	ff 	.
 321+ 7D78 00           	nop			;7d78	00 	.
 322+ 7D79 DF           	rst 18h			;7d79	df 	.
 323+ 7D7A 00           	nop			;7d7a	00 	.
 324+ 7D7B FF           	rst 38h			;7d7b	ff 	.
 325+ 7D7C 00           	nop			;7d7c	00 	.
 326+ 7D7D FF           	rst 38h			;7d7d	ff 	.
 327+ 7D7E 80           	add a,b			;7d7e	80 	.
 328+ 7D7F BF           	cp a			;7d7f	bf 	.
 329+ 7D80 00           	nop			;7d80	00 	.
 330+ 7D81 FF           	rst 38h			;7d81	ff 	.
 331+ 7D82 00           	nop			;7d82	00 	.
 332+ 7D83 FF           	rst 38h			;7d83	ff 	.
 333+ 7D84 00           	nop			;7d84	00 	.
 334+ 7D85 FF           	rst 38h			;7d85	ff 	.
 335+ 7D86 00           	nop			;7d86	00 	.
 336+ 7D87              l7d87h:
 337+ 7D87 7F           	ld a,a			;7d87	7f 	
 338+ 7D88 00           	nop			;7d88	00 	.
 339+ 7D89 FF           	rst 38h			;7d89	ff 	.
 340+ 7D8A 00           	nop			;7d8a	00 	.
 341+ 7D8B FF           	rst 38h			;7d8b	ff 	.
 342+ 7D8C 00           	nop			;7d8c	00 	.
 343+ 7D8D FF           	rst 38h			;7d8d	ff 	.
 344+ 7D8E 10 FF        	djnz $+1		;7d8e	10 ff 	. .
 345+ 7D90 00           	nop			;7d90	00 	.
 346+ 7D91 BF           	cp a			;7d91	bf 	.
 347+ 7D92 00           	nop			;7d92	00 	.
 348+ 7D93 FF           	rst 38h			;7d93	ff 	.
 349+ 7D94 00           	nop			;7d94	00 	.
 350+ 7D95 FF           	rst 38h			;7d95	ff 	.
 351+ 7D96 00           	nop			;7d96	00 	.
 352+ 7D97 AF           	xor a			;7d97	af 	.
 353+ 7D98 80           	add a,b			;7d98	80 	.
 354+ 7D99 FF           	rst 38h			;7d99	ff 	.
 355+ 7D9A 00           	nop			;7d9a	00 	.
 356+ 7D9B FF           	rst 38h			;7d9b	ff 	.
 357+ 7D9C 00           	nop			;7d9c	00 	.
 358+ 7D9D FF           	rst 38h			;7d9d	ff 	.
 359+ 7D9E 00           	nop			;7d9e	00 	.
 360+ 7D9F FF           	rst 38h			;7d9f	ff 	.
 361+ 7DA0 00           	nop			;7da0	00 	.
 362+ 7DA1 7F           	ld a,a			;7da1	7f 	
 363+ 7DA2 00           	nop			;7da2	00 	.
 364+ 7DA3 FF           	rst 38h			;7da3	ff 	.
 365+ 7DA4 00           	nop			;7da4	00 	.
 366+ 7DA5 FF           	rst 38h			;7da5	ff 	.
 367+ 7DA6 00           	nop			;7da6	00 	.
 368+ 7DA7 EF           	rst 28h			;7da7	ef 	.
 369+ 7DA8 90           	sub b			;7da8	90 	.
 370+ 7DA9 FF           	rst 38h			;7da9	ff 	.
 371+ 7DAA 00           	nop			;7daa	00 	.
 372+ 7DAB FF           	rst 38h			;7dab	ff 	.
 373+ 7DAC 00           	nop			;7dac	00 	.
 374+ 7DAD FF           	rst 38h			;7dad	ff 	.
 375+ 7DAE 00           	nop			;7dae	00 	.
 376+ 7DAF BF           	cp a			;7daf	bf 	.
 377+ 7DB0 50           	ld d,b			;7db0	50 	P
 378+ 7DB1 7F           	ld a,a			;7db1	7f 	
 379+ 7DB2 00           	nop			;7db2	00 	.
 380+ 7DB3 FF           	rst 38h			;7db3	ff 	.
 381+ 7DB4 00           	nop			;7db4	00 	.
 382+ 7DB5 FF           	rst 38h			;7db5	ff 	.
 383+ 7DB6 00           	nop			;7db6	00 	.
 384+ 7DB7 FF           	rst 38h			;7db7	ff 	.
 385+ 7DB8 00           	nop			;7db8	00 	.
 386+ 7DB9 BF           	cp a			;7db9	bf 	.
 387+ 7DBA 00           	nop			;7dba	00 	.
 388+ 7DBB FF           	rst 38h			;7dbb	ff 	.
 389+ 7DBC 00           	nop			;7dbc	00 	.
 390+ 7DBD FF           	rst 38h			;7dbd	ff 	.
 391+ 7DBE 00           	nop			;7dbe	00 	.
 392+ 7DBF FF           	rst 38h			;7dbf	ff 	.
 393+ 7DC0 00           	nop			;7dc0	00 	.
 394+ 7DC1              l7dc1h:
 395+ 7DC1 7F           	ld a,a			;7dc1	7f 	
 396+ 7DC2 00           	nop			;7dc2	00 	.
 397+ 7DC3 FF           	rst 38h			;7dc3	ff 	.
 398+ 7DC4 00           	nop			;7dc4	00 	.
 399+ 7DC5 FF           	rst 38h			;7dc5	ff 	.
 400+ 7DC6 00           	nop			;7dc6	00 	.
 401+ 7DC7 AF           	xor a			;7dc7	af 	.
 402+ 7DC8 80           	add a,b			;7dc8	80 	.
 403+ 7DC9 AF           	xor a			;7dc9	af 	.
 404+ 7DCA 00           	nop			;7dca	00 	.
 405+ 7DCB FF           	rst 38h			;7dcb	ff 	.
 406+ 7DCC 00           	nop			;7dcc	00 	.
 407+ 7DCD FF           	rst 38h			;7dcd	ff 	.
 408+ 7DCE 80           	add a,b			;7dce	80 	.
 409+ 7DCF FF           	rst 38h			;7dcf	ff 	.
 410+ 7DD0 20 FF        	jr nz,$+1		;7dd0	20 ff 	  .
 411+ 7DD2 00           	nop			;7dd2	00 	.
 412+ 7DD3 FF           	rst 38h			;7dd3	ff 	.
 413+ 7DD4 00           	nop			;7dd4	00 	.
 414+ 7DD5 FF           	rst 38h			;7dd5	ff 	.
 415+ 7DD6 20 AF        	jr nz,l7d87h		;7dd6	20 af 	  .
 416+ 7DD8 00           	nop			;7dd8	00 	.
 417+ 7DD9 7F           	ld a,a			;7dd9	7f 	
 418+ 7DDA 00           	nop			;7dda	00 	.
 419+ 7DDB FF           	rst 38h			;7ddb	ff 	.
 420+ 7DDC 00           	nop			;7ddc	00 	.
 421+ 7DDD FF           	rst 38h			;7ddd	ff 	.
 422+ 7DDE 80           	add a,b			;7dde	80 	.
 423+ 7DDF FF           	rst 38h			;7ddf	ff 	.
 424+ 7DE0 10 DF        	djnz l7dc1h		;7de0	10 df 	. .
 425+ 7DE2 00           	nop			;7de2	00 	.
 426+ 7DE3 FF           	rst 38h			;7de3	ff 	.
 427+ 7DE4 00           	nop			;7de4	00 	.
 428+ 7DE5 FF           	rst 38h			;7de5	ff 	.
 429+ 7DE6 00           	nop			;7de6	00 	.
 430+ 7DE7 FF           	rst 38h			;7de7	ff 	.
 431+ 7DE8 00           	nop			;7de8	00 	.
 432+ 7DE9 FF           	rst 38h			;7de9	ff 	.
 433+ 7DEA 00           	nop			;7dea	00 	.
 434+ 7DEB FF           	rst 38h			;7deb	ff 	.
 435+ 7DEC 00           	nop			;7dec	00 	.
 436+ 7DED FF           	rst 38h			;7ded	ff 	.
 437+ 7DEE 00           	nop			;7dee	00 	.
 438+ 7DEF DF           	rst 18h			;7def	df 	.
 439+ 7DF0 00           	nop			;7df0	00 	.
 440+ 7DF1 FF           	rst 38h			;7df1	ff 	.
 441+ 7DF2 00           	nop			;7df2	00 	.
 442+ 7DF3 FF           	rst 38h			;7df3	ff 	.
 443+ 7DF4 00           	nop			;7df4	00 	.
 444+ 7DF5 FF           	rst 38h			;7df5	ff 	.
 445+ 7DF6 00           	nop			;7df6	00 	.
 446+ 7DF7 7F           	ld a,a			;7df7	7f 	
 447+ 7DF8 00           	nop			;7df8	00 	.
 448+ 7DF9 FF           	rst 38h			;7df9	ff 	.
 449+ 7DFA 00           	nop			;7dfa	00 	.
 450+ 7DFB FF           	rst 38h			;7dfb	ff 	.
 451+ 7DFC 00           	nop			;7dfc	00 	.
 452+ 7DFD FF           	rst 38h			;7dfd	ff 	.
 453+ 7DFE 20 FF        	jr nz,$+1		;7dfe	20 ff 	  .
 454+ 7E00 00           	nop			;7e00	00 	.
 455+ 7E01 FF           	rst 38h			;7e01	ff 	.
 456+ 7E02 00           	nop			;7e02	00 	.
 457+ 7E03 FF           	rst 38h			;7e03	ff 	.
 458+ 7E04 00           	nop			;7e04	00 	.
 459+ 7E05 FF           	rst 38h			;7e05	ff 	.
 460+ 7E06 00           	nop			;7e06	00 	.
 461+ 7E07 FF           	rst 38h			;7e07	ff 	.
 462+ 7E08 20 FF        	jr nz,$+1		;7e08	20 ff 	  .
 463+ 7E0A 00           	nop			;7e0a	00 	.
 464+ 7E0B FF           	rst 38h			;7e0b	ff 	.
 465+ 7E0C 00           	nop			;7e0c	00 	.
 466+ 7E0D FF           	rst 38h			;7e0d	ff 	.
 467+ 7E0E 00           	nop			;7e0e	00 	.
 468+ 7E0F FF           	rst 38h			;7e0f	ff 	.
 469+ 7E10 00           	nop			;7e10	00 	.
 470+ 7E11 FF           	rst 38h			;7e11	ff 	.
 471+ 7E12 00           	nop			;7e12	00 	.
 472+ 7E13 FF           	rst 38h			;7e13	ff 	.
 473+ 7E14 00           	nop			;7e14	00 	.
 474+ 7E15 FF           	rst 38h			;7e15	ff 	.
 475+ 7E16 00           	nop			;7e16	00 	.
 476+ 7E17 FF           	rst 38h			;7e17	ff 	.
 477+ 7E18 00           	nop			;7e18	00 	.
 478+ 7E19 FF           	rst 38h			;7e19	ff 	.
 479+ 7E1A 00           	nop			;7e1a	00 	.
 480+ 7E1B FF           	rst 38h			;7e1b	ff 	.
 481+ 7E1C 00           	nop			;7e1c	00 	.
 482+ 7E1D FF           	rst 38h			;7e1d	ff 	.
 483+ 7E1E 00           	nop			;7e1e	00 	.
 484+ 7E1F BF           	cp a			;7e1f	bf 	.
 485+ 7E20 00           	nop			;7e20	00 	.
 486+ 7E21 FF           	rst 38h			;7e21	ff 	.
 487+ 7E22 00           	nop			;7e22	00 	.
 488+ 7E23 FF           	rst 38h			;7e23	ff 	.
 489+ 7E24 00           	nop			;7e24	00 	.
 490+ 7E25 FF           	rst 38h			;7e25	ff 	.
 491+ 7E26 00           	nop			;7e26	00 	.
 492+ 7E27 DF           	rst 18h			;7e27	df 	.
 493+ 7E28 00           	nop			;7e28	00 	.
 494+ 7E29 FF           	rst 38h			;7e29	ff 	.
 495+ 7E2A 00           	nop			;7e2a	00 	.
 496+ 7E2B FF           	rst 38h			;7e2b	ff 	.
 497+ 7E2C 00           	nop			;7e2c	00 	.
 498+ 7E2D FF           	rst 38h			;7e2d	ff 	.
 499+ 7E2E 40           	ld b,b			;7e2e	40 	@
 500+ 7E2F FF           	rst 38h			;7e2f	ff 	.
 501+ 7E30 00           	nop			;7e30	00 	.
 502+ 7E31 7F           	ld a,a			;7e31	7f 	
 503+ 7E32 00           	nop			;7e32	00 	.
 504+ 7E33 FF           	rst 38h			;7e33	ff 	.
 505+ 7E34 00           	nop			;7e34	00 	.
 506+ 7E35 FF           	rst 38h			;7e35	ff 	.
 507+ 7E36 00           	nop			;7e36	00 	.
 508+ 7E37 FF           	rst 38h			;7e37	ff 	.
 509+ 7E38 40           	ld b,b			;7e38	40 	@
 510+ 7E39 FF           	rst 38h			;7e39	ff 	.
 511+ 7E3A 00           	nop			;7e3a	00 	.
 512+ 7E3B FF           	rst 38h			;7e3b	ff 	.
 513+ 7E3C 00           	nop			;7e3c	00 	.
 514+ 7E3D FF           	rst 38h			;7e3d	ff 	.
 515+ 7E3E 80           	add a,b			;7e3e	80 	.
 516+ 7E3F EF           	rst 28h			;7e3f	ef 	.
 517+ 7E40 00           	nop			;7e40	00 	.
 518+ 7E41 DF           	rst 18h			;7e41	df 	.
 519+ 7E42 00           	nop			;7e42	00 	.
 520+ 7E43 FF           	rst 38h			;7e43	ff 	.
 521+ 7E44 00           	nop			;7e44	00 	.
 522+ 7E45 FF           	rst 38h			;7e45	ff 	.
 523+ 7E46 00           	nop			;7e46	00 	.
 524+ 7E47 EF           	rst 28h			;7e47	ef 	.
 525+ 7E48 80           	add a,b			;7e48	80 	.
 526+ 7E49 FF           	rst 38h			;7e49	ff 	.
 527+ 7E4A 00           	nop			;7e4a	00 	.
 528+ 7E4B FF           	rst 38h			;7e4b	ff 	.
 529+ 7E4C 00           	nop			;7e4c	00 	.
 530+ 7E4D FF           	rst 38h			;7e4d	ff 	.
 531+ 7E4E 10 FF        	djnz $+1		;7e4e	10 ff 	. .
 532+ 7E50 00           	nop			;7e50	00 	.
 533+ 7E51 EF           	rst 28h			;7e51	ef 	.
 534+ 7E52 00           	nop			;7e52	00 	.
 535+ 7E53 FF           	rst 38h			;7e53	ff 	.
 536+ 7E54 00           	nop			;7e54	00 	.
 537+ 7E55 FF           	rst 38h			;7e55	ff 	.
 538+ 7E56 00           	nop			;7e56	00 	.
 539+ 7E57 FF           	rst 38h			;7e57	ff 	.
 540+ 7E58 00           	nop			;7e58	00 	.
 541+ 7E59 FF           	rst 38h			;7e59	ff 	.
 542+ 7E5A 00           	nop			;7e5a	00 	.
 543+ 7E5B FF           	rst 38h			;7e5b	ff 	.
 544+ 7E5C 00           	nop			;7e5c	00 	.
 545+ 7E5D FF           	rst 38h			;7e5d	ff 	.
 546+ 7E5E 00           	nop			;7e5e	00 	.
 547+ 7E5F FF           	rst 38h			;7e5f	ff 	.
 548+ 7E60 10 FF        	djnz $+1		;7e60	10 ff 	. .
 549+ 7E62 00           	nop			;7e62	00 	.
 550+ 7E63 FF           	rst 38h			;7e63	ff 	.
 551+ 7E64 00           	nop			;7e64	00 	.
 552+ 7E65 FF           	rst 38h			;7e65	ff 	.
 553+ 7E66 00           	nop			;7e66	00 	.
 554+ 7E67 BF           	cp a			;7e67	bf 	.
 555+ 7E68 00           	nop			;7e68	00 	.
 556+ 7E69 FF           	rst 38h			;7e69	ff 	.
 557+ 7E6A 00           	nop			;7e6a	00 	.
 558+ 7E6B FF           	rst 38h			;7e6b	ff 	.
 559+ 7E6C 00           	nop			;7e6c	00 	.
 560+ 7E6D FF           	rst 38h			;7e6d	ff 	.
 561+ 7E6E 00           	nop			;7e6e	00 	.
 562+ 7E6F FF           	rst 38h			;7e6f	ff 	.
 563+ 7E70 10 FF        	djnz $+1		;7e70	10 ff 	. .
 564+ 7E72 00           	nop			;7e72	00 	.
 565+ 7E73 FF           	rst 38h			;7e73	ff 	.
 566+ 7E74 00           	nop			;7e74	00 	.
 567+ 7E75 FF           	rst 38h			;7e75	ff 	.
 568+ 7E76 80           	add a,b			;7e76	80 	.
 569+ 7E77              l7e77h:
 570+ 7E77 FF           	rst 38h			;7e77	ff 	.
 571+ 7E78 00           	nop			;7e78	00 	.
 572+ 7E79 FF           	rst 38h			;7e79	ff 	.
 573+ 7E7A 00           	nop			;7e7a	00 	.
 574+ 7E7B FF           	rst 38h			;7e7b	ff 	.
 575+ 7E7C 00           	nop			;7e7c	00 	.
 576+ 7E7D FF           	rst 38h			;7e7d	ff 	.
 577+ 7E7E 20 FF        	jr nz,$+1		;7e7e	20 ff 	  .
 578+ 7E80 00           	nop			;7e80	00 	.
 579+ 7E81 7F           	ld a,a			;7e81	7f 	
 580+ 7E82 00           	nop			;7e82	00 	.
 581+ 7E83 FF           	rst 38h			;7e83	ff 	.
 582+ 7E84 00           	nop			;7e84	00 	.
 583+ 7E85 FF           	rst 38h			;7e85	ff 	.
 584+ 7E86 00           	nop			;7e86	00 	.
 585+ 7E87 7F           	ld a,a			;7e87	7f 	
 586+ 7E88 00           	nop			;7e88	00 	.
 587+ 7E89 EF           	rst 28h			;7e89	ef 	.
 588+ 7E8A 00           	nop			;7e8a	00 	.
 589+ 7E8B FF           	rst 38h			;7e8b	ff 	.
 590+ 7E8C 00           	nop			;7e8c	00 	.
 591+ 7E8D FF           	rst 38h			;7e8d	ff 	.
 592+ 7E8E 90           	sub b			;7e8e	90 	.
 593+ 7E8F FF           	rst 38h			;7e8f	ff 	.
 594+ 7E90 40           	ld b,b			;7e90	40 	@
 595+ 7E91 FF           	rst 38h			;7e91	ff 	.
 596+ 7E92 00           	nop			;7e92	00 	.
 597+ 7E93 FF           	rst 38h			;7e93	ff 	.
 598+ 7E94 00           	nop			;7e94	00 	.
 599+ 7E95 FF           	rst 38h			;7e95	ff 	.
 600+ 7E96 80           	add a,b			;7e96	80 	.
 601+ 7E97 FF           	rst 38h			;7e97	ff 	.
 602+ 7E98 00           	nop			;7e98	00 	.
 603+ 7E99 FF           	rst 38h			;7e99	ff 	.
 604+ 7E9A 00           	nop			;7e9a	00 	.
 605+ 7E9B FF           	rst 38h			;7e9b	ff 	.
 606+ 7E9C 00           	nop			;7e9c	00 	.
 607+ 7E9D FF           	rst 38h			;7e9d	ff 	.
 608+ 7E9E 80           	add a,b			;7e9e	80 	.
 609+ 7E9F FF           	rst 38h			;7e9f	ff 	.
 610+ 7EA0 00           	nop			;7ea0	00 	.
 611+ 7EA1 7F           	ld a,a			;7ea1	7f 	
 612+ 7EA2 00           	nop			;7ea2	00 	.
 613+ 7EA3 FF           	rst 38h			;7ea3	ff 	.
 614+ 7EA4 00           	nop			;7ea4	00 	.
 615+ 7EA5 FF           	rst 38h			;7ea5	ff 	.
 616+ 7EA6 00           	nop			;7ea6	00 	.
 617+ 7EA7 FF           	rst 38h			;7ea7	ff 	.
 618+ 7EA8 00           	nop			;7ea8	00 	.
 619+ 7EA9 FF           	rst 38h			;7ea9	ff 	.
 620+ 7EAA 00           	nop			;7eaa	00 	.
 621+ 7EAB FF           	rst 38h			;7eab	ff 	.
 622+ 7EAC 00           	nop			;7eac	00 	.
 623+ 7EAD FF           	rst 38h			;7ead	ff 	.
 624+ 7EAE 00           	nop			;7eae	00 	.
 625+ 7EAF FF           	rst 38h			;7eaf	ff 	.
 626+ 7EB0 40           	ld b,b			;7eb0	40 	@
 627+ 7EB1 FF           	rst 38h			;7eb1	ff 	.
 628+ 7EB2 00           	nop			;7eb2	00 	.
 629+ 7EB3 FF           	rst 38h			;7eb3	ff 	.
 630+ 7EB4 00           	nop			;7eb4	00 	.
 631+ 7EB5 FF           	rst 38h			;7eb5	ff 	.
 632+ 7EB6 20 BF        	jr nz,l7e77h		;7eb6	20 bf 	  .
 633+ 7EB8 00           	nop			;7eb8	00 	.
 634+ 7EB9 CF           	rst 8			;7eb9	cf 	.
 635+ 7EBA 00           	nop			;7eba	00 	.
 636+ 7EBB FF           	rst 38h			;7ebb	ff 	.
 637+ 7EBC 00           	nop			;7ebc	00 	.
 638+ 7EBD FF           	rst 38h			;7ebd	ff 	.
 639+ 7EBE 00           	nop			;7ebe	00 	.
 640+ 7EBF DF           	rst 18h			;7ebf	df 	.
 641+ 7EC0 20 FF        	jr nz,$+1		;7ec0	20 ff 	  .
 642+ 7EC2 00           	nop			;7ec2	00 	.
 643+ 7EC3 FF           	rst 38h			;7ec3	ff 	.
 644+ 7EC4 00           	nop			;7ec4	00 	.
 645+ 7EC5 FF           	rst 38h			;7ec5	ff 	.
 646+ 7EC6 00           	nop			;7ec6	00 	.
 647+ 7EC7 DF           	rst 18h			;7ec7	df 	.
 648+ 7EC8 00           	nop			;7ec8	00 	.
 649+ 7EC9 DF           	rst 18h			;7ec9	df 	.
 650+ 7ECA 00           	nop			;7eca	00 	.
 651+ 7ECB FF           	rst 38h			;7ecb	ff 	.
 652+ 7ECC 00           	nop			;7ecc	00 	.
 653+ 7ECD FF           	rst 38h			;7ecd	ff 	.
 654+ 7ECE 80           	add a,b			;7ece	80 	.
 655+ 7ECF FF           	rst 38h			;7ecf	ff 	.
 656+ 7ED0 00           	nop			;7ed0	00 	.
 657+ 7ED1 FF           	rst 38h			;7ed1	ff 	.
 658+ 7ED2 00           	nop			;7ed2	00 	.
 659+ 7ED3 FF           	rst 38h			;7ed3	ff 	.
 660+ 7ED4 00           	nop			;7ed4	00 	.
 661+ 7ED5 FF           	rst 38h			;7ed5	ff 	.
 662+ 7ED6 80           	add a,b			;7ed6	80 	.
 663+ 7ED7 7F           	ld a,a			;7ed7	7f 	
 664+ 7ED8 80           	add a,b			;7ed8	80 	.
 665+ 7ED9 FF           	rst 38h			;7ed9	ff 	.
 666+ 7EDA 00           	nop			;7eda	00 	.
 667+ 7EDB FF           	rst 38h			;7edb	ff 	.
 668+ 7EDC 00           	nop			;7edc	00 	.
 669+ 7EDD FF           	rst 38h			;7edd	ff 	.
 670+ 7EDE 80           	add a,b			;7ede	80 	.
 671+ 7EDF FF           	rst 38h			;7edf	ff 	.
 672+ 7EE0 80           	add a,b			;7ee0	80 	.
 673+ 7EE1 FF           	rst 38h			;7ee1	ff 	.
 674+ 7EE2 00           	nop			;7ee2	00 	.
 675+ 7EE3 FF           	rst 38h			;7ee3	ff 	.
 676+ 7EE4 00           	nop			;7ee4	00 	.
 677+ 7EE5 FF           	rst 38h			;7ee5	ff 	.
 678+ 7EE6 00           	nop			;7ee6	00 	.
 679+ 7EE7 FF           	rst 38h			;7ee7	ff 	.
 680+ 7EE8 40           	ld b,b			;7ee8	40 	@
 681+ 7EE9 FF           	rst 38h			;7ee9	ff 	.
 682+ 7EEA 00           	nop			;7eea	00 	.
 683+ 7EEB FF           	rst 38h			;7eeb	ff 	.
 684+ 7EEC 00           	nop			;7eec	00 	.
 685+ 7EED FF           	rst 38h			;7eed	ff 	.
 686+ 7EEE 00           	nop			;7eee	00 	.
 687+ 7EEF 6F           	ld l,a			;7eef	6f 	o
 688+ 7EF0 00           	nop			;7ef0	00 	.
 689+ 7EF1 BF           	cp a			;7ef1	bf 	.
 690+ 7EF2 00           	nop			;7ef2	00 	.
 691+ 7EF3 FF           	rst 38h			;7ef3	ff 	.
 692+ 7EF4 21 02 7F     	ld hl,l7f02h		;7ef4	21 02 7f 	! . 
 693+ 7EF7 11 00 CE     	ld de,0ce00h		;7ef7	11 00 ce 	. . .
 694+ 7EFA 01 00 01     	ld bc,00100h		;7efa	01 00 01 	. . .
 695+ 7EFD ED B0        	ldir		;7efd	ed b0 	. .
 696+ 7EFF C3 00 CE     	jp 0ce00h		;7eff	c3 00 ce 	. . .
 697+ 7F02              l7f02h:
 698+ 7F02 00           	nop			;7f02	00 	.
 699+ 7F03 00           	nop			;7f03	00 	.
 700+ 7F04 00           	nop			;7f04	00 	.
 701+ 7F05 00           	nop			;7f05	00 	.
 702+ 7F06 00           	nop			;7f06	00 	.
 703+ 7F07 00           	nop			;7f07	00 	.
 704+ 7F08 F3           	di			;7f08	f3 	.
 705+ 7F09 31 F0 CD     	ld sp,0cdf0h		;7f09	31 f0 cd 	1 . .
 706+ 7F0C 3A 00 68     	ld a,(06800h)		;7f0c	3a 00 68 	: . h
 707+ 7F0F E6 F7        	and 0f7h		;7f0f	e6 f7 	. .
 708+ 7F11 32 00 68     	ld (06800h),a		;7f11	32 00 68 	2 . h
 709+ 7F14 21 00 70     	ld hl,07000h		;7f14	21 00 70 	! . p
 710+ 7F17 11 01 70     	ld de,07001h		;7f17	11 01 70 	. . p
 711+ 7F1A 36 20        	ld (hl),020h		;7f1a	36 20 	6
 712+ 7F1C 01 00 01     	ld bc,00100h		;7f1c	01 00 01 	. . .
 713+ 7F1F ED B0        	ldir		;7f1f	ed b0 	. .
 714+ 7F21 21 DA CE     	ld hl,0cedah		;7f21	21 da ce 	! . .
 715+ 7F24 11 00 70     	ld de,07000h		;7f24	11 00 70 	. . p
 716+ 7F27 CD C8 CE     	call 0cec8h		;7f27	cd c8 ce 	. . .
 717+ 7F2A 21 20 70     	ld hl,07020h		;7f2a	21 20 70 	!   p
 718+ 7F2D 01 00 CE     	ld bc,0ce00h		;7f2d	01 00 ce 	. . .
 719+ 7F30 3E 03        	ld a,003h		;7f30	3e 03 	> .
 720+ 7F32              l7f32h:
 721+ 7F32 F5           	push af			;7f32	f5 	.
 722+ 7F33 CD 77 CE     	call 0ce77h		;7f33	cd 77 ce 	. w .
 723+ 7F36 5F           	ld e,a			;7f36	5f 	_
 724+ 7F37 CD 77 CE     	call 0ce77h		;7f37	cd 77 ce 	. w .
 725+ 7F3A 57           	ld d,a			;7f3a	57 	W
 726+ 7F3B CD A2 CE     	call 0cea2h		;7f3b	cd a2 ce 	. . .
 727+ 7F3E E5           	push hl			;7f3e	e5 	.
 728+ 7F3F C5           	push bc			;7f3f	c5 	.
 729+ 7F40 E1           	pop hl			;7f40	e1 	.
 730+ 7F41 73           	ld (hl),e			;7f41	73 	s
 731+ 7F42 23           	inc hl			;7f42	23 	#
 732+ 7F43 72           	ld (hl),d			;7f43	72 	r
 733+ 7F44 23           	inc hl			;7f44	23 	#
 734+ 7F45 E5           	push hl			;7f45	e5 	.
 735+ 7F46 C1           	pop bc			;7f46	c1 	.
 736+ 7F47 E1           	pop hl			;7f47	e1 	.
 737+ 7F48 11 1C 00     	ld de,0001ch		;7f48	11 1c 00 	. . .
 738+ 7F4B 19           	add hl,de			;7f4b	19 	.
 739+ 7F4C F1           	pop af			;7f4c	f1 	.
 740+ 7F4D 3D           	dec a			;7f4d	3d 	=
 741+ 7F4E 20 E2        	jr nz,l7f32h		;7f4e	20 e2 	  .
 742+ 7F50 CD D3 CE     	call 0ced3h		;7f50	cd d3 ce 	. . .
 743+ 7F53 CD D3 CE     	call 0ced3h		;7f53	cd d3 ce 	. . .
 744+ 7F56 CD D3 CE     	call 0ced3h		;7f56	cd d3 ce 	. . .
 745+ 7F59 CD D3 CE     	call 0ced3h		;7f59	cd d3 ce 	. . .
 746+ 7F5C 2A 00 CE     	ld hl,(0ce00h)		;7f5c	2a 00 ce 	* . .
 747+ 7F5F ED 4B 02 CE  	ld bc,(0ce02h)		;7f5f	ed 4b 02 ce 	. K . .
 748+ 7F63              l7f63h:
 749+ 7F63 CD 77 CE     	call 0ce77h		;7f63	cd 77 ce 	. w .
 750+ 7F66 77           	ld (hl),a			;7f66	77 	w
 751+ 7F67 23           	inc hl			;7f67	23 	#
 752+ 7F68 0B           	dec bc			;7f68	0b 	.
 753+ 7F69 78           	ld a,b			;7f69	78 	x
 754+ 7F6A B1           	or c			;7f6a	b1 	.
 755+ 7F6B 20 F6        	jr nz,l7f63h		;7f6b	20 f6 	  .
 756+ 7F6D 3A 00 68     	ld a,(06800h)		;7f6d	3a 00 68 	: . h
 757+ 7F70 F6 08        	or 008h		;7f70	f6 08 	. .
 758+ 7F72 32 00 68     	ld (06800h),a		;7f72	32 00 68 	2 . h
 759+ 7F75 2A 04 CE     	ld hl,(0ce04h)		;7f75	2a 04 ce 	* . .
 760+ 7F78 E9           	jp (hl)			;7f78	e9 	.
 761+ 7F79 00           	nop			;7f79	00 	.
 762+ 7F7A 3E 80        	ld a,080h		;7f7a	3e 80 	> .
 763+ 7F7C D3 E0        	out (0e0h),a		;7f7c	d3 e0 	. .
 764+ 7F7E              l7f7eh:
 765+ 7F7E DB E0        	in a,(0e0h)		;7f7e	defb e0 	. .
 766+ 7F80 CB 7F        	bit 7,a		;7f80	cb 7f 	. 
 767+ 7F82 28 FA        	jr z,l7f7eh		;7f82	28 fa 	( .
 768+ 7F84 DB E0        	in a,(0e0h)		;7f84	defb e0 	. .
 769+ 7F86 CB 7F        	bit 7,a		;7f86	cb 7f 	. 
 770+ 7F88 CA 7C CE     	jp z,0ce7ch		;7f88	ca 7c ce 	. | .
 771+ 7F8B E6 0F        	and 00fh		;7f8b	e6 0f 	. .
 772+ 7F8D 57           	ld d,a			;7f8d	57 	W
 773+ 7F8E D3 E0        	out (0e0h),a		;7f8e	d3 e0 	. .
 774+ 7F90              l7f90h:
 775+ 7F90 DB E0        	in a,(0e0h)		;7f90	defb e0 	. .
 776+ 7F92 CB 7F        	bit 7,a		;7f92	cb 7f 	. 
 777+ 7F94 20 FA        	jr nz,l7f90h		;7f94	20 fa 	  .
 778+ 7F96 DB E0        	in a,(0e0h)		;7f96	defb e0 	. .
 779+ 7F98 CB 7F        	bit 7,a		;7f98	cb 7f 	. 
 780+ 7F9A 20 F4        	jr nz,l7f90h		;7f9a	20 f4 	  .
 781+ 7F9C 07           	rlca			;7f9c	07 	.
 782+ 7F9D 07           	rlca			;7f9d	07 	.
 783+ 7F9E 07           	rlca			;7f9e	07 	.
 784+ 7F9F 07           	rlca			;7f9f	07 	.
 785+ 7FA0 E6 F0        	and 0f0h		;7fa0	e6 f0 	. .
 786+ 7FA2 B2           	or d			;7fa2	b2 	.
 787+ 7FA3 C9           	ret			;7fa3	c9 	.
 788+ 7FA4 7A           	ld a,d			;7fa4	7a 	z
 789+ 7FA5 CD AB CE     	call 0ceabh		;7fa5	cd ab ce 	. . .
 790+ 7FA8 7B           	ld a,e			;7fa8	7b 	{
 791+ 7FA9 CD AB CE     	call 0ceabh		;7fa9	cd ab ce 	. . .
 792+ 7FAC C9           	ret			;7fac	c9 	.
 793+ 7FAD F5           	push af			;7fad	f5 	.
 794+ 7FAE 0F           	rrca			;7fae	0f 	.
 795+ 7FAF 0F           	rrca			;7faf	0f 	.
 796+ 7FB0 0F           	rrca			;7fb0	0f 	.
 797+ 7FB1 0F           	rrca			;7fb1	0f 	.
 798+ 7FB2 E6 0F        	and 00fh		;7fb2	e6 0f 	. .
 799+ 7FB4 CD BC CE     	call 0cebch		;7fb4	cd bc ce 	. . .
 800+ 7FB7 F1           	pop af			;7fb7	f1 	.
 801+ 7FB8 E6 0F        	and 00fh		;7fb8	e6 0f 	. .
 802+ 7FBA CD BC CE     	call 0cebch		;7fba	cd bc ce 	. . .
 803+ 7FBD C9           	ret			;7fbd	c9 	.
 804+ 7FBE FE 0A        	cp 00ah		;7fbe	fe 0a 	. .
 805+ 7FC0 FA C3 CE     	jp m,0cec3h		;7fc0	fa c3 ce 	. . .
 806+ 7FC3 C6 07        	add a,007h		;7fc3	c6 07 	. .
 807+ 7FC5 C6 30        	add a,030h		;7fc5	c6 30 	. 0
 808+ 7FC7 77           	ld (hl),a			;7fc7	77 	w
 809+ 7FC8 23           	inc hl			;7fc8	23 	#
 810+ 7FC9 C9           	ret			;7fc9	c9 	.
 811+ 7FCA 7E           	ld a,(hl)			;7fca	7e 	~
 812+ 7FCB B7           	or a			;7fcb	b7 	.
 813+ 7FCC C8           	ret z			;7fcc	c8 	.
 814+ 7FCD D6 40        	sub 040h		;7fcd	d6 40 	. @
 815+ 7FCF 12           	ld (de),a			;7fcf	12 	.
 816+ 7FD0 23           	inc hl			;7fd0	23 	#
 817+ 7FD1 13           	inc de			;7fd1	13 	.
 818+ 7FD2 C3 C8 CE     	jp 0cec8h		;7fd2	c3 c8 ce 	. . .
 819+ 7FD5 0B           	dec bc			;7fd5	0b 	.
 820+ 7FD6 78           	ld a,b			;7fd6	78 	x
 821+ 7FD7 B1           	or c			;7fd7	b1 	.
 822+ 7FD8 C2 D3 CE     	jp nz,0ced3h		;7fd8	c2 d3 ce 	. . .
 823+ 7FDB C9           	ret			;7fdb	c9 	.
 824+ 7FDC 54           	ld d,h			;7fdc	54 	T
 825+ 7FDD 52           	ld d,d			;7fdd	52 	R
 826+ 7FDE 41           	ld b,c			;7fde	41 	A
 827+ 7FDF 4E           	ld c,(hl)			;7fdf	4e 	N
 828+ 7FE0 53           	ld d,e			;7fe0	53 	S
 829+ 7FE1 46           	ld b,(hl)			;7fe1	46 	F
 830+ 7FE2 45           	ld b,l			;7fe2	45 	E
 831+ 7FE3 52           	ld d,d			;7fe3	52 	R
 832+ 7FE4 52           	ld d,d			;7fe4	52 	R
 833+ 7FE5 49           	ld c,c			;7fe5	49 	I
 834+ 7FE6 4E           	ld c,(hl)			;7fe6	4e 	N
 835+ 7FE7 47           	ld b,a			;7fe7	47 	G
 836+ 7FE8 20 44        	defb " D"		;7fe8	20 44 	  D
 837+ 7FEA 41           	ld b,c			;7fea	41 	A
 838+ 7FEB 54           	ld d,h			;7feb	54 	T
 839+ 7FEC 41           	ld b,c			;7fec	41 	A
 840+ 7FED 00           	nop			;7fed	00 	.
 841+ 7FEE 2C           	inc l			;7fee	2c 	,
 842+ 7FEF 42           	ld b,d			;7fef	42 	B
 843+ 7FF0 4C           	ld c,h			;7ff0	4c 	L
 844+ 7FF1 41           	ld b,c			;7ff1	41 	A
 845+ 7FF2 4E           	ld c,(hl)			;7ff2	4e 	N
 846+ 7FF3 4B           	ld c,e			;7ff3	4b 	K
 847+ 7FF4 00           	nop			;7ff4	00 	.
 848+ 7FF5 FF           	rst 38h			;7ff5	ff 	.
 849+ 7FF6 00           	nop			;7ff6	00 	.
 850+ 7FF7              l7ff7h:
 851+ 7FF7 07           	rlca			;7ff7	07 	.
 852+ 7FF8 00           	nop			;7ff8	00 	.
 853+ 7FF9 4E           	ld c,(hl)			;7ff9	4e 	N
 854+ 7FFA 20 FB        	jr nz,l7ff7h		;7ffa	20 fb 	  .
 855+ 7FFC 00           	nop			;7ffc	00 	.
 856+ 7FFD FD 00 07     	defb 0fdh,000h,007h	;illegal sequence		;7ffd	fd 00 07 	. . .
 857+ 8000
# file closed: l:\vz-dis-games\GhostHunter\basic_garbage.asm
 173  8000
 174  8000
 175  8000              ;***********************************************************************************************
 176  8000              ;
 177  8000              ;    M A I N  E N T R Y   P O I N T
 178  8000              ;
 179  8000              ;***********************************************************************************************
 180  8000              MAIN				org		$8000
 181  8000 C3 D5 80     	jp GAME_INIT					; jump to GAME_INIT							;8000	c3 d5 80
 182  8003
 183  8003
 184  8003
 185  8003              ;***********************************************************************************************
 186  8003              ;
 187  8003              ;    G A M E    V A R I A B L E S
 188  8003              ;
 189  8003              ;***********************************************************************************************
 190  8003 00           LEVEL				defb	0		; current Level								;8003	00
 191  8004 00           MEN_LIVES:			defb	0		; Live Counter								;8004	00
 192  8005
 193  8005              ;***********************************************************************************************
 194  8005              ; Game State Data - 46 bytes 8005 - 8033
 195  8005 00           GAME_STATE			defb	0		; Not Used variable							;8005	00
 196  8006 00           DOTS_EATEN			defb	0		; Dots Eaten Counter						;8006	00
 197  8007
 198  8007              ;***********************************************************************************************
 199  8007              ; Level DataSet
 200  8007              ; These 4 bytes are set for every Level at start. Contains initial values for Game Loop Timers.
 201  8007              ; Every Level has different values to incrase difficulty of Game with higher Level.
 202  8007              ; - The smaller the Update Timer value, the more often the Ghosts position is updated and thus they move faster.
 203  8007              ; - Chase Mode Time defines duration of time when Chase Mode is active after Player Eat Power Pill.
 204  8007              ; - SpeedUp value decrases Ghost Red 2 (A) Update Timer when Player Eat 25,50 and 75th Dot making
 205  8007              ;   gameplay even more difficult by incrase this Ghost moves.
 206  8007              ; All values are given as the number of Game Loop iterations.
 207  8007              LEVEL_DATASET:
 208  8007 00           LEVEL_GH_UPD_TIMER	defb	0		; Ghosts Update Timer init value  			;8007	00
 209  8008 00           LEVEL_GA_UPD_TIMER  defb	0		; Ghost Red A Update Timer init value		;8008	00
 210  8009 00           LEVEL_CMODE_TIME	defb	0		; Ghost Chase Timer init value 				;8009	00
 211  800A 00           LEVEL_GA_SPEEDUP	defb	0		; Ghost Red A Speedup Value  				;800a	00
 212  800B
 213  800B              ;***********************************************************************************************
 214  800B              ; Player Sprite current Properties
 215  800B              ; Keeps current data for Player Sprite to draw it properly.
 216  800B              ; - Sprite Address points to current Sprite Variant to be use.
 217  800B              ;   There are 6 variants of Player Sprite to ensure proper display while Player is moving (2px step)
 218  800B              ; - VRAM Address is current Player position on screen as byte addres
 219  800B              ; - Properties contains 2 values: current moving direction and flag to mark use of shifted Sprite
 220  800B              ;   when Player position is 2px right from base for this VRAM address
 221  800B              ; - Animate Flag toggles every Player Update iteration. When is set we draw Alternate Sprite to show animation.
 222  800B D9 8E        PLAYER_SADR			defw	SPR.PLAYER_U	; address of current Sprite Variant	;800b	d9 8e
 223  800D 00 00        PLAYER_VADR			defw	$0000	; VRAM address of sprite					;800d	00 00
 224  800F 00 00        PLAYER_PROPS		defw	0		; Move direction, Sprite Shifted Flag		;800f	00 00
 225  8011 00           PLAYER_ANIM			defb	0		; 0 - use valid variant, 1 - use Alt Sprite ;8011	00
 226  8012
 227  8012              ;***********************************************************************************************
 228  8012              ; Game Loop Timers
 229  8012              ; Timers are counters which value is decremented in every Game Loop iteration.
 230  8012              ; When the Timer value reaches 0 then corresponding Update or Draw routine is performed.
 231  8012              ; Ghosts Update Timers will be reinitialized to value from Level Data, Draw Timers
 232  8012              ; are not initialized so when reaches 0 it wrap to value 256. Player Update Timer
 233  8012              ; is initialized to value 188 or 170 depending on direction Player moves (horizontal/vartical).
 234  8012              ; This way Ghosts' speed is controlled
 235  8012 00           PLAYER_UPD_TIMER	defb	0	; Player Update Timer - reset to 188 or 170 by code 	;8012	00
 236  8013 00           GHOSTS_UPD_TIMER	defb	0	; Ghosts Update Timer - reset to LEVEL_GH_UPD_TIMER 	;8013	00
 237  8014 00           CMODE_DRAW_TIMER	defb	0	; Chase Mode Update Timer (Screen Flash) reset to 256	;8014	00
 238  8015 00           DOTS_DRAW_TIMER		defb	0	; Dots and Pills Redraw Timer - reset to 256			;8015	00
 239  8016 00           GHOSTS_DRAW_TIMER	defb	0	; Ghosts Redraw Timer - reset to 256					;8016	00
 240  8017 00           GHOSTA_UPD_TIMER	defb	0	; Ghost Red 2 (A) Update Timer - reset to LEVEL_GH_UPD_TIMER  ;8017	00 	.
 241  8018
 242  8018              ;***********************************************************************************************
 243  8018              ; Ghosts Sprite current Properties
 244  8018              ; Similar to Player Sprite Properties these data contains current values for every Ghost.
 245  8018              ; It doesn't include Sprite Address because Ghosts use the same sprite no matter which
 246  8018              ; direction they move.
 247  8018 00 00 00 00  GHOST_B1		TGhost 0, 0, 0 	; Ghost Blue 1 [VRAM address,Properties,Freeze Timer]	;8018	00 00 00 00 00
 247  801C 00
 248  801D 00 00 00 00  GHOST_B2		TGhost 0, 0, 0 	; Ghost Blue 2 [VRAM address,Properties,Freeze Timer]	;801d	00 00 00 00 00
 248  8021 00
 249  8022 00 00 00 00  GHOST_R1		TGhost 0, 0, 0 	; Ghost Red 1 [VRAM address,Properties,Freeze Timer]	;8022	00 00 00 00 00
 249  8026 00
 250  8027 00 00 00 00  GHOST_R2		TGhost 0, 0, 0 	; Ghost Red 2 [VRAM address,Properties,Freeze Timer]	;8027	00 00 00 00 00
 250  802B 00
 251  802C
 252  802C              ;***********************************************************************************************
 253  802C              ; Chase Mode Timer
 254  802C              ; Nonzero value means that Chase Mode is active - Player can chase and Kill Ghost and Ghost
 255  802C              ; can't kill Player. This value is decremented every 256th interation of Game Loop.
 256  802C 00           CMODE_ON_TIMER		defb	0	; counting down time when Ghost Chase Mode is active 	;802c	00
 257  802D 00           HEART_UPD_TIMER		defb	0	; Heart Update Timer - reset to 256						;802d	00
 258  802E 00           HEART_SHOW_TIMER	defb	0	; counter down - initialized with random value			;802e	00
 259  802F 00           HEART_ON_TIMER		defb	0	; count down time when Heart is active on screen	 	;802f	00
 260  8030 00           SHOW_WALLS_FLAG		defb	0	; 0 - Maze Walls are hidden, nonzero - Walls are Drawn	;8030	00
 261  8031 00           HEARTS_PER_LEVEL	defb	0	; Number of times Heart will spawn in this Game Level	;8031	00
 262  8032
 263  8032              ;***********************************************************************************************
 264  8032              ; Dummy Data
 265  8032 00 00        					defb	0,0	; Not used												;8032	00
 266  8034              ;-----------------------------------------------------------------------------------------------
 267  8034
 268  8034
 269  8034
 270  8034              ;================================================================================================
 271  8034              ;================================================================================================
 272  8034              ;================================================================================================
 273  8034              ;
 274  8034              ;   Sound Routines Module
 275  8034              ;   -------------------
 276  8034              ;	Routines for predefined Sounds played by Th Game
 277  8034              ;
 278  8034              	MODULE	SND
 279  8034              ;
 280  8034              ;
 281  8034              ;***********************************************************************************************
 282  8034              ; Play Predefined Sound
 283  8034              ; Multiple entry points for 4 Sounds used in Game
 284  8034              PLAY_LowShort:
 285  8034 01 20 00     	ld bc,$0020				; Sound params: b=256, c=32 (low/short)				;8034	01 20 00
 286  8037 C3 4C 80     	jp PLAY_WAVE			; Play Sound										;8037	c3 4c 80
 287  803A              PLAY_HighShort:
 288  803A 01 40 30     	ld bc,$3040				; Sound params: b=48, c=64 	(high/short)			;803a	01 40 30
 289  803D C3 4C 80     	jp PLAY_WAVE			; Play Sound										;803d	c3 4c 80
 290  8040              PLAY_MiddleLong:
 291  8040 01 00 40     	ld bc,$4000				; Sound params: b=64, c=256 (middle/long)			;8040	01 00 40
 292  8043 C3 4C 80     	jp PLAY_WAVE			; Play Sound										;8043	c3 4c 80
 293  8046              PLAY_LowLong:
 294  8046 01 80 00     	ld bc,$0080				; Sound params: b=256, c=128 (low/long)				;8046	01 80 00
 295  8049 C3 4C 80     	jp PLAY_WAVE			; Play Sound										;8049	c3 4c 80
 296  804C
 297  804C              ;***********************************************************************************************
 298  804C              ; Play Sound Wave
 299  804C              ; IN: b - half period time (0 = 256)
 300  804C              ;     c - number of cycles to play (0 = 256)
 301  804C              PLAY_WAVE:
 302  804C 3A 6F 80     	ld a,(IOLATCH_SHADOW)	; a - current hardware IOLATCH value				;804c	3a 6f 80
 303  804F              .NEXT_CYCLE:
 304  804F E6 18        	and VDG_MODE_CSS_MASK	; reset all bits but VDG MODE and Colors			;804f	e6 18
 305  8051 F6 20        	or BIT_SPK_MINUS		; set Speaker Out to 0-1							;8051	f6 20
 306  8053 32 00 68     	ld (IOLATCH),a			; send to hardware speaker 							;8053	32 00 68
 307  8056 CD 68 80     	call DELAY_B			; wait delay according to value in b				;8056	cd 68 80
 308  8059 E6 18        	and VDG_MODE_CSS_MASK	; reset all bits but VDG MODE and Colors			;8059	e6 18
 309  805B F6 01        	or BIT_SPK_PLUS			; set Speaker Out to 1-0							;805b	f6 01
 310  805D 32 00 68     	ld (IOLATCH),a			; send to hardware speaker 							;805d	32 00 68
 311  8060 CD 68 80     	call DELAY_B			; wait delay according to value in b				;8060	cd 68 80
 312  8063 0D           	dec c					; decrement cycle counter							;8063	0d
 313  8064 C2 4F 80     	jp nz,.NEXT_CYCLE		; repeat c times									;8064	c2 4f 80
 314  8067 C9           	ret						; ---------- End of Proc --------------				;8067	c9
 315  8068
 316  8068              ;***********************************************************************************************
 317  8068              ; Delay
 318  8068              ; IN: b - delay value/counter
 319  8068              DELAY_B:
 320  8068 C5           	push bc					; save bc											;8068	c5
 321  8069              .WAIT:
 322  8069 05           	dec b					; decrement delay counter							;8069	05
 323  806A C2 69 80     	jp nz,.WAIT				; repeat b times									;806a	c2 69 80
 324  806D C1           	pop bc					; restore bc										;806d	c1
 325  806E C9           	ret						; ------------- End of Proc -----------				;806e	c9
 326  806F
 327  806F
 328  806F              	ENDMODULE 		; ================ End SND module ==========================================
 329  806F
 330  806F
 331  806F
 332  806F
 333  806F
 334  806F              ;***********************************************************************************************
 335  806F              ; Game Variable
 336  806F              IOLATCH_SHADOW
 337  806F 00           	defb	0		; shadow variable to store value last written 				;806f	00
 338  8070
 339  8070
 340  8070              ;***********************************************************************************************
 341  8070              ; Add value to Score
 342  8070              ; Multiple entry points for values: 1, 10, 100, 1000, 10000
 343  8070              ;-----------------------------------------------------------------------------------------------
 344  8070              ; Increment Score value by 1 (not used)
 345  8070              SCORE_ADD_1
 346  8070 3A CB 83     	ld a,(TXT_SCORE_DIGITS+4)	; 5th digit placeholder in Score text			;8070	3a cb 83
 347  8073 3C           	inc a						; add 1 										;8073	3c
 348  8074 FE 3A        	cp $3a						; check if was "9" before increment				;8074	fe 3a
 349  8076 CA 7D 80     	jp z,SCORE_ADD_1_OV			; yes - set to "0" and increment higher digit	;8076	ca 7d 80
 350  8079              ; -- digit value didn't exceeded '9'
 351  8079 32 CB 83     	ld (TXT_SCORE_DIGITS+4),a	; store new 5th digit							;8079	32 cb 83
 352  807C C9           	ret							; ------------- End of Proc --------------		;807c	c9
 353  807D              ; -- digit overflow - set to '0'
 354  807D              SCORE_ADD_1_OV:
 355  807D 3E 30        	ld a,"0"					; set digit as "0"								;807d	3e 30
 356  807F 32 CB 83     	ld (TXT_SCORE_DIGITS+4),a	; store new 5th digit							;807f	32 cb 83
 357  8082              ;-----------------------------------------------------------------------------------------------
 358  8082              ; Increment Score value by 10
 359  8082              SCORE_ADD_10:
 360  8082 3A CA 83     	ld a,(TXT_SCORE_DIGITS+3)	; 4th digit placeholder in Score text			;8082	3a ca 83
 361  8085 3C           	inc a						; add 1 (add 10 to Score in total)				;8085	3c
 362  8086 FE 3A        	cp $3a						; check if digit was "9" before increment		;8086	fe 3a
 363  8088 CA 8F 80     	jp z,SCORE_ADD_10_OV		; yes - set to "0" and increment higher digit	;8088	ca 8f 80
 364  808B              ; -- digit value didn't exceeded '9'
 365  808B 32 CA 83     	ld (TXT_SCORE_DIGITS+3),a	; store new 4th digit 							;808b	32 ca 83
 366  808E C9           	ret							; ------------- End of Proc --------------		;808e	c9
 367  808F              ; -- digit overflow - set to '0'
 368  808F              SCORE_ADD_10_OV:
 369  808F 3E 30        	ld a,"0"					; set digit as "0"								;808f	3e 30
 370  8091 32 CA 83     	ld (TXT_SCORE_DIGITS+3),a	; store new 4th digit							;8091	32 ca 83
 371  8094              ;-----------------------------------------------------------------------------------------------
 372  8094              ; Increment Score value by 100
 373  8094              SCORE_ADD_100:
 374  8094 3A C9 83     	ld a,(TXT_SCORE_DIGITS+2)	; 3rd digit placeholder in Score text			;8094	3a c9 83
 375  8097 3C           	inc a						; add 1 (add 100 to Score in total)				;8097	3c
 376  8098 FE 3A        	cp $3a						; check if digit was "9" before increment		;8098	fe 3a
 377  809A CA A1 80     	jp z,SCORE_ADD_100_OV		; yes - set to "0" and increment higher digit	;809a	ca a1 80
 378  809D              ; -- digit value didn't exceeded '9'
 379  809D 32 C9 83     	ld (TXT_SCORE_DIGITS+2),a	; store new 3rd digit 							;809d	32 c9 83
 380  80A0 C9           	ret							; ------------- End of Proc --------------		;80a0	c9
 381  80A1              ; -- digit overflow - set to '0'
 382  80A1              SCORE_ADD_100_OV:
 383  80A1 3E 30        	ld a,"0"					; set digit as "0"								;80a1	3e 30
 384  80A3 32 C9 83     	ld (TXT_SCORE_DIGITS+2),a	; set new 3rd digit 							;80a3	32 c9 83
 385  80A6              ;-----------------------------------------------------------------------------------------------
 386  80A6              ; Increment Score value by 1000 (not used)
 387  80A6              SCORE_ADD_1000:
 388  80A6 3A C8 83     	ld a,(TXT_SCORE_DIGITS+1)	; 2nd digit placeholder in Score text			;80a6	3a c8 83
 389  80A9 3C           	inc a						; add 1 (add 1000 to Score in total)			;80a9	3c
 390  80AA FE 3A        	cp $3a						; check if digit was "9" before increment		;80aa	fe 3a
 391  80AC CA B3 80     	jp z,SCORE_ADD_1000_OV		; yes - set to "0" and increment higher digit	;80ac	ca b3 80
 392  80AF              ; -- digit value didn't exceeded '9'
 393  80AF 32 C8 83     	ld (TXT_SCORE_DIGITS+1),a	; store new 2nd digit 							;80af	32 c8 83
 394  80B2 C9           	ret							; ------------- End of Proc --------------		;80b2	c9
 395  80B3              ; -- digit overflow - set to '0'
 396  80B3              SCORE_ADD_1000_OV:
 397  80B3 3E 30        	ld a,"0"					; set digit as "0"								;80b3	3e 30
 398  80B5 32 C8 83     	ld (TXT_SCORE_DIGITS+1),a	; store new 2nd digit 							;80b5	32 c8 83
 399  80B8              ;-----------------------------------------------------------------------------------------------
 400  80B8              ; Increment Score value by 10000 (not used)
 401  80B8              SCORE_ADD_10000
 402  80B8 3A C7 83     	ld a,(TXT_SCORE_DIGITS)		; 1st digit placeholder in Score text			;80b8	3a c7 83
 403  80BB 3C           	inc a						; add 1 (add 10000 to Score in total)			;80bb	3c
 404  80BC FE 3A        	cp $3a						; check if digit was "9" before increment		;80bc	fe 3a
 405  80BE CA CF 80     	jp z,SCORE_ADD_10000_OV		; yes - set to "0" and overflow total to 00000	;80be	ca cf 80
 406  80C1              ; -- digit value didn't exceeded '9'
 407  80C1 32 C7 83     	ld (TXT_SCORE_DIGITS),a		; store new 1st digit							;80c1	32 c7 83
 408  80C4 3A 04 80     	ld a,(MEN_LIVES)			; Life Counter									;80c4	3a 04 80
 409  80C7 FE 09        	cp 9						; check if Player has 9 lives already			;80c7	fe 09
 410  80C9 F0           	ret p						; yes ---------- End of Proc --------------		;80c9	f0
 411  80CA              ; -- Player has less than 9 lives
 412  80CA 3C           	inc a						; give Player 1 more Life						;80ca	3c
 413  80CB 32 04 80     	ld (MEN_LIVES),a			; store new value								;80cb	32 04 80
 414  80CE C9           	ret							; ------------- End of Proc --------------		;80ce	c9
 415  80CF              ; -- digit overflow - set to '0'
 416  80CF              SCORE_ADD_10000_OV:
 417  80CF 3E 30        	ld a,"0"					; set digit as "0"								;80cf	3e 30
 418  80D1 32 C7 83     	ld (TXT_SCORE_DIGITS),a		; store new 1st digit 							;80d1	32 c7 83
 419  80D4 C9           	ret							; ------------- End of Proc --------------		;80d4	c9
 420  80D5
 421  80D5
 422  80D5              ;***********************************************************************************************
 423  80D5              ;
 424  80D5              ;   S E T   G A M E   I N P U T
 425  80D5              ;
 426  80D5              ;***********************************************************************************************
 427  80D5              ; Ask user about using Joystick, check keys for answer and store Input Flag
 428  80D5              GAME_INIT:
 429  80D5              ; -- display Joystick Question
 430  80D5 CD F6 82     	call CLEAR_SCREEN			; reset Screen to MODE 0 (text) and clear		;80d5	cd f6 82
 431  80D8 21 29 83     	ld hl,TXT_JOYSTICK_Q		; question about Yoistick						;80d8	21 29 83
 432  80DB 11 00 70     	ld de,VRAM+0				; screen text coord (0,0) [$7000]				;80db	11 00 70
 433  80DE CD 08 83     	call PRINT_TEXT				; Print Text data on screen						;80de	cd 08 83
 434  80E1              ; -- set default value - no Joystick as default
 435  80E1 AF           	xor a						; 0 - no joystick, only keyboard				;80e1	af
 436  80E2 32 7C 8F     	ld (INPUT.JOY_ENABLE),a		; store as default value						;80e2	32 7c 8f
 437  80E5              ; -- check key pressed - wait for N or Y
 438  80E5              .WAIT_FOR_KEY:
 439  80E5 3A EF 6F     	ld a,(INPUT.KEYS_ROW_4)		; select Keyboard row 4 						;80e5	3a ef 6f
 440  80E8 CB 47        	bit 0,a						; check if key 'N' pressed						;80e8	cb 47
 441  80EA CA FA 80     	jp z,GAME_START				; yes - Start the Game - flag already set		;80ea	ca fa 80
 442  80ED 3A BF 6F     	ld a,(INPUT.KEYS_ROW_6)		; select Keyboard row 6							;80ed	3a bf 6f
 443  80F0 CB 47        	bit 0,a						; check if key 'Y' pressed						;80f0	cb 47
 444  80F2 C2 E5 80     	jp nz,.WAIT_FOR_KEY			; no - wait for 'Y' or 'N' key					;80f2	c2 e5 80
 445  80F5              ; -- key 'Y' pressed - set Input Flag to Joystick
 446  80F5 3E 01        	ld a,1						; 1 - use joystick								;80f5	3e 01
 447  80F7 32 7C 8F     	ld (INPUT.JOY_ENABLE),a		; store settings value							;80f7	32 7c 8f
 448  80FA
 449  80FA
 450  80FA
 451  80FA              ;***********************************************************************************************
 452  80FA              ;
 453  80FA              ;   M A I N   G A M E   S T A R T
 454  80FA              ;
 455  80FA              ;***********************************************************************************************
 456  80FA              GAME_START:
 457  80FA F3           	di							; disable interrupts							;80fa	f3
 458  80FB 31 FE 8F     	ld sp,$8ffe					; set Stack Pointer - safe value for 6kB		;80fb	31 fe 8f
 459  80FE              ; -- display Game Tiltle
 460  80FE CD F6 82     	call CLEAR_SCREEN			; reset Screen to MODE 0 (text) and clear		;80fe	cd f6 82
 461  8101 21 65 83     	ld hl,TXT_GAME_TITLE		; Game Title text - VZ GHOST HUNTER				;8101	21 65 83
 462  8104 11 20 70     	ld de,VRAM+(1*32)+0			; screen text coord (0,1) [$7020]				;8104	11 20 70
 463  8107 CD 08 83     	call PRINT_TEXT				; Print Text data on screen						;8107	cd 08 83
 464  810A              ; -- display Help screen with keys mappings
 465  810A 21 85 83     	ld hl,TXT_HELP_SCREEN		; Help Screen text								;810a	21 85 83
 466  810D 11 8A 70     	ld de,VRAM+(4*32)+10		; screen text coord (4,4) [$708a]				;810d	11 8a 70
 467  8110 CD 08 83     	call PRINT_TEXT				; Print Text data on screen						;8110	cd 08 83
 468  8113              .WAIT_FOR_S_KEY:
 469  8113 3A FD 6F     	ld a,(INPUT.KEYS_ROW_1)		; select Keyboard row 1							;8113	3a fd 6f
 470  8116 CB 4F        	bit 1,a						; check if key 'S' pressed						;8116	cb 4f
 471  8118 C2 13 81     	jp nz,.WAIT_FOR_S_KEY		; no - wait for Start key						;8118	c2 13 81
 472  811B
 473  811B              ; -- key 'S' pressed - start game
 474  811B 3E 03        	ld a,3						; give Pleyer 3 lives on start 					;811b	3e 03
 475  811D 32 04 80     	ld (MEN_LIVES),a			; store to Life Counter							;811d	32 04 80
 476  8120 3E 01        	ld a,1						; 1st Frame to play								;8120	3e 01
 477  8122 32 03 80     	ld (LEVEL),a				; store as current Frame						;8122	32 03 80
 478  8125              ; -- set Score text to "00000"
 479  8125 21 C7 83     	ld hl,TXT_SCORE_DIGITS		; 1st digit placeholder in Score text			;8125	21 c7 83
 480  8128 11 C8 83     	ld de,TXT_SCORE_DIGITS+1	; 2nd digit placeholder in Score text			;8128	11 c8 83
 481  812B 01 04 00     	ld bc,4						; 4 bytes to set								;812b	01 04 00
 482  812E 36 30        	ld (hl),"0"					; set 1st byte to "0"							;812e	36 30
 483  8130 ED B0        	ldir						; copy this value to next 4 bytes				;8130	ed b0
 484  8132
 485  8132              ;***********************************************************************************************
 486  8132              ;
 487  8132              ;   G A M E    L E V E L   I N I T
 488  8132              ;
 489  8132              ;***********************************************************************************************
 490  8132              GAME_LEVEL_INIT:
 491  8132              ; -- create Collision Map
 492  8132 CD 52 8B     	call CMAP_DOTS_PILLS		; mark Dots and Power Pills in Collision Map	;8132	cd 52 8b
 493  8135 CD F5 8A     	call CMAP_MARK_PASSAGES		; mark Passages/Walls in Collision Map			;8135	cd f5 8a
 494  8138
 495  8138              ; -- reset Game State Data - fill block (46 bytes) with 0 value
 496  8138 21 05 80     	ld hl,GAME_STATE			; src - address of Game State block data		;8138	21 05 80
 497  813B 11 06 80     	ld de,GAME_STATE+1			; dst - address + 1								;813b	11 06 80
 498  813E 01 2D 00     	ld bc,45					; cnt - 45 bytes of data						;813e	01 2d 00
 499  8141 36 00        	ld (hl),0					; store 0 as init value							;8141	36 00
 500  8143 ED B0        	ldir						; fill Game State data with 0 					;8143	ed b0
 501  8145
 502  8145              ; -- set number of times Heart will spawn in this Level
 503  8145 ED 5F        	ld a,r						; a - random value								;8145	ed 5f
 504  8147 E6 03        	and $03						; narrow range to 0..3							;8147	e6 03
 505  8149 3C           	inc a						; shift range to 1..4							;8149	3c
 506  814A 32 31 80     	ld (HEARTS_PER_LEVEL),a		; store number of Hearts for this Level			;814a	32 31 80
 507  814D
 508  814D              ; -- initialize Level Data for current Level
 509  814D 3A 03 80     	ld a,(LEVEL)				; current Level to play							;814d	3a 03 80
 510  8150 FE 01        	cp 1						; is this 1st Level								;8150	fe 01
 511  8152 CA 6A 81     	jp z,COPY_LEVEL1_DATA		; initialize Level Data							;8152	ca 6a 81
 512  8155 FE 02        	cp 2						; is this 2nd Level								;8155	fe 02
 513  8157 CA 70 81     	jp z,COPY_LEVEL2_DATA		; initialize Level Data							;8157	ca 70 81
 514  815A FE 03        	cp 3						; is this 3rd Level								;815a	fe 03
 515  815C CA 76 81     	jp z,COPY_LEVEL3_DATA		; initialize Level Data							;815c	ca 76 81
 516  815F FE 04        	cp 4						; is this 4th Level								;815f	fe 04
 517  8161 CA 7C 81     	jp z,COPY_LEVEL4_DATA		; initialize Level Data							;8161	ca 7c 81
 518  8164              ; - must be 5 Level
 519  8164
 520  8164              ; -- initialize 4 Level dependend variables
 521  8164 21 5A 8C     	ld hl,DATA_LEVEL5			; src - Level Data 0							;8164	21 5a 8c
 522  8167 C3 7F 81     	jp INIT_LEVEL_DATA			; copy Level data								;8167	c3 7f 81
 523  816A              COPY_LEVEL1_DATA:
 524  816A 21 4A 8C     	ld hl,DATA_LEVEL1			; src - Level Data 1							;816a	21 4a 8c
 525  816D C3 7F 81     	jp INIT_LEVEL_DATA			; copy Level data								;816d	c3 7f 81
 526  8170              COPY_LEVEL2_DATA:
 527  8170 21 4E 8C     	ld hl,DATA_LEVEL2			; src - Level Data 2							;8170	21 4e 8c
 528  8173 C3 7F 81     	jp INIT_LEVEL_DATA			; copy Level data								;8173	c3 7f 81
 529  8176              COPY_LEVEL3_DATA:
 530  8176 21 52 8C     	ld hl,DATA_LEVEL3			; src - Level Data 3							;8176	21 52 8c
 531  8179 C3 7F 81     	jp INIT_LEVEL_DATA			; copy Level data								;8179	c3 7f 81
 532  817C              COPY_LEVEL4_DATA:
 533  817C 21 56 8C     	ld hl,DATA_LEVEL4			; src - Level Data 4							;817c	21 56 8c
 534  817F
 535  817F              ; -- copy data predefined for this Level - 4 bytes
 536  817F              INIT_LEVEL_DATA:
 537  817F 11 07 80     	ld de,LEVEL_DATASET			; dst - Level Data for current Level			;817f	11 07 80
 538  8182 01 04 00     	ld bc,4						; 4 bytes to copy								;8182	01 04 00
 539  8185 ED B0        	ldir						; copy data										;8185	ed b0
 540  8187
 541  8187              ;***********************************************************************************************
 542  8187              ;
 543  8187              ;   G A M E   L E V E L  S T A R T
 544  8187              ;
 545  8187              ;***********************************************************************************************
 546  8187              ; Start of Gameplay - current Level
 547  8187              GAME_LEVEL_START:
 548  8187 31 FE 8F     	ld sp,$8ffe					; reset Stack Pointer 							;8187	31 fe 8f
 549  818A CD C0 82     	call PRINT_STATUS_CLS		; clear screen and print Status Screen			;818a	cd c0 82
 550  818D              ; -- as a side effect from above routine register bc = 0
 551  818D
 552  818D              ; -- long delay - 8*65536 = 524288
 553  818D 3E 08        	ld a,8						; repeat delay counter							;818d	3e 08
 554  818F              .WAIT_DELAY:
 555  818F F5           	push af						; save af - repeat counter						;818f	f5
 556  8190 CD 5D 87     	call DELAY_BC				; delay (bc = 65536)							;8190	cd 5d 87
 557  8193 F1           	pop af						; restore af 									;8193	f1
 558  8194 3D           	dec a						; decrement counter (check if 0)				;8194	3d
 559  8195 C2 8F 81     	jp nz,.WAIT_DELAY			; no - repeat delay 8 times						;8195	c2 8f 81
 560  8198
 561  8198              ; -- initialize screen
 562  8198 CD EE 8A     	call DRAW_LEVEL_SCREEN		; draw Maze Walls, Dots and Pills				;8198	cd ee 8a
 563  819B
 564  819B              ; -- initialize Update Timers to 1 - will update in next iteration of Game Loop
 565  819B 3E 01        	ld a,1						; a - init value for Timers (update now)		;819b	3e 01
 566  819D 32 12 80     	ld (PLAYER_UPD_TIMER),a		; set Player Update Timer						;819d	32 12 80
 567  81A0 32 13 80     	ld (GHOSTS_UPD_TIMER),a		; set Ghosts Update Timer 						;81a0	32 13 80
 568  81A3 32 14 80     	ld (CMODE_DRAW_TIMER),a		; set Chase Mode Update Timer 					;81a3	32 14 80
 569  81A6
 570  81A6              ; -- initialize Player screen position and Move Direction
 571  81A6 21 8D 75     	ld hl,VRAM+(44*32)+13		; screen coord (52,44)px (13,44)bytes [$758d]	;81a6	21 8d 75
 572  81A9 22 0D 80     	ld (PLAYER_VADR),hl			; hl - destination VRAM address Player			;81a9	22 0d 80
 573  81AC 01 03 00     	ld bc,00003h				; b - no spr shift (0), c - Move Dir (Left)		;81ac	01 03 00
 574  81AF ED 43 0F 80  	ld (PLAYER_PROPS),bc		; store initial values							;81af	ed 43 0f 80
 575  81B3              ; -- spawn Ghost Blue 1 at position 40x30px
 576  81B3 21 CA 73     	ld hl,VRAM+(30*32)+10		; screen coord (40,30)px (10,30)bytes [$73ca]	;81b3	21 ca 73
 577  81B6 22 18 80     	ld (GHOST_B1.VADR),hl		; hl - destination VRAM address Ghost Blue 1	;81b6	22 18 80
 578  81B9 CD EA 83     	call DRAW_GHOST_BLUE		; draw Ghost Blue sprite on screen				;81b9	cd ea 83
 579  81BC              ; -- spawn Ghost Blue 2 at position 48x30px
 580  81BC 21 CC 73     	ld hl,VRAM+(30*32)+12		; screen coord (48,30)px (12,30)bytes [$73cc]	;81bc	21 cc 73
 581  81BF 22 1D 80     	ld (GHOST_B2.VADR),hl		; hl - destination VRAM address Ghost Blue 2	;81bf	22 1d 80
 582  81C2 CD EA 83     	call DRAW_GHOST_BLUE		; draw Ghost Blue sprite on screen				;81c2	cd ea 83
 583  81C5              ; -- spawn Ghost Red 1 at position 56x30px
 584  81C5 21 CE 73     	ld hl,VRAM+(30*32)+14		; screen coord (56,30)px (14,30)bytes [$73ce]	;81c5	21 ce 73
 585  81C8 22 22 80     	ld (GHOST_R1.VADR),hl		; hl - destination VRAM address	Ghost Red 1		;81c8	22 22 80
 586  81CB CD F7 83     	call DRAW_GHOST_RED			; draw Ghost Red sprite on screen				;81cb	cd f7 83
 587  81CE              ; -- spawn Ghost Red 1 at position 64x30px
 588  81CE 21 D0 73     	ld hl,VRAM+(30*32)+16		; screen coord (64,30)px (16,30)bytes [$73d0]	;81ce	21 d0 73
 589  81D1 22 27 80     	ld (GHOST_R2.VADR),hl		; hl - destination VRAM address	Ghost Red 2		;81d1	22 27 80
 590  81D4 CD FD 83     	call DRAW_GHOST_REDA		; draw Ghost Red A variant sprite on screen		;81d4	cd fd 83
 591  81D7              ; -- generate random Freeze Time for Ghost Blue 1
 592  81D7 CD 03 84     	call RANDOM_32_63			; a - Random Value in range 32..63				;81d7	cd 03 84
 593  81DA E6 0F        	and $0f						; constrain range to 0..15						;81da	e6 0f
 594  81DC F6 08        	or $08						; move range value to 8..15						;81dc	f6 08
 595  81DE 32 1C 80     	ld (GHOST_B1.FREEZE),a		; set Ghost Blue 1 Freeze Timer					;81de	32 1c 80
 596  81E1              ; -- generate random Freeze Time for Ghost Blue 2
 597  81E1 CD 03 84     	call RANDOM_32_63			; a - Random Value in range 32..63				;81e1	cd 03 84
 598  81E4 F6 10        	or $10						; move range value to 48..63					;81e4	f6 10
 599  81E6 32 21 80     	ld (GHOST_B2.FREEZE),a		; set Ghost Blue 2 Freeze Timer					;81e6	32 21 80
 600  81E9              ; -- generate random Freeze Time for Ghost Red 1
 601  81E9 CD 03 84     	call RANDOM_32_63			; a - Random Value in range 32..63				;81e9	cd 03 84
 602  81EC F6 20        	or $20						; move range value to 32..63					;81ec	f6 20
 603  81EE 32 26 80     	ld (GHOST_R1.FREEZE),a		;; set Ghost Red 1 Freeze Timer					;81ee	32 26 80
 604  81F1              ; -- generate random Freeze Time for Ghost Red 2
 605  81F1 CD 03 84     	call RANDOM_32_63			; a - Random Value in range 32..63				;81f1	cd 03 84
 606  81F4 F6 40        	or $40						; move range to range value 64..95 				;81f4	f6 40
 607  81F6 32 2B 80     	ld (GHOST_R2.FREEZE),a		; set Ghost Red 2 Freeze Timer					;81f6	32 2b 80
 608  81F9              ; -- initialize Heart timers
 609  81F9 CD 7E 82     	call INIT_HEART_PROPS		; init Heart parameters							;81f9	cd 7e 82
 610  81FC
 611  81FC
 612  81FC              ;***********************************************************************************************
 613  81FC              ;
 614  81FC              ;   G A M E    L O O P
 615  81FC              ;
 616  81FC              ;***********************************************************************************************
 617  81FC
 618  81FC              GAME_LOOP
 619  81FC CD 5D 8A     	call GL_DRAW_DOTS_PILLS		; draw Dots and Power Pills						;81fc	cd 5d 8a
 620  81FF CD 64 87     	call GL_UPDATE_PLAYER		; update Player position and draw 				;81ff	cd 64 87
 621  8202 CD 4D 84     	call GL_UPDATE_GHOSTS		; update Ghosts positions (except Ghost Red A)	;8202	cd 4d 84
 622  8205 CD B9 84     	call GL_UPDATE_GHOSTA		; update Ghost Red A position and draw			;8205	cd b9 84
 623  8208 CD 0A 84     	call GL_UPDATE_CHASE_MODE	; update screen colors if in Chase Mode 		;8208	cd 0a 84
 624  820B CD 22 8A     	call GL_DRAW_FREEZED_GHOSTS	; draw freezed Ghosts 							;820b	cd 22 8a
 625  820E CD 1A 82     	call GL_UPDATE_HEART		; update Heart timer and draw if it's active	;820e	cd 1a 82
 626  8211 01 12 00     	ld bc,18					; delay value									;8211	01 12 00
 627  8214 CD 5D 87     	call DELAY_BC				; wait Delay									;8214	cd 5d 87
 628  8217 C3 FC 81     	jp GAME_LOOP				; ---------- Repeat Game Loop -----------------	;8217	c3 fc 81
 629  821A
 630  821A
 631  821A              ;***********************************************************************************************
 632  821A              ;
 633  821A              ;   G A M E    L O O P  -  U P D A T E   H E A R T
 634  821A              ;
 635  821A              ;***********************************************************************************************
 636  821A              GL_UPDATE_HEART:
 637  821A              ; -- decrement timer and check if it's time to update
 638  821A 3A 2D 80     	ld a,(HEART_UPD_TIMER)		; Heart Update Timer value						;821a	3a 2d 80
 639  821D 3D           	dec a						; decrement timer - check if 0					;821d	3d
 640  821E 32 2D 80     	ld (HEART_UPD_TIMER),a		; store new value								;821e	32 2d 80
 641  8221 C0           	ret nz						; no - don't update in this Game Loop iteration	;8221	c0
 642  8222              ; -- check if any Hearts can be shown for this Level
 643  8222 3A 31 80     	ld a,(HEARTS_PER_LEVEL)		; Number of Hearts left for this Level			;8222	3a 31 80
 644  8225 B7           	or a						; are any left?									;8225	b7
 645  8226 C8           	ret z						; no ------------ End of Proc -----------------	;8226	c8
 646  8227              ; -- check if it's time to show Heart
 647  8227 3A 2E 80     	ld a,(HEART_SHOW_TIMER)		; Heart Show Timer value						;8227	3a 2e 80
 648  822A B7           	or a						; check if it's already shown					;822a	b7
 649  822B CA 48 82     	jp z,.UPDATE_HEART			; yes - skip create - just update Heart			;822b	ca 48 82
 650  822E              ; -- decrement Heart Show Timer and check if it's time to show Heart
 651  822E 3D           	dec a						; decrement timer and check if 0				;822e	3d
 652  822F 32 2E 80     	ld (HEART_SHOW_TIMER),a		; store new value								;822f	32 2e 80
 653  8232 C0           	ret nz						; not yet ------- End of Proc ----------------- ;8232	c0
 654  8233
 655  8233              ; -- counter just set to 0 - it's time to create Heart
 656  8233              ; -- set Heart Bits (7,6) in Collision Map
 657  8233 21 AD 74     	ld hl,VRAM+(37*32)+13		; screen coord (52,37)px (13,37)bytes [$74ad]	;8233	21 ad 74
 658  8236 CD E9 89     	call CMAP_GET_BYTE			; de - address in Colision Map					;8236	cd e9 89
 659  8239 06 C0        	ld b,%11000000				; Heart Bits (7,6) to set in CMap				;8239	06 c0
 660  823B CD 8F 86     	call CMAP_SET_2X4			; set Heart Bits (7,6) in CMap (8x4)px (2x4)b	;823b	cd 8f 86
 661  823E              ; -- check Show Walls Flag - skip drawing Maze Walls if not set
 662  823E 3A 30 80     	ld a,(SHOW_WALLS_FLAG)		; show/hide Maze Walls flag 					;823e	3a 30 80
 663  8241 B7           	or a						; check if 0									;8241	b7
 664  8242 CA 48 82     	jp z,.UPDATE_HEART			; yes - don't draw Maze Walls					;8242	ca 48 82
 665  8245 CD C8 8B     	call DRAW_MAZE_WALLS		; draw Maze Lines on screen						;8245	cd c8 8b
 666  8248              .UPDATE_HEART:
 667  8248              ; -- draw Heart Sprite at predefined coordinates
 668  8248 21 3A 8F     	ld hl,SPR.HEART				; Sprite Heart data (8x4)px (2x4) bytes			;8248	21 3a 8f
 669  824B 11 AD 74     	ld de,VRAM+(37*32)+13		; screen coord (52,37)px (13,37)bytes [$74ad]	;824b	11 ad 74
 670  824E 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;824e	01 02 00
 671  8251 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;8251	3e 04
 672  8253 CD 75 89     	call DRAW_SPRITE			; draw sprite on screen							;8253	cd 75 89
 673  8256              ; -- decrement Heart Life Counter and check if time elapsed
 674  8256 3A 2F 80     	ld a,(HEART_ON_TIMER)		; Heart On Timer value							;8256	3a 2f 80
 675  8259 3D           	dec a						; decrement timer - check if 0					;8259	3d
 676  825A 32 2F 80     	ld (HEART_ON_TIMER),a		; store new value								;825a	32 2f 80
 677  825D C0           	ret nz						; no ------------ End of Proc -----------------	;825d	c0
 678  825E
 679  825E              ; -- Heart LifeTime Elapsed - remove Heart from screen and Collision Map
 680  825E 21 AD 74     	ld hl,VRAM+(37*32)+13		; screen coord (52,37)px (13,37)bytes [$74ad]	;825e	21 ad 74
 681  8261 CD E9 89     	call CMAP_GET_BYTE			; de - address in Colision Map					;8261	cd e9 89
 682  8264 06 3F        	ld b,%00111111				; bitmask to clear bits 7 and 6					;8264	06 3f
 683  8266 CD 78 86     	call CMAP_CLEAR_2X4			; clear bits 7 and 6 in buffer for this sprite	;8266	cd 78 86
 684  8269              ; -- clear screen area
 685  8269 21 F1 8E     	ld hl,SPR.EMPTY				; Sprite Empty (8x4)px (2x4) bytes				;8269	21 f1 8e
 686  826C 11 AD 74     	ld de,VRAM+(37*32)+13		; screen coord (52,37)px (13,37)bytes [$74ad]	;826c	11 ad 74
 687  826F 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;826f	01 02 00
 688  8272 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;8272	3e 04
 689  8274 CD 75 89     	call DRAW_SPRITE			; draw sprite on screen (clear)					;8274	cd 75 89
 690  8277              ; -- update Show Walls Flag and reinitialize Heart parameters for next time
 691  8277 CD 2B 8C     	call UPDATE_SHOW_WALLS		; update Show Walls Flag if Level > 3			;8277	cd 2b 8c
 692  827A CD 7E 82     	call INIT_HEART_PROPS		; initialize Heart Timers						;827a	cd 7e 82
 693  827D C9           	ret							; -------------- End of Proc ------------------	;827d	c9
 694  827E
 695  827E
 696  827E              ;***********************************************************************************************
 697  827E              ; Initialize Heart parameters:
 698  827E              ; HEART_TIMER - number of game loop ticks before Heart will show
 699  827E              ; HEART_LIFETIME - number of game loop ticks Heart wil be shown before removed
 700  827E              INIT_HEART_PROPS:
 701  827E              ; -- reset Heart Timer to random value (128..255)
 702  827E ED 5F        	ld a,r						; a - random value								;827e	ed 5f
 703  8280 E6 7F        	and %01111111				; range 0..127									;8280	e6 7f
 704  8282 F6 80        	or 	%10000000				; range 128..255								;8282	f6 80
 705  8284 32 2E 80     	ld (HEART_SHOW_TIMER),a		; set Heart Timer								;8284	32 2e 80
 706  8287              ; -- reset Heart LifeTime
 707  8287 3E 50        	ld a,80						; set LifeTIme Counter to 80					;8287	3e 50
 708  8289 32 2F 80     	ld (HEART_ON_TIMER),a		; store into timer variable 					;8289	32 2f 80
 709  828C              ; -- hide Maze Walls
 710  828C AF           	xor a						; reset Show Walls Flag							;828c	af
 711  828D 32 30 80     	ld (SHOW_WALLS_FLAG),a		; hide Maze Walls - don't draw					;828d	32 30 80
 712  8290 C9           	ret							; -------------- End of Proc ------------------	;8290	c9
 713  8291
 714  8291              ;***********************************************************************************************
 715  8291              ; Show Game Over Screen
 716  8291              ; Clear screen and print Game Over Text 12 times in 6 lines. Next jump to PRINT_STATUS routine.
 717  8291              GAME_OVER:
 718  8291 CD F6 82     	call CLEAR_SCREEN			; reset Screen to MODE 0 (text) and clear		;8291	cd f6 82
 719  8294 3E 03        	ld a,3						; repeat 3 times								;8294	3e 03
 720  8296 21 CD 83     	ld hl,TXT_GAME_OVER			; Game Over text line							;8296	21 cd 83
 721  8299 11 00 70     	ld de,VRAM+0				; screen text coord (0,0) [$7000]				;8299	11 00 70
 722  829C CD AD 82     	call PRINT_TEXT_X_TIMES		; print Game Over line 3 times					;829c	cd ad 82
 723  829F 3E 03        	ld a,3						; repeat 3 times								;829f	3e 03
 724  82A1 21 CD 83     	ld hl,TXT_GAME_OVER			; Game Over text line							;82a1	21 cd 83
 725  82A4 11 80 71     	ld de,VRAM+(12*32)+0		; screen text coord (0,12) [$7180]				;82a4	11 80 71
 726  82A7 CD AD 82     	call PRINT_TEXT_X_TIMES		; print Game Over line 3 times					;82a7	cd ad 82
 727  82AA C3 C3 82     	jp PRINT_STATUS				; jump to Print Status routine					;82aa	c3 c3 82
 728  82AD
 729  82AD              ;***********************************************************************************************
 730  82AD              ; Print Text on screen multiple times in multiple lines
 731  82AD              ; IN: hl - address of text data to print on screen
 732  82AD              ;     de - destination VRAM address
 733  82AD              ;     a  - how many times (lines) display this text
 734  82AD              PRINT_TEXT_X_TIMES:
 735  82AD F5           	push af						; save af (a = repeat counter)					;82ad	f5
 736  82AE E5           	push hl						; save hl - text to print on screen				;82ae	e5
 737  82AF D5           	push de						; save de - VRAM destination address			;82af	d5
 738  82B0 CD 08 83     	call PRINT_TEXT				; Print Text on screen							;82b0	cd 08 83
 739  82B3 D1           	pop de						; restore de - VRAM address						;82b3	d1
 740  82B4 21 20 00     	ld hl,32					; 32 bytes per screen line						;82b4	21 20 00
 741  82B7 19           	add hl,de					; shift adrress to next line 					;82b7	19
 742  82B8 EB           	ex de,hl					; de - new VRAM destination address				;82b8	eb
 743  82B9 E1           	pop hl						; restore hl - text source						;82b9	e1
 744  82BA F1           	pop af						; restore af - a repeat counter					;82ba	f1
 745  82BB 3D           	dec a						; decrement counter (check if 0)				;82bb	3d
 746  82BC C2 AD 82     	jp nz,PRINT_TEXT_X_TIMES	; not 0 - repeat print on screeen				;82bc	c2 ad 82
 747  82BF C9           	ret							; --------------- End of Proc -----------		;82bf	c9
 748  82C0
 749  82C0              ;***********************************************************************************************
 750  82C0              ; Clear Screen and print Status data.beg.
 751  82C0              ; Used before fresh new Game and along with Game Over Screen
 752  82C0              PRINT_STATUS_CLS:
 753  82C0 CD F6 82     	call CLEAR_SCREEN			; reset Screen to MODE 0 (text) and clear		;82c0	cd f6 82
 754  82C3              PRINT_STATUS:
 755  82C3              ; -- copy score digits from Help Screen to Status Screen
 756  82C3 21 C7 83     	ld hl,TXT_SCORE_DIGITS		; src - Score digits - Help Screen				;82c3	21 c7 83
 757  82C6 11 4C 83     	ld de,TXT_SCORE_DIGITS_STA	; dst - Score digits - Status Screen			;82c6	11 4c 83
 758  82C9 01 05 00     	ld bc,5						; 5 bytes/chars to copy							;82c9	01 05 00
 759  82CC ED B0        	ldir						; copy bytes 									;82cc	ed b0
 760  82CE              ; -- update Life Counter info (MEN)
 761  82CE 3A 04 80     	ld a,(MEN_LIVES)			; current Life Counter value					;82ce	3a 04 80
 762  82D1 C6 30        	add a,'0'					; convert to char digit							;82d1	c6 30
 763  82D3 32 59 83     	ld (TXT_MEN_DIGIT),a		; update text buffer							;82d3	32 59 83
 764  82D6              ; -- update info about Game Frame
 765  82D6 3A 03 80     	ld a,(LEVEL)				; a - current Game Level to play				;82d6	3a 03 80
 766  82D9 F5           	push af						; save af 										;82d9	f5
 767  82DA C6 30        	add a,'0'					; convert to char digit							;82da	c6 30
 768  82DC 32 62 83     	ld (TXT_LEVEL_DIGITS),a		; update text buffer							;82dc	32 62 83
 769  82DF F1           	pop af						; restore af - a - current Level				;82df	f1
 770  82E0              ; -- place '+' char if current Level > 5
 771  82E0 FE 06        	cp 6						; check if LEVEL > 5							;82e0	fe 06
 772  82E2 3E 20        	ld a,' '					; space char for Levels 1..5					;82e2	3e 20
 773  82E4 FA E9 82     	jp m,.SET_EXTRA_CHAR		; skip if LEVEL < 6								;82e4	fa e9 82
 774  82E7 3E 2B        	ld a,'+'					; '+' char for Levels 6...n						;82e7	3e 2b
 775  82E9              .SET_EXTRA_CHAR:
 776  82E9 32 63 83     	ld (TXT_LEVEL_DIGITS+1),a	; set char next to Level number					;82e9	32 63 83
 777  82EC              ; -- everything updated - print on screen
 778  82EC 21 39 83     	ld hl,TXT_GAME_STATUS		; src - Status Text								;82ec	21 39 83
 779  82EF 11 8A 70     	ld de,VRAM+(4*32)+10		; screen text coord (10,4) [$708a]				;82ef	11 8a 70
 780  82F2 CD 08 83     	call PRINT_TEXT				; Print Text data on screen						;82f2	cd 08 83
 781  82F5 C9           	ret							; ---------------- End of Proc -------------	;82f5	c9
 782  82F6
 783  82F6              ;***********************************************************************************************
 784  82F6              ; Clear Screen
 785  82F6              ; Custom clear screen routine via set first byte to Space and copy previous byte to next 511 times.
 786  82F6              CLEAR_SCREEN:
 787  82F6 21 00 70     	ld hl,VRAM				; src - address of Video RAM Memory					;82f6	21 00 70
 788  82F9 11 01 70     	ld de,VRAM+1			; dst - address + 1									;82f9	11 01 70
 789  82FC 01 FF 01     	ld bc,511				; cnt - 511 times copy								;82fc	01 ff 01
 790  82FF 36 20        	ld (hl)," "				; set 1st byte to space (clear)						;82ff	36 20
 791  8301 ED B0        	ldir					; fill VRAM with space char							;8301	ed b0
 792  8303              ; -- reset VDG MODE 0, Background Green, Speaker Off
 793  8303 AF           	xor a					; VDG MODE 0, Background Color Green				;8303	af
 794  8304 32 00 68     	ld (IOLATCH),a			; store to hardware latch							;8304	32 00 68
 795  8307 C9           	ret						; --------------- End of Proc ---------------		;8307	c9
 796  8308
 797  8308              ;***********************************************************************************************
 798  8308              ; Print Text data on screen
 799  8308              ; Text must be delimited by 0. Routine supports new line character ($0d) (simplified way).
 800  8308              ; ASCII chars are converted to upper case before print.
 801  8308              ; IN: hl - address of text data to print on screen
 802  8308              ;     de - destination VRAM address
 803  8308              PRINT_TEXT:
 804  8308 D5           	push de					; save de - target VRAM address						;8308	d5
 805  8309              .NEXT_CHAR:
 806  8309 7E           	ld a,(hl)				; char to display on screen							;8309	7e
 807  830A FE 0D        	cp $0d					; check if New Line Char							;830a	fe 0d
 808  830C CA 1B 83     	jp z,.NEXT_LINE			; yes - calculate new target address				;830c	ca 1b 83
 809  830F              ; -- Char to print is not New Line ($0d)
 810  830F B7           	or a					; check if 0 - end of text							;830f	b7
 811  8310 CA 27 83     	jp z,.EXIT				; yes - return to caller							;8310	ca 27 83
 812  8313              ; -- a - ASCII char do print on screen
 813  8313 CB B7        	res 6,a					; clear bit 6 - change to UpperCase					;8313	cb b7
 814  8315 12           	ld (de),a				; print char to screen								;8315	12
 815  8316 23           	inc hl					; next source address								;8316	23
 816  8317 13           	inc de					; next destination address							;8317	13
 817  8318 C3 09 83     	jp .NEXT_CHAR			; continue with remaining chars						;8318	c3 09 83
 818  831B              .NEXT_LINE:
 819  831B              ; -- add 32 bytes to destination VRAM address
 820  831B D1           	pop de					; VRAM address of first char of current line		;831b	d1
 821  831C E5           	push hl					; save hl - current char address					;831c	e5
 822  831D 21 20 00     	ld hl,32				; 32 bytes per screen line							;831d	21 20 00
 823  8320 19           	add hl,de				; VRAM address in next line							;8320	19
 824  8321 EB           	ex de,hl				; set as destination address						;8321	eb
 825  8322 E1           	pop hl					; restore hl - current char address					;8322	e1
 826  8323 23           	inc hl					; next char to pront								;8323	23
 827  8324 C3 08 83     	jp PRINT_TEXT			; continue with remaining chars						;8324	c3 08 83
 828  8327              .EXIT:
 829  8327 D1           	pop de					; restore de 										;8327	d1
 830  8328 C9           	ret						; -------------- End of Proc ---------------		;8328	c9
 831  8329
 832  8329              ;***********************************************************************************************
 833  8329              ; Input Settings Question text
 834  8329              TXT_JOYSTICK_Q:
 835  8329
 836  8329 4A 4F 59 53  	defb	"JOYSTICKS (Y-N)",0							;8329	4a 4f 59 53 54 49 43 4b 53 20 28 59 2d 4e 29 00
 836  832D 54 49 43 4B
 836  8331 53 20 28 59
 836  8335 2D 4E 29 00
 837  8339
 838  8339              ;***********************************************************************************************
 839  8339              ; Game Status and Score text
 840  8339              TXT_GAME_STATUS:
 841  8339
 842  8339 47 41 4D 45  	defb	"GAME STATUS",$0d,$0d						;8339	47 41 4d 45 20 53 54 41 54 55 53 0d 0d
 842  833D 20 53 54 41
 842  8341 54 55 53 0D
 842  8345 0D
 843  8346 53 43 4F 52  	defb 	"SCORE "									;8346	53 43 4f 52 45 20
 843  834A 45 20
 844  834C              TXT_SCORE_DIGITS_STA
 845  834C 00 00 00 00  	defb	0,0,0,0,0		; digit placeholder			;834c	00 00 00 00 00
 845  8350 00
 846  8351 0D 0D        	defb	$0d,$0d										;8351	0d 0d
 847  8353 4D 45 4E 20  	defb	"MEN   "									;8353	4d 45 4e 20 20 20
 847  8357 20 20
 848  8359              TXT_MEN_DIGIT
 849  8359 00           	defb	0				; digit placeholder			;8359	00
 850  835A 0D 0D        	defb	$0d,$0d										;835a	0d 0d
 851  835C 46 52 41 4D  	defb	"FRAME "									;835c	46 52 41 4d 45 20
 851  8360 45 20
 852  8362              TXT_LEVEL_DIGITS
 853  8362 00 00        	defb	0,0				; digit placeholder			;8362	00 00
 854  8364 00           	defb	0				; end of text				;8364	00
 855  8365
 856  8365              ;***********************************************************************************************
 857  8365              ; Game Title text
 858  8365              TXT_GAME_TITLE:
 859  8365
 860  8365 20 56 20 5A  	defb	" V Z  -  G H O S T  H U N T E R",0			;8365	20 56 20 5a 20 20 2d 20 20 47 20 48 20 4f 20 53 20 54 20 20 48 20 55 20 4e 20 54 20 45 20 52 00
 860  8369 20 20 2D 20
 860  836D 20 47 20 48
 860  8371 20 4F 20 53
 860  8375 20 54 20 20
 860  8379 48 20 55 20
 860  837D 4E 20 54 20
 860  8381 45 20 52 00
 861  8385
 862  8385              ;***********************************************************************************************
 863  8385              ; Help screen text
 864  8385              TXT_HELP_SCREEN:
 865  8385
 866  8385 3C 53 3E 20  	defb	"<S> = START",$0d,$0d						;8385	3c 53 3e 20 3d 20 53 54 41 52 54 0d 0d
 866  8389 3D 20 53 54
 866  838D 41 52 54 0D
 866  8391 0D
 867  8392 3C 4D 3E 20  	defb	"<M> = LEFT",$0d,$0d						;8392	3c 4d 3e 20 3d 20 4c 45 46 54 0d 0d
 867  8396 3D 20 4C 45
 867  839A 46 54 0D 0D
 868  839E 3C 2C 3E 20  	defb	"<,> = RIGHT",$0d,$0d						;839e	3c 2c 3e 20 3d 20 52 49 47 48 54 0d 0d
 868  83A2 3D 20 52 49
 868  83A6 47 48 54 0D
 868  83AA 0D
 869  83AB 3C 51 3E 20  	defb	"<Q> = UP",$0d,$0d							;83ab	3c 51 3e 20 3d 20 55 50 0d 0d
 869  83AF 3D 20 55 50
 869  83B3 0D 0D
 870  83B5 3C 41 3E 20  	defb	"<A> = DOWN",$0d,$0d						;83b5	3c 41 3e 20 3d 20 44 4f 57 4e 0d 0d
 870  83B9 3D 20 44 4F
 870  83BD 57 4E 0D 0D
 871  83C1 53 43 4F 52  	defb	"SCORE "									;83c1	53 43 4f 52 45 20
 871  83C5 45 20
 872  83C7              TXT_SCORE_DIGITS
 873  83C7 30 30 30 30  	defb 	"00000"					; digit placeholder ;83c7	30 30 30 30 30 00
 873  83CB 30
 874  83CC 00           	defb 	0						; end of text		;83cc	00
 875  83CD
 876  83CD              ;***********************************************************************************************
 877  83CD              ; Game Over text
 878  83CD              TXT_GAME_OVER:
 879  83CD
 880  83CD 20 20 20 47  	defb 	"   GAME",$60,"OVER       GAME",$60,"OVER",0 ;83cd	20 20 20 47 41 4d 45 60 4f 56 45 52 20 20 20 20 20 20 20 47 41 4d 45 60 4f 56 45 52 00
 880  83D1 41 4D 45 60
 880  83D5 4F 56 45 52
 880  83D9 20 20 20 20
 880  83DD 20 20 20 47
 880  83E1 41 4D 45 60
 880  83E5 4F 56 45 52
 880  83E9 00
 881  83EA
 882  83EA
 883  83EA              ;***********************************************************************************************
 884  83EA              ; Draw Ghost Blue sprite data on screen at VRAM addres set in hl
 885  83EA              ; IN: hl - destination VRAM address
 886  83EA              DRAW_GHOST_BLUE:
 887  83EA 11 0A 8F     	ld de,SPR.GHOST_BLUE		; Sprite Ghost Blue data (8x4)px (2x4) bytes	;83ea	11 0a 8f
 888  83ED              ;***********************************************************************************************
 889  83ED              ; Draw 8x4 sprite
 890  83ED              ; IN: de - address of sprite data
 891  83ED              ;     hl - destination VRAM address
 892  83ED              DRAW_8x4_SPRITE:
 893  83ED EB           	ex de,hl					; hl - source, de - destination address			;83ed	eb
 894  83EE 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;83ee	01 02 00
 895  83F1 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;83f1	3e 04
 896  83F3 CD 75 89     	call DRAW_SPRITE			; draw Ghost Blue sprite on screen				;83f3	cd 75 89
 897  83F6 C9           	ret							; ---------- End of Proc ----------------		;83f6	c9
 898  83F7
 899  83F7              ;***********************************************************************************************
 900  83F7              ; Draw Ghost Red sprite data on screen at VRAM addres set in hl
 901  83F7              ; IN: hl - destination VRAM address
 902  83F7              DRAW_GHOST_RED:
 903  83F7 11 1A 8F     	ld de,SPR.GHOST_RED			; Sprite Ghost Red data (8x4)px (2x4) bytes		;83f7	11 1a 8f
 904  83FA C3 ED 83     	jp DRAW_8x4_SPRITE			; Draw 8x4 sprite								;83fa	c3 ed 83
 905  83FD
 906  83FD              ;***********************************************************************************************
 907  83FD              ; Draw Ghost Red A variant sprite data on screen at VRAM addres set in hl
 908  83FD              ; IN: hl - destination VRAM address
 909  83FD              DRAW_GHOST_REDA:
 910  83FD 11 2A 8F     	ld de,SPR.GHOST_REDA		; Sprite Ghost Red A variant (8x4)px (2x4)bytes	;83fd	11 2a 8f
 911  8400 C3 ED 83     	jp DRAW_8x4_SPRITE			; Draw 8x4 sprite								;8400	c3 ed 83
 912  8403
 913  8403
 914  8403
 915  8403              ;***********************************************************************************************
 916  8403              ; Get Random Value in range 32..63
 917  8403              RANDOM_32_63:
 918  8403 ED 5F        	ld a,r						; a - random value								;8403	ed 5f
 919  8405 E6 1F        	and $1f						; value range 0..31								;8405	e6 1f
 920  8407 C6 20        	add a,32					; value range 32..63 							;8407	c6 20
 921  8409 C9           	ret							; ---------- End of Proc ----------------		;8409	c9
 922  840A
 923  840A
 924  840A
 925  840A
 926  840A              ;***********************************************************************************************
 927  840A              ;
 928  840A              ;   G A M E    L O O P  -  U P D A T E   C H A S E   M O D E
 929  840A              ;
 930  840A              ;***********************************************************************************************
 931  840A              ; Checks Timer if it's time to update Chase Mode in this Game Loop iteration
 932  840A              ; If so decrement Chase Mode Timer and if value is less than 13 changes Screen Colors
 933  840A              ; in order to inform Player that is close to the end
 934  840A              GL_UPDATE_CHASE_MODE:
 935  840A              ; -- decrement Chase Mode Update Timer and check if we Update Screen in this Game Loop iteration
 936  840A 3A 14 80     	ld a,(CMODE_DRAW_TIMER)		; a - Chase Mode Update Timer					;840a	3a 14 80
 937  840D 3D           	dec a						; decrement timer - check if elapsed			;840d	3d
 938  840E 32 14 80     	ld (CMODE_DRAW_TIMER),a		; store new value								;840e	32 14 80
 939  8411 C0           	ret nz						; no - no update in this Game Loop iteration	;8411	c0
 940  8412
 941  8412              ; -- Update Timer elapsed - check if game is in Ghost Chase Mode
 942  8412 3A 2C 80     	ld a,(CMODE_ON_TIMER)		; a - Ghost Chase Mode Timer					;8412	3a 2c 80
 943  8415 B7           	or a						; is Mode active (a > 0)						;8415	b7
 944  8416 C8           	ret z						; no ------- End of Proc ----------------------	;8416	c8
 945  8417
 946  8417              ; -- Ghost Chase Mode is active - decrement LifeTimer
 947  8417 3D           	dec a						; decrement Timer value							;8417	3d
 948  8418 32 2C 80     	ld (CMODE_ON_TIMER),a		; store new value								;8418	32 2c 80
 949  841B              ; -- flash screen colors when Chase Mode is ending
 950  841B FE 0C        	cp 12						; is 12 "ticks" left? 							;841b	fe 0c
 951  841D CA 3B 84     	jp z,SET_GFX_MODE_COLORS_0	; yes - change Colors to Green Palette			;841d	ca 3b 84
 952  8420 FE 0B        	cp 11						; is 11 "ticks" left? 							;8420	fe 0b
 953  8422 CA 44 84     	jp z,SET_GFX_MODE_COLORS_1	; yes - change Colors to Buff Palette			;8422	ca 44 84
 954  8425 FE 08        	cp 8						; is 8 "ticks" left? 							;8425	fe 08
 955  8427 CA 3B 84     	jp z,SET_GFX_MODE_COLORS_0	; yes - change Colors to Green Palette			;8427	ca 3b 84
 956  842A FE 07        	cp 7						; is 7 "ticks" left? 							;842a	fe 07
 957  842C CA 44 84     	jp z,SET_GFX_MODE_COLORS_1	; yes - change Colors to Buff Palette			;842c	ca 44 84
 958  842F FE 04        	cp 4						; is 4 "ticks" left? 							;842f	fe 04
 959  8431 CA 3B 84     	jp z,SET_GFX_MODE_COLORS_0	; yes - change Colors to Green Palette			;8431	ca 3b 84
 960  8434 FE 03        	cp 3						; is 3 "ticks" left? 							;8434	fe 03
 961  8436 CA 44 84     	jp z,SET_GFX_MODE_COLORS_1	; yes - change Colors to Buff Palette			;8436	ca 44 84
 962  8439 B7           	or a						; is still active?								;8439	b7
 963  843A C0           	ret nz						; yes ----------- End of Proc -----------------	;843a	c0
 964  843B              ; -- Ghost Chase Mode has ended - revert back Colors to Green Palette
 965  843B
 966  843B              ;***********************************************************************************************
 967  843B              ; Set HiRes graphics Mode (1) and Color Palette to 0 (GREEN/YELLOW/BLUE/RED)
 968  843B              SET_GFX_MODE_COLORS_0:
 969  843B 3E 08        	ld a,VDG_GFX_COLORS_0		; set VDG MODE 1 and Color Palette to 0			;843b	3e 08
 970  843D 32 00 68     	ld (IOLATCH),a				; store to hardware register					;843d	32 00 68
 971  8440 32 6F 80     	ld (IOLATCH_SHADOW),a		; store to shadow register 						;8440	32 6f 80
 972  8443 C9           	ret							; -------------- End of Proc ------------------	;8443	c9
 973  8444
 974  8444              ;***********************************************************************************************
 975  8444              ; Set HiRes graphics Mode (1) and Color Palette to 1 (BUFF/CYAN/MAGENTA/ORANGE)
 976  8444              SET_GFX_MODE_COLORS_1:
 977  8444 3E 18        	ld a,VDG_GFX_COLORS_1		; set VDG MODE 1 and Color Palette to 1			;8444	3e 18
 978  8446 32 00 68     	ld (IOLATCH),a				; store to hardware register					;8446	32 00 68
 979  8449 32 6F 80     	ld (IOLATCH_SHADOW),a		; store to shadow register 						;8449	32 6f 80
 980  844C C9           	ret							; -------------- End of Proc ------------------	;844c	c9
 981  844D
 982  844D
 983  844D              ;***********************************************************************************************
 984  844D              ;
 985  844D              ;   G A M E    L O O P  -  U P D A T E   G H O S T S
 986  844D              ;
 987  844D              ;***********************************************************************************************
 988  844D              GL_UPDATE_GHOSTS:
 989  844D              ; -- decrement Ghosts Update Timer - check if we update in this Game Loop iteration
 990  844D 3A 13 80     	ld a,(GHOSTS_UPD_TIMER)		; a - Ghost Update Timer 						;844d	3a 13 80
 991  8450 3D           	dec a						; decrement value and check if 0				;8450	3d
 992  8451 32 13 80     	ld (GHOSTS_UPD_TIMER),a		; store new value 								;8451	32 13 80
 993  8454 C0           	ret nz						; no - dont update this time					;8454	c0
 994  8455              ; -- reset Timer value to one defined in Level Data - this value evective determine moving speed
 995  8455 3A 07 80     	ld a,(LEVEL_GH_UPD_TIMER)	; initial value for this Level					;8455	3a 07 80
 996  8458 32 13 80     	ld (GHOSTS_UPD_TIMER),a		; store new value								;8458	32 13 80
 997  845B
 998  845B              ;***********************************************************************************************
 999  845B              ; Update/Move Ghosts Blue 1, Blue 2 and Red 1
1000  845B              ; -- Pepeare 2 variants of Sprite - base and shifted 2px - to use by subroutine for Blue Ghosts
1001  845B 21 0A 8F     	ld hl,SPR.GHOST_BLUE		; Sprite Ghost Blue data (8x4)px (2x4) bytes	;845b	21 0a 8f
1002  845E 22 EB 84     	ld (SPR_BASE_VAR),hl		; store as current moving Sprite				;845e	22 eb 84
1003  8461 21 12 8F     	ld hl,SPR.GHOST_BLUE_2R		; Sprite Ghost Blue shifted 2px right			;8461	21 12 8f
1004  8464 22 ED 84     	ld (SPR_2R_VAR),hl			; store as current moving Sprite 2R variant		;8464	22 ed 84
1005  8467              ; -- Update/Move Ghost Blue 1
1006  8467 2A 18 80     	ld hl,(GHOST_B1.VADR)		; hl - VRAM address of Ghost Blue 1				;8467	2a 18 80
1007  846A ED 4B 1A 80  	ld bc,(GHOST_B1.PROPS)		; c - move direction, b - sprite shift flag		;846a	ed 4b 1a 80
1008  846E 3A 1C 80     	ld a,(GHOST_B1.FREEZE)		; a - Ghost Freeze Timer						;846e	3a 1c 80
1009  8471 CD EF 84     	call UPDATE_MOVE_GHOST		; Update Move Ghost								;8471	cd ef 84
1010  8474 32 1C 80     	ld (GHOST_B1.FREEZE),a		; store new Freeze Timer value					;8474	32 1c 80
1011  8477 22 18 80     	ld (GHOST_B1.VADR),hl		; new VRAM address of Ghost Blue 1				;8477	22 18 80
1012  847A ED 43 1A 80  	ld (GHOST_B1.PROPS),bc		; store new Move Direction and Sprite Shift Flag;847a	ed 43 1a 80
1013  847E              ; -- Update/Move Ghost Blue 2
1014  847E 2A 1D 80     	ld hl,(GHOST_B2.VADR)		; hl - VRAM address of Ghost Blue 2				;847e	2a 1d 80
1015  8481 ED 4B 1F 80  	ld bc,(GHOST_B2.PROPS)		; c - move direction, b - sprite shift flag		;8481	ed 4b 1f 80
1016  8485 3A 21 80     	ld a,(GHOST_B2.FREEZE)		; a - Ghost Freeze Timer						;8485	3a 21 80
1017  8488 CD EF 84     	call UPDATE_MOVE_GHOST		; Update Move Ghost								;8488	cd ef 84
1018  848B 32 21 80     	ld (GHOST_B2.FREEZE),a		; store new Freeze Timer value					;848b	32 21 80
1019  848E 22 1D 80     	ld (GHOST_B2.VADR),hl		; new VRAM address of Ghost Blue 2				;848e	22 1d 80
1020  8491 ED 43 1F 80  	ld (GHOST_B2.PROPS),bc		; store new Move Direction and Sprite Shift Flag;8491	ed 43 1f 80
1021  8495
1022  8495              ; -- Pepeare 2 variants of Ghost Red Sprite - base and shifted 2px - to use by subroutine
1023  8495 21 1A 8F     	ld hl,SPR.GHOST_RED			; Sprite Ghost Red data (8x4)px (2x4) bytes		;8495	21 1a 8f
1024  8498 22 EB 84     	ld (SPR_BASE_VAR),hl		; store as current moving Sprite				;8498	22 eb 84
1025  849B 21 22 8F     	ld hl,SPR.GHOST_RED_2R		; Sprite Ghost Red  shifted 2px right			;849b	21 22 8f
1026  849E 22 ED 84     	ld (SPR_2R_VAR),hl			; store as current moving Sprite 2R variant		;849e	22 ed 84
1027  84A1              ; -- Update/Move Ghost Red 1
1028  84A1 2A 22 80     	ld hl,(GHOST_R1.VADR)		; hl - VRAM address of Ghost Red 1				;84a1	2a 22 80
1029  84A4 ED 4B 24 80  	ld bc,(GHOST_R1.PROPS)		; c - move direction, b - sprite shift flag		;84a4	ed 4b 24 80
1030  84A8 3A 26 80     	ld a,(GHOST_R1.FREEZE)		; a - Ghost Freeze Timer					;84a8	3a 26 80
1031  84AB CD EF 84     	call UPDATE_MOVE_GHOST		; Update Move Ghost								;84ab	cd ef 84
1032  84AE 32 26 80     	ld (GHOST_R1.FREEZE),a		; store new Freeze Timer value					;84ae	32 26 80
1033  84B1 22 22 80     	ld (GHOST_R1.VADR),hl		; new VRAM address of Ghost Red 1				;84b1	22 22 80
1034  84B4 ED 43 24 80  	ld (GHOST_R1.PROPS),bc		; store new Move Direction and Sprite Shift Flag;84b4	ed 43 24 80
1035  84B8 C9           	ret							; -------------- End of Proc ------------------	;84b8	c9
1036  84B9
1037  84B9              ;***********************************************************************************************
1038  84B9              ;
1039  84B9              ;   G A M E    L O O P  -  U P D A T E   G H O S T   R E D   A
1040  84B9              ;
1041  84B9              ;***********************************************************************************************
1042  84B9              GL_UPDATE_GHOSTA:
1043  84B9              ; -- decrement Ghost Red A Update Timer - check if we update in this Game Loop iteration
1044  84B9 3A 17 80     	ld a,(GHOSTA_UPD_TIMER)		; a - Ghost Red 2 (A) Update timer value		;84b9	3a 17 80
1045  84BC 3D           	dec a						; decrement value and check if 0				;84bc	3d
1046  84BD 32 17 80     	ld (GHOSTA_UPD_TIMER),a		; store new value 								;84bd	32 17 80
1047  84C0 C0           	ret nz						; timer <> 0 - dont update this time			;84c0	c0
1048  84C1              ; -- reset Timer value to one defined in Level Data - this value evective determine moving speed
1049  84C1 3A 08 80     	ld a,(LEVEL_GA_UPD_TIMER)	; initial value for this Level					;84c1	3a 08 80
1050  84C4 32 17 80     	ld (GHOSTA_UPD_TIMER),a		; store new value								;84c4	32 17 80
1051  84C7
1052  84C7              ;***********************************************************************************************
1053  84C7              ; Update/Move Ghost Red A
1054  84C7              ; -- Pepeare 2 variants of Sprite - base and shifted 2px - to use by subroutine
1055  84C7 21 2A 8F     	ld hl,SPR.GHOST_REDA		; Sprite Ghost Red A variant (8x4)px (2x4)bytes	;84c7	21 2a 8f
1056  84CA 22 EB 84     	ld (SPR_BASE_VAR),hl		; store as current moving Sprite				;84ca	22 eb 84
1057  84CD 21 32 8F     	ld hl,SPR.GHOST_REDA_2R		; Sprite Ghost Red A shifted 2px right			;84cd	21 32 8f
1058  84D0 22 ED 84     	ld (SPR_2R_VAR),hl			; store as current moving Sprite 2R variant		;84d0	22 ed 84
1059  84D3              ; -- Update/Move Ghost Red 1
1060  84D3 2A 27 80     	ld hl,(GHOST_R2.VADR)		; hl - VRAM address of Ghost Red 2				;84d3	2a 27 80
1061  84D6 ED 4B 29 80  	ld bc,(GHOST_R2.PROPS)		; c - move direction, b - sprite shift flag		;84d6	ed 4b 29 80
1062  84DA 3A 2B 80     	ld a,(GHOST_R2.FREEZE)		; a - Ghost Freeze Timer						;84da	3a 2b 80
1063  84DD CD EF 84     	call UPDATE_MOVE_GHOST		; Update Move Ghost								;84dd	cd ef 84
1064  84E0 32 2B 80     	ld (GHOST_R2.FREEZE),a		; store new Freeze Timer value					;84e0	32 2b 80
1065  84E3 22 27 80     	ld (GHOST_R2.VADR),hl		; store new VRAM address of Ghost Red 2			;84e3	22 27 80
1066  84E6 ED 43 29 80  	ld (GHOST_R2.PROPS),bc		; store new Move Direction and Sprite Shift Flag;84e6	ed 43 29 80
1067  84EA C9           	ret							; -------------- End of Proc ------------------	;84ea	c9
1068  84EB
1069  84EB              ;***********************************************************************************************
1070  84EB              ; Helper variables - used to transfer data to common Ghost update routine
1071  84EB 00 00        SPR_BASE_VAR	defw	$0000	; current processed Ghost Sprite - used as param	;84eb	00 00
1072  84ED 00 00        SPR_2R_VAR		defw	$0000	; current processed Ghost Sprite (shifted variant)	;84ed	00 00
1073  84EF
1074  84EF              ;***********************************************************************************************
1075  84EF              ; Update/Move Ghost common routine
1076  84EF              ; IN: hl - VRAM address of Ghost
1077  84EF              ;     b - Sprite Shifted Flag
1078  84EF              ;     c - Ghost Move Direction
1079  84EF              ;     a - Ghost Freeze TImer
1080  84EF              ;     SPR_BASE_VAR - Ghost Sprite data - regular variant
1081  84EF              ;     SPR_2R_VAR - Ghost Sprite data - shifted 2px variant
1082  84EF              UPDATE_MOVE_GHOST
1083  84EF              ; -- check Freeze Timer and if not 0 don't move Ghost - just decrement timer
1084  84EF B7           	or a						; check if Ghost is freezed (Freeze Timer > 0)	;84ef	b7
1085  84F0 C2 BF 86     	jp nz,DEC_FREEZE_TIMER		; yes - just decrement Freeze Timer				;84f0	c2 bf 86
1086  84F3
1087  84F3              ; -- Ghost isn't freezed anymore - first test collision with Player
1088  84F3 C5           	push bc						; save Shift Flag (b) and Move Direction (c)	;84f3	c5
1089  84F4 E5           	push hl						; save hl - current VRAM address				;84f4	e5
1090  84F5 CD E9 89     	call CMAP_GET_BYTE			; de - address in Colision Map					;84f5	cd e9 89
1091  84F8 CD 53 86     	call TEST_KILL_PLAYER		; check collision with Player 					;84f8	cd 53 86
1092  84FB
1093  84FB              ; -- clear screen area where Ghost was
1094  84FB 11 F1 8E     	ld de,SPR.EMPTY				; Sprite Empty (8x4)px (2x4) bytes				;84fb	11 f1 8e
1095  84FE EB           	ex de,hl					; hl - sprite to draw, de - screen address		;84fe	eb
1096  84FF 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;84ff	01 02 00
1097  8502 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;8502	3e 04
1098  8504 CD 75 89     	call DRAW_SPRITE			; draw sprite on screen	(clear)					;8504	cd 75 89
1099  8507
1100  8507              ; -- clear Ghost Bits in Collision Map
1101  8507 E1           	pop hl						; hl - VRAM address								;8507	e1
1102  8508 CD E9 89     	call CMAP_GET_BYTE			; de - address in Colision Map					;8508	cd e9 89
1103  850B 06 EF        	ld b,%11101111				; bitmask to clear bit 4 (Ghost)				;850b	06 ef
1104  850D CD 78 86     	call CMAP_CLEAR_2X4			; clear Ghost Bit (4) in Collision Map			;850d	cd 78 86
1105  8510
1106  8510              ; -- check if we use Sprite Shiftet 2px right - if so continue move in same direction
1107  8510 C1           	pop bc						; restore Shift Flag (b) and Move Direction (c)	;8510	c1
1108  8511 78           	ld a,b						; a - Sprite Shift Flag							;8511	78
1109  8512 B7           	or a						; check if Sprite is Shifted					;8512	b7
1110  8513 C2 A6 86     	jp nz,CONT_GHOST_MOVE		; yes - continue moving (LEFT or RIGHT)			;8513	c2 a6 86
1111  8516
1112  8516              ; -- sprite is NOT shifted - can move any direction now
1113  8516              ; check current move direction and clear allow bit at opposite direction to avoid moving back and forth
1114  8516 79           	ld a,c						; a - current move direction					;8516	79
1115  8517 B7           	or a						; is moving UP?									;8517	b7
1116  8518 CA 28 85     	jp z,SPR_MOVE_NO_DOWN		; yes - eliminate DOWN Direction from CMap byte	;8518	ca 28 85
1117  851B FE 01        	cp 1						; is moving RIGHT?								;851b	fe 01
1118  851D CA 38 85     	jp z,SPR_MOVE_NO_LEFT		; yes - eliminate LEFT Direction from CMap byte	;851d	ca 38 85
1119  8520 FE 02        	cp 2						; is moving DOWN?								;8520	fe 02
1120  8522 CA 30 85     	jp z,SPR_MOVE_NO_UP			; yes - eliminate UP Direction from CMap byte	;8522	ca 30 85
1121  8525 C3 40 85     	jp SPR_MOVE_NO_RIGHT		; moving LEFT - eliminate RIGHT Direction		;8525	c3 40 85
1122  8528
1123  8528              ; -- eliminate DOWN direction from possible moves and determine next move
1124  8528              SPR_MOVE_NO_DOWN
1125  8528 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8528	cd e9 89
1126  852B E6 0B        	and %00001011				; clear Down Direction Bit						;852b	e6 0b
1127  852D C3 45 85     	jp FIND_GHOST_MOVE			; move Ghost in 1 of 3 direction				;852d	c3 45 85
1128  8530
1129  8530              ; -- eliminate UP direction from possible moves and determine next move
1130  8530              SPR_MOVE_NO_UP:
1131  8530 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8530	cd e9 89
1132  8533 E6 0E        	and %00001110				; clear Up Direction Bit						;8533	e6 0e
1133  8535 C3 45 85     	jp FIND_GHOST_MOVE			; move Ghost in 1 of 3 direction				;8535	c3 45 85
1134  8538
1135  8538              ; -- eliminate LEFT direction from possible moves and determine next move
1136  8538              SPR_MOVE_NO_LEFT:
1137  8538 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8538	cd e9 89
1138  853B E6 07        	and %00000111				; clear Left Direction Bit						;853b	e6 07
1139  853D C3 45 85     	jp FIND_GHOST_MOVE			; move Ghost in 1 of 3 direction				;853d	c3 45 85
1140  8540
1141  8540              ; -- eliminate RIGHT direction from possible moves and determine next move
1142  8540              SPR_MOVE_NO_RIGHT:
1143  8540 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8540	cd e9 89
1144  8543 E6 0D        	and %00001101				; clear Right Direction Bit						;8543	e6 0d
1145  8545
1146  8545              FIND_GHOST_MOVE
1147  8545 5F           	ld e,a						; e - byte from CMap with Bit cleared			;8545	5f
1148  8546
1149  8546              ; -- if Chase Mode is Active Ghost will run away (random direction),
1150  8546 3A 2C 80     	ld a,(CMODE_ON_TIMER)		; a - Ghost Chase Mode Timer					;8546	3a 2c 80
1151  8549 B7           	or a						; is Chase Mode active?							;8549	b7
1152  854A C2 C1 85     	jp nz,TRY_MOV_RANDOM		; yes - move Ghost to random direction	(run)	;854a	c2 c1 85
1153  854D
1154  854D              ; -- Chase Mode is inactive - Ghost will try to chase Player - try to move to direction where Player is
1155  854D ED 5F        	ld a,r						; a - random byte								;854d	ed 5f
1156  854F CB 47        	bit 0,a						; random preference - Horizontal or Vertical	;854f	cb 47
1157  8551 CA 9B 85     	jp z,TRY_CHASE_PLAYER_V		; yes - chase Player Up or Down					;8551	ca 9b 85
1158  8554 C3 66 85     	jp TRY_CHASE_PLAYER_H		; no - chase Player Left or Right				;8554	c3 66 85
1159  8557
1160  8557              ;***********************************************************************************************
1161  8557              ; Compare X position of Ghost and Player
1162  8557              ; IN: hl - Ghost VRAM address
1163  8557              CMP_PLAYER_X_POS
1164  8557 C5           	push bc						; save bc										;8557	c5
1165  8558              ; -- calculate Player X position (in screen bytes)
1166  8558 ED 4B 0D 80  	ld bc,(PLAYER_VADR)			; bc - player screen coord (VRAM address)		;8558	ed 4b 0d 80
1167  855C 79           	ld a,c						; a - low byte of address						;855c	79
1168  855D E6 1F        	and $1f						; range 0..31 -  - Palyer X position			;855d	e6 1f
1169  855F 4F           	ld c,a						; store in c to compare later					;855f	4f
1170  8560              ; -- calculate Ghost X position (in screen bytes)
1171  8560 7D           	ld a,l						; a - low byte of Ghost address					;8560	7d
1172  8561 E6 1F        	and $1f						; range 0..31 -  - Ghost X position				;8561	e6 1f
1173  8563              ; -- compare values
1174  8563 B9           	cp c						; compare with Player X position				;8563	b9
1175  8564              ; -- - Sign Flag is set if Player is on right side of Ghost (Ghost X pos < Player X pos)
1176  8564 C1           	pop bc						; restore saved bc								;8564	c1
1177  8565 C9           	ret							; --------- End of Proc (Flags) --------		;8565	c9
1178  8566
1179  8566              ;***********************************************************************************************
1180  8566              ; Try move Ghost to Left or Right depending on which side is Player
1181  8566              ; If none of above is possible, try chase Player Up or Down
1182  8566              ; If it is still impossible, try random move
1183  8566              TRY_CHASE_PLAYER_H
1184  8566 CD 57 85     	call CMP_PLAYER_X_POS		; is Player somewhere on left from Ghost 		;8566	cd 57 85
1185  8569 F2 74 85     	jp p,TRY_CHASE_PLAYER_LEFT	; yes - try move left							;8569	f2 74 85
1186  856C              ; -- player is somewhere on right from Ghost - try move right
1187  856C CB 4B        	bit 1,e						; is Wall on RIGHT?								;856c	cb 4b
1188  856E C2 23 86     	jp nz,SPR_MOVE_RIGHT_SO		; no - move sprite Right (shift sprite only)	;856e	c2 23 86
1189  8571              ; -- can't chase Player Right - try Up or Down
1190  8571 C3 79 85     	jp CHASE_PLAYER_UP_DOWN		; yes - so try move Up or Down					;8571	c3 79 85
1191  8574
1192  8574              TRY_CHASE_PLAYER_LEFT
1193  8574 CB 5B        	bit 3,e						; is Wall on LEFT?								;8574	cb 5b
1194  8576 C2 2E 86     	jp nz,SPR_MOVE_LEFT			; no - move sprite Left (VRAM will change)		;8576	c2 2e 86
1195  8579
1196  8579              ; -- can't chase Player Left or Right - try Up or Down
1197  8579              ;***********************************************************************************************
1198  8579              ; Try move Ghost Up or Down depending on if Player is above or below
1199  8579              CHASE_PLAYER_UP_DOWN
1200  8579 CD 8F 85     	call CMP_PLAYER_Y_POS		; is Player somewhere above Ghost 				;8579	cd 8f 85
1201  857C F2 87 85     	jp p,CHASE_PLAYER_UP		; yes - try move up								;857c	f2 87 85
1202  857F              ; -- player is somewhere below Ghost - try move down
1203  857F CB 53        	bit 2,e						; is Wall DOWN below							;857f	cb 53
1204  8581 C2 16 86     	jp nz,SPR_MOVE_DOWN			; no - move sprite Down (VRAM will change)		;8581	c2 16 86
1205  8584              ; -- can't chase Player Down - try random move in any direction
1206  8584 C3 C1 85     	jp TRY_MOV_RANDOM			; yes - move Ghost in random Direction			;8584	c3 c1 85
1207  8587
1208  8587              CHASE_PLAYER_UP
1209  8587 CB 43        	bit 0,e						; is Wall Up above?								;8587	cb 43
1210  8589 C2 07 86     	jp nz,SPR_MOVE_UP			; no - move sprite Up (VRAM will change)		;8589	c2 07 86
1211  858C              ; -- can't chase Player Up - try random move in any direction
1212  858C C3 C1 85     	jp TRY_MOV_RANDOM			; yes - move Ghost in random Direction			;858c	c3 c1 85
1213  858F
1214  858F
1215  858F              ;***********************************************************************************************
1216  858F              ; Compare Y position of Ghost and Player
1217  858F              ; IN: hl - Ghost VRAM address
1218  858F              CMP_PLAYER_Y_POS
1219  858F E5           	push hl						; save hl 										;858f	e5
1220  8590 C5           	push bc						; save bc										;8590	c5
1221  8591              ; -- calculate difference beetween Player and Ghost positions on screen (in bytes)
1222  8591 ED 4B 0D 80  	ld bc,(PLAYER_VADR)			; bc - Player screen coord (VRAM address)		;8591	ed 4b 0d 80
1223  8595 B7           	or a						; clear Carry flag								;8595	b7
1224  8596 ED 42        	sbc hl,bc					; compare Ghost adr with Player adr				;8596	ed 42
1225  8598              ; -- Sign Flag is set if Player is below Ghost (Player VRAM sddr > Ghost VRAM addr)
1226  8598 C1           	pop bc						; restore bc									;8598	c1
1227  8599 E1           	pop hl						; restore hl									;8599	e1
1228  859A C9           	ret							; --------------- End of Proc (Flags) ---------	;859a	c9
1229  859B
1230  859B              ;***********************************************************************************************
1231  859B              ; Try move Ghost Up or Down depending on if Player is above or below
1232  859B              ; If none of above is possible, try chase Player Left or Right
1233  859B              ; If it is still impossible, try random move
1234  859B              TRY_CHASE_PLAYER_V
1235  859B CD 8F 85     	call CMP_PLAYER_Y_POS		; is Player somewhere above Ghost 				;859b	cd 8f 85
1236  859E F2 A9 85     	jp p,TRY_CHASE_PLAYER_UP	; yes - try move up								;859e	f2 a9 85
1237  85A1              ; -- player is somewhere below Ghost - try move down
1238  85A1 CB 53        	bit 2,e						; is Wall Down below							;85a1	cb 53
1239  85A3 C2 16 86     	jp nz,SPR_MOVE_DOWN			; no - move sprite Down (VRAM will change)		;85a3	c2 16 86
1240  85A6              ; -- can't chase player Down
1241  85A6 C3 AE 85     	jp CHASE_PLAYER_LEFT_RIGHT	; try to chase Player Left or Right				;85a6	c3 ae 85
1242  85A9
1243  85A9              TRY_CHASE_PLAYER_UP
1244  85A9 CB 43        	bit 0,e						; is Wall Up above								;85a9	cb 43
1245  85AB C2 07 86     	jp nz,SPR_MOVE_UP			; no - move sprite Up (VRAM will change)		;85ab	c2 07 86
1246  85AE
1247  85AE              ; -- can't chase Player Up or Down - try Left or Right
1248  85AE              ;***********************************************************************************************
1249  85AE              ; Try move Ghost Left or Right depending on which side is Player
1250  85AE              CHASE_PLAYER_LEFT_RIGHT:
1251  85AE CD 57 85     	call CMP_PLAYER_X_POS		; is Player somewhere on left from Ghost 		;85ae	cd 57 85
1252  85B1 F2 BC 85     	jp p,CHASE_PLAYER_LEFT		; yes - try move left							;85b1	f2 bc 85
1253  85B4              ; -- player is somewhere on right from Ghost - try move right
1254  85B4 CB 4B        	bit 1,e						; is Wall on Right side							;85b4	cb 4b
1255  85B6 C2 23 86     	jp nz,SPR_MOVE_RIGHT_SO		; no - move sprite Right (shift sprite only)	;85b6	c2 23 86
1256  85B9              ; -- can't chase Player - try random move
1257  85B9 C3 C1 85     	jp TRY_MOV_RANDOM			; try random move in any direction				;85b9	c3 c1 85
1258  85BC
1259  85BC              ; -- player is somewhere on Left from Ghost - try move Left
1260  85BC              CHASE_PLAYER_LEFT:
1261  85BC CB 5B        	bit 3,e						; is Wall on Left side							;85bc	cb 5b
1262  85BE C2 2E 86     	jp nz,SPR_MOVE_LEFT			; no - move sprite Left (VRAM will change)		;85be	c2 2e 86
1263  85C1              ; -- can't chase Player - try random move
1264  85C1
1265  85C1              ;***********************************************************************************************
1266  85C1              ; Move Ghost in Random direction
1267  85C1              TRY_MOV_RANDOM:
1268  85C1 ED 5F        	ld a,r						; a - random value								;85c1	ed 5f
1269  85C3 CB 47        	bit 0,a						; bit 0 - random pref Vertical or Horizontal	;85c3	cb 47
1270  85C5 CA E6 85     	jp z,TRY_MOV_RND_VERT		; try random move Up or Down					;85c5	ca e6 85
1271  85C8
1272  85C8              ;***********************************************************************************************
1273  85C8              ; Move Ghost Horizontal in Random direction (Left or Right)
1274  85C8              TRY_MOV_RND_HORIZ
1275  85C8 ED 5F        	ld a,r						; a - random value								;85c8	ed 5f
1276  85CA CB 47        	bit 0,a						; check bit 0 - random preference Left or Right ;85ca	cb 47
1277  85CC CA DC 85     	jp z,TRY_MOVE_LEFT_OR_RIGHT	; bit is set - try move Left then Right			;85cc	ca dc 85
1278  85CF              ; -- bit is not set - try move Right and then Left
1279  85CF CB 4B        	bit 1,e						; is Wall on Right side							;85cf	cb 4b
1280  85D1 C2 23 86     	jp nz,SPR_MOVE_RIGHT_SO		; no - move sprite Right (shift sprite only)	;85d1	c2 23 86
1281  85D4 CB 5B        	bit 3,e						; is Wall on Left side							;85d4	cb 5b
1282  85D6 C2 2E 86     	jp nz,SPR_MOVE_LEFT			; no - move sprite Left (VRAM will change)		;85d6	c2 2e 86
1283  85D9              ; -- can't move Right nor Left
1284  85D9 C3 E6 85     	jp TRY_MOV_RND_VERT			; try random move Up or Down					;85d9	c3 e6 85
1285  85DC
1286  85DC              TRY_MOVE_LEFT_OR_RIGHT:
1287  85DC CB 5B        	bit 3,e						; is Wall on Left side							;85dc	cb 5b
1288  85DE C2 2E 86     	jp nz,SPR_MOVE_LEFT			; no - move sprite Left (VRAM will change)		;85de	c2 2e 86
1289  85E1              ; -- can't move Left - try move Right
1290  85E1 CB 4B        	bit 1,e						; is Wall on Right side							;85e1	cb 4b
1291  85E3 C2 23 86     	jp nz,SPR_MOVE_RIGHT_SO		; no - move sprite Right (shift sprite only)	;85e3	c2 23 86
1292  85E6              ; -- can't move Left nor Right - try random Up or Down
1293  85E6
1294  85E6              ;***********************************************************************************************
1295  85E6              ; Move Ghost Vertical in Random direction (Up or Down)
1296  85E6              TRY_MOV_RND_VERT:
1297  85E6 ED 5F        	ld a,r						; a - random value								;85e6	ed 5f
1298  85E8 CB 47        	bit 0,a						; check bit 0 - random Up or Down				;85e8	cb 47
1299  85EA CA FA 85     	jp z,TRY_MOV_UP_OR_DOWN		; bit is set - try Up then Down					;85ea	ca fa 85
1300  85ED              ; -- bit is not set - try Down then Up
1301  85ED CB 53        	bit 2,e						; is Wall Down below							;85ed	cb 53
1302  85EF C2 16 86     	jp nz,SPR_MOVE_DOWN			; no - move sprite Down (VRAM will change)		;85ef	c2 16 86
1303  85F2              ; -- can't move Down - try move Up
1304  85F2 CB 43        	bit 0,e						; is Wall Up above								;85f2	cb 43
1305  85F4 C2 07 86     	jp nz,SPR_MOVE_UP			; no - move sprite Up (VRAM will change)		;85f4	c2 07 86
1306  85F7              ; -- cant move Down nor Up
1307  85F7 C3 C8 85     	jp TRY_MOV_RND_HORIZ		; try random move Left or Right					;85f7	c3 c8 85
1308  85FA
1309  85FA              TRY_MOV_UP_OR_DOWN
1310  85FA CB 43        	bit 0,e						; is Wall Up above								;85fa	cb 43
1311  85FC C2 07 86     	jp nz,SPR_MOVE_UP			; no - move sprite Up (VRAM will change)		;85fc	c2 07 86
1312  85FF              ; -- can't move up - try move down
1313  85FF CB 53        	bit 2,e						; is Wall Down below							;85ff	cb 53
1314  8601 C2 16 86     	jp nz,SPR_MOVE_DOWN			; no - move sprite Down (VRAM will change)		;8601	c2 16 86
1315  8604              ; -- cant move Up nor Down
1316  8604 C3 C8 85     	jp TRY_MOV_RND_HORIZ		; try random move Left or Right					;8604	c3 c8 85
1317  8607
1318  8607              SPR_MOVE_UP
1319  8607 0E 00        	ld c,0						; set Move Direction Up							;8607	0e 00
1320  8609 11 20 00     	ld de,32					; 32 bytes per screen line						;8609	11 20 00
1321  860C B7           	or a						; clear Carry flag								;860c	b7
1322  860D ED 52        	sbc hl,de					; new VRAM address (1 line above)				;860d	ed 52
1323  860F ED 5B EB 84  	ld de,(SPR_BASE_VAR)		; not shifted variant of Ghost Sprite			;860f	ed 5b eb 84
1324  8613 C3 37 86     	jp DRAW_GHOST				; draw Ghost Sprite								;8613	c3 37 86
1325  8616
1326  8616              SPR_MOVE_DOWN
1327  8616 0E 02        	ld c,2						; set Move Direction Down						;8616	0e 02
1328  8618 11 20 00     	ld de,32					; 32 bytes per screen line						;8618	11 20 00
1329  861B 19           	add hl,de					; new VRAM address (1 line below)				;861b	19
1330  861C ED 5B EB 84  	ld de,(SPR_BASE_VAR)		; not shifted variant of Ghost Sprite			;861c	ed 5b eb 84
1331  8620 C3 37 86     	jp DRAW_GHOST				; draw Ghost Sprite								;8620	c3 37 86
1332  8623
1333  8623              SPR_MOVE_RIGHT_SO
1334  8623 0E 01        	ld c,1						; set Move Direction Right						;8623	0e 01
1335  8625 06 01        	ld b,1						; set Sprite Shifted Flag						;8625	06 01
1336  8627 ED 5B ED 84  	ld de,(SPR_2R_VAR)			; 2px shifted variant of Ghost Sprite			;8627	ed 5b ed 84
1337  862B C3 37 86     	jp DRAW_GHOST				; draw Ghost Sprite								;862b	c3 37 86
1338  862E
1339  862E              SPR_MOVE_LEFT
1340  862E 0E 03        	ld c,3						; set Move Direction Left						;862e	0e 03
1341  8630 2B           	dec hl						; new VRAM addres (to left)						;8630	2b
1342  8631 06 01        	ld b,1						; set Sprite Shifted Flag						;8631	06 01
1343  8633 ED 5B ED 84  	ld de,(SPR_2R_VAR)			; 2px shifted variant of Ghost Sprite			;8633	ed 5b ed 84
1344  8637
1345  8637              ;***********************************************************************************************
1346  8637              ; Draw Ghost Sprite and update Collision Map
1347  8637              ; IN: hl - destination VRAM address
1348  8637              ;     de - address of Ghost sprite to draw
1349  8637              ; OUT: hl - Ghost VRAM address (position on screen)
1350  8637              ;      b - Sprite Shifted Flag (1 if shifted 2px right)
1351  8637              ;      c - Ghost Move Direction
1352  8637              ;      a - Ghost Freeze Timer
1353  8637              DRAW_GHOST:
1354  8637 C5           	push bc						; save bc										;8637	c5
1355  8638              ; -- draw Ghost Sprite on Screen
1356  8638 E5           	push hl						; save hl - VRAM address						;8638	e5
1357  8639 EB           	ex de,hl					; de - VRAM target address, hl - sprite source	;8639	eb
1358  863A 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;863a	01 02 00
1359  863D 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;863d	3e 04
1360  863F CD 75 89     	call DRAW_SPRITE			; draw sprite on screen							;863f	cd 75 89
1361  8642 E1           	pop hl						; restore hl - VRAM address						;8642	e1
1362  8643              ; -- mark Ghost position in Collision Map
1363  8643 E5           	push hl						; save hl										;8643	e5
1364  8644 CD E9 89     	call CMAP_GET_BYTE			; de - address in Colision Map					;8644	cd e9 89
1365  8647 06 10        	ld b,%00010000				; Ghost Bit (4) to set in Collision Map			;8647	06 10
1366  8649 CD 8F 86     	call CMAP_SET_2X4			; set Ghost Bit (6) in CMap (8x4)px (2x4)bytes 	;8649	cd 8f 86
1367  864C              ; -- test Collision with Player
1368  864C CD 53 86     	call TEST_KILL_PLAYER		; check collision with Player 					;864c	cd 53 86
1369  864F E1           	pop hl						; restore hl - VRAM address						;864f	e1
1370  8650 C1           	pop bc						; restore bc - direction and shift flag			;8650	c1
1371  8651 AF           	xor a						; a - turn off Ghost Freeze Timer				;8651	af
1372  8652 C9           	ret							; ---------- End of Proc -------------------	;8652	c9
1373  8653
1374  8653
1375  8653              TEST_KILL_PLAYER:
1376  8653              ; -- if Chase Mode is active Ghost can't kill Player
1377  8653 3A 2C 80     	ld a,(CMODE_ON_TIMER)		; a - Ghost Chase Mode Timer					;8653	3a 2c 80
1378  8656 B7           	or a						; is Chase Mode active?							;8656	b7
1379  8657 C0           	ret nz						; yes ---------- End of Proc ------------------	;8657	c0
1380  8658
1381  8658              ; -- Chase Mode is inactive - chceck collision with Player
1382  8658 E5           	push hl						; save hl - Ghost VRAM address					;8658	e5
1383  8659 D5           	push de						; save de - address in Collision Map			;8659	d5
1384  865A EB           	ex de,hl					; hl - address in Collision Map					;865a	eb
1385  865B 11 1F 00     	ld de,31					; 31 bytes per line (32-1 handled below)		;865b	11 1f 00
1386  865E CB 6E        	bit 5,(hl)					; check if Player Bit (5) is set in CMap		;865e	cb 6e
1387  8660 23           	inc hl						; point to next byte							;8660	23
1388  8661 CA 69 86     	jp z,.NEXT_LINE				; no - check next line							;8661	ca 69 86
1389  8664              ; -- bit is set - there is Player (left side)
1390  8664 CB 6E        	bit 5,(hl)					; check if Player Bit (5) is set in CMap		;8664	cb 6e
1391  8666 C2 DC 86     	jp nz,KILL_PLAYER			; yes - both are set - Kill Player				;8666	c2 dc 86
1392  8669              .NEXT_LINE:
1393  8669 19           	add hl,de					; point to next line in Collision Map			;8669	19
1394  866A CB 6E        	bit 5,(hl)					; check if Player Bit (5) is set in CMap		;866a	cb 6e
1395  866C CA 75 86     	jp z,.EXIT					; no - there is no collision					;866c	ca 75 86
1396  866F              ; -- bit is set - there is Player (left side)
1397  866F 23           	inc hl						; point to next byte							;866f	23
1398  8670 CB 6E        	bit 5,(hl)					; check if Player Bit (5) is set in CMap		;8670	cb 6e
1399  8672 C2 DC 86     	jp nz,KILL_PLAYER			; yes - Kill Player								;8672	c2 dc 86
1400  8675              .EXIT:
1401  8675 D1           	pop de						; restore de - address in Collision Map			;8675	d1
1402  8676 E1           	pop hl						; restore hl - Ghost VRAM address				;8676	e1
1403  8677 C9           	ret							; ---------- End of Proc ----------------------	;8677	c9
1404  8678
1405  8678              ;***********************************************************************************************
1406  8678              ; Clear bit(s) of specified area (8x4px) bytes in Collision Map
1407  8678              ; IN de - adress in Collision Map
1408  8678              ;     b - mask to clear bits
1409  8678              CMAP_CLEAR_2X4
1410  8678 E5           	push hl						; save hl										;8678	e5
1411  8679 D5           	push de						; save de										;8679	d5
1412  867A EB           	ex de,hl					; hl - addres in Buffer							;867a	eb
1413  867B 11 1F 00     	ld de,31					; 31 bytes per screen line						;867b	11 1f 00
1414  867E 0E 04        	ld c,4						; 4 lines to draw								;867e	0e 04
1415  8680              .NEXT_LINE:
1416  8680 78           	ld a,b						; b - mask to clear pixels 						;8680	78
1417  8681 A6           	and (hl)					; a - masked byte from Buffer					;8681	a6
1418  8682 77           	ld (hl),a					; store back to Buffer							;8682	77
1419  8683 23           	inc hl						; next address in Buffer						;8683	23
1420  8684 78           	ld a,b						; b - mask to clear pixels						;8684	78
1421  8685 A6           	and (hl)					; a - masked byte from Buffer					;8685	a6
1422  8686 77           	ld (hl),a					; store back to Buffer							;8686	77
1423  8687 19           	add hl,de					; next address in Buffer - 1 line below			;8687	19
1424  8688 0D           	dec c						; check if all 4 lines processed				;8688	0d
1425  8689 C2 80 86     	jp nz,.NEXT_LINE			; no - process 2 bytes in next line 			;8689	c2 80 86
1426  868C D1           	pop de						; restore de									;868c	d1
1427  868D E1           	pop hl						; restore hl									;868d	e1
1428  868E C9           	ret							; -------------- End of Proc ---------------	;868e	c9
1429  868F
1430  868F
1431  868F              ;***********************************************************************************************
1432  868F              ; Set bit(s) of specified area (8x4px) bytes in Collision Map
1433  868F              ; IN de - adress in Collision Map
1434  868F              ;     b - mask to set bits
1435  868F              CMAP_SET_2X4:
1436  868F E5           	push hl						; save hl										;868f	e5
1437  8690 D5           	push de						; save de										;8690	d5
1438  8691 EB           	ex de,hl					; hl - addres in Buffer							;8691	eb
1439  8692 11 1F 00     	ld de,31					; 31 bytes per screen line						;8692	11 1f 00
1440  8695 0E 04        	ld c,4						; 4 lines to draw								;8695	0e 04
1441  8697              .NEXT_LINE:
1442  8697 78           	ld a,b						; b - mask to set pixels 						;8697	78
1443  8698 B6           	or (hl)						; a - byte from Buffer with bits set			;8698	b6
1444  8699 77           	ld (hl),a					; store back to Buffer							;8699	77
1445  869A 23           	inc hl						; next address in Buffer						;869a	23
1446  869B 78           	ld a,b						; b - mask to set pixels 						;869b	78
1447  869C B6           	or (hl)						; a - byte from Buffer with bits set			;869c	b6
1448  869D 77           	ld (hl),a					; store back to Buffer							;869d	77
1449  869E 19           	add hl,de					; next address in Buffer - 1 line below			;869e	19
1450  869F 0D           	dec c						; check if all 4 lines processed				;869f	0d
1451  86A0 C2 97 86     	jp nz,.NEXT_LINE			; no - process 2 bytes in next line 			;86a0	c2 97 86
1452  86A3 D1           	pop de						; restore de									;86a3	d1
1453  86A4 E1           	pop hl						; restore hl									;86a4	e1
1454  86A5 C9           	ret							; -------------- End of Proc ---------------	;86a5	c9
1455  86A6
1456  86A6              ;***********************************************************************************************
1457  86A6              ; Continue Ghost Move in current direction
1458  86A6              ; When sprite used for Ghost is shifted 2px right then Ghost can move only Left or Right
1459  86A6              ; However game is trying to avoid movig Ghost in dirtection where it comes from, so the only move
1460  86A6              ; possible in such case is the same as was just before.
1461  86A6              CONT_GHOST_MOVE:
1462  86A6 79           	ld a,c						; a - Ghost Move Direction						;86a6	79
1463  86A7 FE 01        	cp 1						; check if Ghost is moving Right				;86a7	fe 01
1464  86A9 CA B5 86     	jp z,GHOST_MOVE_RIGHT		; yes - move sprite Right again					;86a9	ca b5 86
1465  86AC
1466  86AC              ; -- Ghost is moving Left so do this again (without VRAM addres change)
1467  86AC 06 00        	ld b,0						; b - use nonshifted Ghost Sprite 				;86ac	06 00
1468  86AE ED 5B EB 84  	ld de,(SPR_BASE_VAR)		; de - Ghost Sprite in nonshifted variant		;86ae	ed 5b eb 84
1469  86B2 C3 37 86     	jp DRAW_GHOST				; draw Ghost									;86b2	c3 37 86
1470  86B5
1471  86B5              ;***********************************************************************************************
1472  86B5              ; Move selected Ghost Right - next VRAM byte
1473  86B5              ; Sprite was already shifted (b != 0) so change position to next VRAM byte
1474  86B5              ; -- b != 0 && c = 1
1475  86B5              GHOST_MOVE_RIGHT
1476  86B5 23           	inc hl						; next VRAM address								;86b5	23
1477  86B6 06 00        	ld b,0						; clear Sprite Shifted Flag						;86b6	06 00
1478  86B8 ED 5B EB 84  	ld de,(SPR_BASE_VAR)		; use Base Variant Sprite						;86b8	ed 5b eb 84
1479  86BC C3 37 86     	jp DRAW_GHOST				; draw Ghost at new position					;86bc	c3 37 86
1480  86BF
1481  86BF              ;***********************************************************************************************
1482  86BF              ; Decrement Ghost Freeze Timer
1483  86BF              ; Every Ghost has assigned at start some random Freeze time. Until this time elapse
1484  86BF              ; Ghost doesn't move
1485  86BF              DEC_FREEZE_TIMER:
1486  86BF              ; -- check if game is in Chase Mode - don't decrement Ghost Freeze Timer in Chase Mode
1487  86BF 5F           	ld e,a						; e - save a - Ghost's Freeze Timer				;86bf	5f
1488  86C0 3A 2C 80     	ld a,(CMODE_ON_TIMER)		; a - Ghost Chase Mode Timer					;86c0	3a 2c 80
1489  86C3 B7           	or a						; is Chase Mode active?							;86c3	b7
1490  86C4 7B           	ld a,e						; restore a - Ghost's Freeze Timer				;86c4	7b
1491  86C5 C0           	ret nz						; yes ------- End of Proc --------------------	;86c5	c0
1492  86C6
1493  86C6              ; -- Chase Mode is inactive - decrement Freeze Timer and return if not 0
1494  86C6 3D           	dec a						; decrement Freeze Timer - check if 0			;86c6	3d
1495  86C7 C0           	ret nz						; no ---------End of Proc ---------------------	;86c7	c0
1496  86C8
1497  86C8              ; -- Freeze Timer reached 0 - remove Ghost from current screen position
1498  86C8 11 F1 8E     	ld de,SPR.EMPTY				; Sprite Empty (8x4)px (2x4) bytes				;86c8	11 f1 8e
1499  86CB EB           	ex de,hl					; hl - sprite address, de - VRAM address		;86cb	eb
1500  86CC 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;86cc	01 02 00
1501  86CF 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;86cf	3e 04
1502  86D1 CD 75 89     	call DRAW_SPRITE			; draw sprite on screen (clear)					;86d1	cd 75 89
1503  86D4
1504  86D4              ; -- reset Ghost Sprite data to initial values
1505  86D4 01 00 00     	ld bc,$0000					; Move Direction = 0, Sprite Shifted Flag = 0	;86d4	01 00 00
1506  86D7 21 CD 73     	ld hl,VRAM+(30*32)+13		; screen coord (52,30)px (13,30)bytes			;86d7	21 cd 73
1507  86DA AF           	xor a						; new Freeze Time 0 - moving enabled			;86da	af
1508  86DB C9           	ret							; ---------- End of Proc ----------------		;86db	c9
1509  86DC
1510  86DC              ;***********************************************************************************************
1511  86DC              ; Kill Player
1512  86DC              ; Remove Player and all Ghosts from Collision Map and flash screen colors 6 time.
1513  86DC              ; Next decrement Life Counter and if it's not 0 start again this Level otherwise show Game Over screen.
1514  86DC              ; There is no need to remove sprites from screen because in both cases screen will be reinitialized.
1515  86DC              KILL_PLAYER:
1516  86DC              ; -- clear Player position in Collision Map
1517  86DC 2A 0D 80     	ld hl,(PLAYER_VADR)			; VRAM address of Player						;86dc	2a 0d 80
1518  86DF CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;86df	cd e9 89
1519  86E2 06 DF        	ld b,%11011111				; bitmask to clear Player Bit (5)				;86e2	06 df
1520  86E4 CD 78 86     	call CMAP_CLEAR_2X4			; clear Player Bit (5) in Collision Map			;86e4	cd 78 86
1521  86E7              ; -- clear Ghost Blue 1 position in Collision Map
1522  86E7 2A 18 80     	ld hl,(GHOST_B1.VADR)		; VRAM address of Ghost Blue 1					;86e7	2a 18 80
1523  86EA CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;86ea	cd e9 89
1524  86ED 06 EF        	ld b,%11101111				; bitmask to clear Ghost Bit (4)				;86ed	06 ef
1525  86EF CD 78 86     	call CMAP_CLEAR_2X4			; clear Ghost Bit (4) in Collision Map			;86ef	cd 78 86
1526  86F2              ; -- clear Ghost Blue 2 position in Collision Map
1527  86F2 2A 1D 80     	ld hl,(GHOST_B2.VADR)		; VRAM address of Ghost Blue 2					;86f2	2a 1d 80
1528  86F5 CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;86f5	cd e9 89
1529  86F8 06 EF        	ld b,%11101111				; bitmask to clear Ghost Bit (4)				;86f8	06 ef
1530  86FA CD 78 86     	call CMAP_CLEAR_2X4			; clear Ghost Bit (4) in Collision Map			;86fa	cd 78 86
1531  86FD              ; -- clear Ghost Red 1 position in Collision Map
1532  86FD 2A 22 80     	ld hl,(GHOST_R1.VADR)		; VRAM address of Ghost Red 1					;86fd	2a 22 80
1533  8700 CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;8700	cd e9 89
1534  8703 06 EF        	ld b,%11101111				; bitmask to clear Ghost Bit (4)				;8703	06 ef
1535  8705 CD 78 86     	call CMAP_CLEAR_2X4			; clear Ghost Bit (4) in Collision Map			;8705	cd 78 86
1536  8708              ; -- clear Ghost Red 2 position in Collision Map
1537  8708 2A 27 80     	ld hl,(GHOST_R2.VADR)		; VRAM address of Ghost Red 2					;8708	2a 27 80
1538  870B CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;870b	cd e9 89
1539  870E 06 EF        	ld b,%11101111				; bitmask to clear Ghost Bit (4)				;870e	06 ef
1540  8710 CD 78 86     	call CMAP_CLEAR_2X4			; clear Ghost Bit (4) in Collision Map			;8710	cd 78 86
1541  8713              ; -- flash screen 6 times
1542  8713 CD 31 87     	call FLASH_SCREEN			; flash screeen 6 times 						;8713	cd 31 87
1543  8716              ; -- decrement Life Counter
1544  8716 3A 04 80     	ld a,(MEN_LIVES)			; a - current number of Lives/Men				;8716	3a 04 80
1545  8719 3D           	dec a						; decrement value (check if 0)					;8719	3d
1546  871A 32 04 80     	ld (MEN_LIVES),a			; store new value								;871a	32 04 80
1547  871D C2 87 81     	jp nz,GAME_LEVEL_START		; start again the same Level gameplay			;871d	c2 87 81
1548  8720              ; -- no more Lives left - Game Over
1549  8720 CD 91 82     	call GAME_OVER				; show Game Over Screen							;8720	cd 91 82
1550  8723              ; -- wait delay
1551  8723 3E 14        	ld a,20						; a - delay repeat counter 						;8723	3e 14
1552  8725              GO_DELAY:
1553  8725 F5           	push af						; save af										;8725	f5
1554  8726 CD 5D 87     	call DELAY_BC				; wait daly (bc == 0 == 65536)					;8726	cd 5d 87
1555  8729 F1           	pop af						; restore af									;8729	f1
1556  872A 3D           	dec a						; decrement repeat counter						;872a	3d
1557  872B C2 25 87     	jp nz,GO_DELAY				; repeat 20 times								;872b	c2 25 87
1558  872E C3 FA 80     	jp GAME_START				; ------------ Start New Game ------------		;872e	c3 fa 80
1559  8731
1560  8731              ;***********************************************************************************************
1561  8731              ; Flash Screen
1562  8731              FLASH_SCREEN:
1563  8731 3E 06        	ld a,6						; number of screen flashes to display			;8731	3e 06
1564  8733              .INVERT_PIXELS:
1565  8733 F5           	push af						; save af - flash counter						;8733	f5
1566  8734              ; -- invert all pixels on screen
1567  8734 21 00 70     	ld hl,VRAM					; start of Video RAM							;8734	21 00 70
1568  8737 01 00 08     	ld bc,64*32					; 2048 bytes - 32x64 bytes - 128x64px 			;8737	01 00 08
1569  873A              .NEXT_BYTE:
1570  873A 7E           	ld a,(hl)					; byte from screen								;873a	7e
1571  873B EE FF        	xor $ff						; invert all pixels								;873b	ee ff
1572  873D 77           	ld (hl),a					; save new byte to screen						;873d	77
1573  873E 23           	inc hl						; next screen address							;873e	23
1574  873F 0B           	dec bc						; decrement bytes counter						;873f	0b
1575  8740 78           	ld a,b						; check if bc = 0								;8740	78
1576  8741 B1           	or c						; a = b|c										;8741	b1
1577  8742 C2 3A 87     	jp nz,.NEXT_BYTE			; no - repeat for all pixels					;8742	c2 3a 87
1578  8745              ; -- play sounds
1579  8745 CD 40 80     	call SND.PLAY_MiddleLong	; play sound (middle/long)						;8745	cd 40 80
1580  8748 01 00 30     	ld bc,$3000					; delay value									;8748	01 00 30
1581  874B CD 5D 87     	call DELAY_BC				; wait delay									;874b	cd 5d 87
1582  874E CD 46 80     	call SND.PLAY_LowLong		; play sound (low/long)							;874e	cd 46 80
1583  8751 01 00 30     	ld bc,$3000					; delay value									;8751	01 00 30
1584  8754 CD 5D 87     	call DELAY_BC				; wait delay									;8754	cd 5d 87
1585  8757              ; -- repeat if needed
1586  8757 F1           	pop af						; flash counter									;8757	f1
1587  8758 3D           	dec a						; check if 0									;8758	3d
1588  8759 C2 33 87     	jp nz,.INVERT_PIXELS		; no - repeat 6 times							;8759	c2 33 87
1589  875C C9           	ret							; ---------------- End of Proc ----------		;875c	c9
1590  875D
1591  875D              ;***********************************************************************************************
1592  875D              ; Delay
1593  875D              ; IN: bc - delay counter
1594  875D              DELAY_BC:
1595  875D 0B           	dec bc						; decrement delay counter						;875d	0b
1596  875E 78           	ld a,b						; check if bc = 0								;875e	78
1597  875F B1           	or c						; a = b|c										;875f	b1
1598  8760 C2 5D 87     	jp nz,DELAY_BC				; no - wait delay								;8760	c2 5d 87
1599  8763 C9           	ret							; ---------------- End of Proc ----------		;8763	c9
1600  8764
1601  8764
1602  8764
1603  8764
1604  8764              ;***********************************************************************************************
1605  8764              ;
1606  8764              ;   G A M E    L O O P  -  U P D A T E   P L A Y E R
1607  8764              ;
1608  8764              ;***********************************************************************************************
1609  8764              GL_UPDATE_PLAYER:
1610  8764              ; -- decrement and check Player Update Timer
1611  8764 3A 12 80     	ld a,(PLAYER_UPD_TIMER)		; a - Player Update Timer						;8764	3a 12 80
1612  8767 3D           	dec a						; decrement Timer - check if elapsed			;8767	3d
1613  8768 32 12 80     	ld (PLAYER_UPD_TIMER),a		; store new value								;8768	32 12 80
1614  876B C0           	ret nz						; no ------------- End of Proc ----------------	;876b	c0
1615  876C              ; -- reset Timer to initial value 188
1616  876C 3E BC        	ld a,188					; initial value for Player Update Timer			;876c	3e bc
1617  876E 32 12 80     	ld (PLAYER_UPD_TIMER),a		; set new value									;876e	32 12 80
1618  8771              ; -- push on Stack address of routine to RETurn from jumps
1619  8771 21 B1 87     	ld hl,PLAYER_MOVE			; address of Proc to continue 					;8771	21 b1 87
1620  8774 E5           	push hl						; set as RETurn from routine					;8774	e5
1621  8775
1622  8775              ; -- clear screeen area at Player position
1623  8775 ED 5B 0D 80  	ld de,(PLAYER_VADR)			; de - Player's VRAM address					;8775	ed 5b 0d 80
1624  8779 D5           	push de						; save de 										;8779	d5
1625  877A 21 F1 8E     	ld hl,SPR.EMPTY				; Sprite Empty (8x4)px (2x4) bytes				;877a	21 f1 8e
1626  877D 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;877d	01 02 00
1627  8780 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;8780	3e 04
1628  8782 CD 75 89     	call DRAW_SPRITE			; draw sprite on screen (clear)					;8782	cd 75 89
1629  8785              ; -- clear Player Bit (5) in Collision Map for this area
1630  8785 E1           	pop hl						; hl - Player's VRAM address					;8785	e1
1631  8786 CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;8786	cd e9 89
1632  8789 06 DF        	ld b,%11011111				; bitmask to clear Player Bit (5)				;8789	06 df
1633  878B CD 78 86     	call CMAP_CLEAR_2X4			; clear Player Bit (5) in Collision Map			;878b	cd 78 86
1634  878E
1635  878E CD 15 88     	call TEST_KILL_GHOST		; check collision with any Ghost				;878e	cd 15 88
1636  8791              ; -- preload Player Sprite Props
1637  8791 3A 0F 80     	ld a,(PLAYER_PROPS)			; Player Move Direction							;8791	3a 0f 80
1638  8794 47           	ld b,a						; b - current Move Direction 					;8794	47
1639  8795 3A 10 80     	ld a,(PLAYER_PROPS+1)		; Sprite Shifted Flag							;8795	3a 10 80
1640  8798 4F           	ld c,a						; c - Sprite Shifted Flag						;8798	4f
1641  8799              ; -- read keys pressed and joystick (if enabled) - bit=1 -> input registered
1642  8799 CD 42 8F     	call INPUT.READ_INPUT		; read user input - a - input bitmask			;8799	cd 42 8f
1643  879C CB 47        	bit INPUT.UP,a				; is UP key pressed								;879c	cb 47
1644  879E C2 F2 89     	jp nz,TEST_MOVE_UP			; yes - try to move player UP					;879e	c2 f2 89
1645  87A1 CB 4F        	bit INPUT.DOWN,a			; is DOWN key pressed							;87a1	cb 4f
1646  87A3 C2 FE 89     	jp nz,TEST_MOVE_DOWN		; yes - try to move player DOWN					;87a3	c2 fe 89
1647  87A6 CB 57        	bit INPUT.LEFT,a			; is LEFT key pressed							;87a6	cb 57
1648  87A8 C2 16 8A     	jp nz,TEST_MOVE_LEFT		; yes - try to move player LEFT					;87a8	c2 16 8a
1649  87AB CB 5F        	bit INPUT.RIGHT,a			; is RIGHT key pressed							;87ab	cb 5f
1650  87AD C2 0A 8A     	jp nz,TEST_MOVE_RIGHT		; yes - try to move player RIGHT				;87ad	c2 0a 8a
1651  87B0
1652  87B0              ; -- no keys pressed - no move change required
1653  87B0 D1           	pop de						; remove from Stack RETurn address				;87b0	d1
1654  87B1              PLAYER_MOVE
1655  87B1              ; -- push on Stack address of routine to RETurn from jumps
1656  87B1 11 C7 87     	ld de,PLAYER_UPDATE			; address of Proc to continue					;87b1	11 c7 87
1657  87B4 D5           	push de						; set as RETurn from subroutine 				;87b4	d5
1658  87B5              ; -- try to move player
1659  87B5 78           	ld a,b						; Player move direction							;87b5	78
1660  87B6 B7           	or a						; is facing UP (0)								;87b6	b7
1661  87B7 CA 87 89     	jp z,PLAYER_MOVE_UP			; yes - move Player 1 line Up					;87b7	ca 87 89
1662  87BA FE 01        	cp 1						; is facing RIGHT (1)							;87ba	fe 01
1663  87BC CA AD 89     	jp z,PLAYER_MOVE_RIGHT		; yes - move Player 2px (??) Right				;87bc	ca ad 89
1664  87BF FE 02        	cp 2						; is facing DOWN (2)							;87bf	fe 02
1665  87C1 CA 9B 89     	jp z,PLAYER_MOVE_DOWN		; yes - move Player 1 line Down					;87c1	ca 9b 89
1666  87C4              ; -- is facing LEFT (3)
1667  87C4 C3 CB 89     	jp PLAYER_MOVE_LEFT			; move Player 2px (??) Left						;87c4	c3 cb 89
1668  87C7
1669  87C7              ; -- hl - destination VRAM address for Player, b - move direction, c - sprite shifted flag
1670  87C7              PLAYER_UPDATE:
1671  87C7              ; -- store new values
1672  87C7 22 0D 80     	ld (PLAYER_VADR),hl			; sore new VRAM address of Player Sprite		;87c7	22 0d 80
1673  87CA 78           	ld a,b						; a - player move direction 					;87ca	78
1674  87CB 32 0F 80     	ld (PLAYER_PROPS),a			; store as current 								;87cb	32 0f 80
1675  87CE 79           	ld a,c						; a - is sprite is shifted 2px right			;87ce	79
1676  87CF 32 10 80     	ld (PLAYER_PROPS+1),a		; store as current								;87cf	32 10 80
1677  87D2 E5           	push hl						; save hl - Player VRAM address					;87d2	e5
1678  87D3 EB           	ex de,hl					; de - destination to draw sprite				;87d3	eb
1679  87D4 79           	ld a,c						; Sprite Shifter Flag							;87d4	79
1680  87D5 B7           	or a						; is shifted 2px right?							;87d5	b7
1681  87D6 C2 EA 87     	jp nz,.DRAW_SHIFTED			; yes - draw shifted variant of sprite			;87d6	c2 ea 87
1682  87D9              ; -- check if Playar changes move direction
1683  87D9 3A 11 80     	ld a,(PLAYER_ANIM)			; a - player Animation Flag						;87d9	3a 11 80
1684  87DC B7           	or a						; is this animation frame ?						;87dc	b7
1685  87DD CA FC 87     	jp z,.SET_ANIM_FLAG			; no - set Flag and draw regular Player sprite	;87dd	ca fc 87
1686  87E0
1687  87E0              ; -- in this frame - use Animated Sprite Variant and toggle (clear) Animation Flag
1688  87E0 21 E9 8E     	ld hl,SPR.PLAYER_ANIM		; Sprite Player (animation frame)				;87e0	21 e9 8e
1689  87E3 AF           	xor a						; reset value									;87e3	af
1690  87E4 32 11 80     	ld (PLAYER_ANIM),a			; clear Animation Flag							;87e4	32 11 80
1691  87E7 C3 03 88     	jp DRAW_PLAYER				; --------- draw sprite on screen ----------	;87e7	c3 03 88
1692  87EA
1693  87EA              ; -- draw player using shifted variant of sprite
1694  87EA              .DRAW_SHIFTED
1695  87EA 78           	ld a,b						; a - player moving direction					;87ea	78
1696  87EB FE 01        	cp 1						; is player faicing right ?						;87eb	fe 01
1697  87ED CA F6 87     	jp z,.DRAW_PLAYER_R_SH		; yes - draw Player facing right				;87ed	ca f6 87
1698  87F0
1699  87F0              .DRAW_PLAYER_L_SH
1700  87F0              ; -- draw player using shifted variant of sprite (facing Left)
1701  87F0 21 D1 8E     	ld hl,SPR.PLAYER_L_SH		; Sprite Player (facing Left) shifted 2px right	;87f0	21 d1 8e
1702  87F3 C3 03 88     	jp DRAW_PLAYER				; --------- draw sprite on screen ----------	;87f3	c3 03 88
1703  87F6
1704  87F6              ; -- draw player using shifted variant of sprite (facing Right)
1705  87F6              .DRAW_PLAYER_R_SH:
1706  87F6 21 C9 8E     	ld hl,SPR.PLAYER_R_SH		; Sprite Player (facing Right) shifted 2px right;87f6	21 c9 8e
1707  87F9 C3 03 88     	jp DRAW_PLAYER				; --------- draw sprite on screen ----------	;87f9	c3 03 88
1708  87FC
1709  87FC              ; -- set Animation Flag and draw player using current sprite
1710  87FC              .SET_ANIM_FLAG:
1711  87FC 3C           	inc a						; toggle (set) Animation Flag					;87fc	3c
1712  87FD 32 11 80     	ld (PLAYER_ANIM),a			; next time draw Animated Sprite Variant		;87fd	32 11 80
1713  8800 2A 0B 80     	ld hl,(PLAYER_SADR)			; address of current Player Sprite Variant		;8800	2a 0b 80
1714  8803
1715  8803              ; -- de - destination VRAM address, hl - sprite data address
1716  8803              DRAW_PLAYER:
1717  8803 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;8803	01 02 00
1718  8806 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;8806	3e 04
1719  8808 CD 75 89     	call DRAW_SPRITE			; draw sprite on screen							;8808	cd 75 89
1720  880B              ; -- check collision with
1721  880B E1           	pop hl						; hl - destination VRAM address					;880b	e1
1722  880C CD E9 89     	call CMAP_GET_BYTE			; de - address in Buffer, a - byte from Buffer	;880c	cd e9 89
1723  880F CD 15 88     	call TEST_KILL_GHOST		; check collision with any Ghost				;880f	cd 15 88
1724  8812 C3 E3 88     	jp TEST_EAT_STUFF			; check Collision with Dots, Power Pills, Heart ;8812	c3 e3 88
1725  8815
1726  8815
1727  8815              ;***********************************************************************************************
1728  8815              ; Test Player collision with Ghost but only if Ghost Chase Mode is active
1729  8815              ; Player can Kill Ghost only if Chase Mode is active.
1730  8815              ; Collision when Ghost can KIll Player is tested in Ghosts Update routines (TEST_KILL_PLAYER)
1731  8815              TEST_KILL_GHOST
1732  8815              ; -- check if Chase Mode is active
1733  8815 3A 2C 80     	ld a,(CMODE_ON_TIMER)		; a - Ghost Chase Mode Timer					;8815	3a 2c 80
1734  8818 B7           	or a						; is Chase Mode active?							;8818	b7
1735  8819 C8           	ret z						; no ---------- End of Proc -------------------	;8819	c8
1736  881A
1737  881A              ; -- Chase Mode is active - check collision with any Ghost
1738  881A E5           	push hl						; save hl - Player VRAM address					;881a	e5
1739  881B D5           	push de						; save de - address in Collision Map			;881b	d5
1740  881C EB           	ex de,hl					; hl - address in Collision Map					;881c	eb
1741  881D 11 1F 00     	ld de,31					; 31 bytes per line (32-1 handled below)		;881d	11 1f 00
1742  8820 CB 66        	bit 4,(hl)					; check if Ghost Bit (4) is set in CMap			;8820	cb 66
1743  8822 23           	inc hl						; point to next byte							;8822	23
1744  8823 CA 2B 88     	jp z,.NEXT_LINE				; no - skip checking next byte					;8823	ca 2b 88
1745  8826              ; -- bit is set - there is Ghost (left side)
1746  8826 CB 66        	bit 4,(hl)					; check if Ghost Bit (4) is set in CMap			;8826	cb 66
1747  8828 C2 3A 88     	jp nz,KILL_GHOST			; yes - both are set - Kill Ghost				;8828	c2 3a 88
1748  882B              .NEXT_LINE:
1749  882B 19           	add hl,de					; point to next line in Collision Map			;882b	19
1750  882C CB 66        	bit 4,(hl)					; check if Ghost Bit (4) is set in CMap			;882c	cb 66
1751  882E CA 37 88     	jp z,.EXIT					; no - there is no collision					;882e	ca 37 88
1752  8831              ; -- bit is set - there is Ghost (left side)
1753  8831 23           	inc hl						; point to next byte							;8831	23
1754  8832 CB 66        	bit 4,(hl)					; check if Ghost Bit (4) is set in CMap			;8832	cb 66
1755  8834 C2 3A 88     	jp nz,KILL_GHOST			; yes - both are set - Kill Ghost				;8834	c2 3a 88
1756  8837              .EXIT:
1757  8837 D1           	pop de						; restore de - address in Collision Map			;8837	d1
1758  8838 E1           	pop hl						; restore hl - Player VRAM address				;8838	e1
1759  8839 C9           	ret							; --------------- End of Proc -----------------	;8839	c9
1760  883A
1761  883A              KILL_GHOST:
1762  883A              ; -- mark place (bytes) in Collision Map where Ghost was killed
1763  883A 2B           	dec hl						; hl - addr of "sprite left byte" in CMap 		;883a	2b
1764  883B 7E           	ld a,(hl)					; a - current CMap byte value					;883b	7e
1765  883C 36 FF        	ld (hl),$ff					; store Ghost Killed Here Flag					;883c	36 ff
1766  883E F5           	push af						; save a - previous CMap value					;883e	f5
1767  883F E5           	push hl						; save hl - address in Collision Map			;883f	e5
1768  8840              ; -- find Ghost that was killed and respawn it
1769  8840 2A 18 80     	ld hl,(GHOST_B1.VADR)		; VRAM address of Ghost Blue 1					;8840	2a 18 80
1770  8843 CD C2 88     	call GHOST_HAS_KILL_FLAG	; check if Ghost Blue 1 was killed 				;8843	cd c2 88
1771  8846 CA 88 88     	jp z,RESPAWN_GHOST_B1		; yes - respawn Ghost Blue 1					;8846	ca 88 88
1772  8849 2A 1D 80     	ld hl,(GHOST_B2.VADR)		; VRAM address of Ghost Blue 2					;8849	2a 1d 80
1773  884C CD C2 88     	call GHOST_HAS_KILL_FLAG	; check if Ghost Blue 2 was killed 				;884c	cd c2 88
1774  884F CA 7E 88     	jp z,RESPAN_GHOST_B2		; yes - respawn Ghost Blue 2					;884f	ca 7e 88
1775  8852 2A 22 80     	ld hl,(GHOST_R1.VADR)		; VRAM address of Ghost Red 1					;8852	2a 22 80
1776  8855 CD C2 88     	call GHOST_HAS_KILL_FLAG	; check if Ghost Red 1 was killed 				;8855	cd c2 88
1777  8858 CA 74 88     	jp z,RESPAWN_GHOST_R1		; yes - respawn Ghost Red 1						;8858	ca 74 88
1778  885B 2A 27 80     	ld hl,(GHOST_R2.VADR)		; VRAM address of Ghost Red 2					;885b	2a 27 80
1779  885E CD C2 88     	call GHOST_HAS_KILL_FLAG	; check if Ghost Red 2 was killed 				;885e	cd c2 88
1780  8861 CA 6A 88     	jp z,RESPAWN_GHOST_R2		; yes - respawn Ghost Red 2						;8861	ca 6a 88
1781  8864              ; -- restore previous value of byte in Collision Map
1782  8864 E1           	pop hl						; restore hl - address in Collision Map			;8864	e1
1783  8865 F1           	pop af						; restore a - previous CMap value				;8865	f1
1784  8866 77           	ld (hl),a					; restore previous value in Collision Map		;8866	77
1785  8867 D1           	pop de						; restore de - address in Collision Map			;8867	d1
1786  8868 E1           	pop hl						; restore hl - Player VRAM address				;8868	e1
1787  8869 C9           	ret							; --------------- End of Proc -----------------	;8869	c9
1788  886A
1789  886A              ;***********************************************************************************************
1790  886A              ; Respawn Ghost in Ghost Cage - Multiple entries for every Ghost
1791  886A              RESPAWN_GHOST_R2:
1792  886A E5           	push hl					; save hl - current VRAM address					;886a	e5
1793  886B 21 27 80     	ld hl,GHOST_R2.VADR		; VRAM address of Ghost Red 2						;886b	21 27 80
1794  886E 11 D0 73     	ld de,VRAM+(30*32)+16	; screen coord (64,30)px (16,30)bytes [$73d0]		;886e	11 d0 73
1795  8871 C3 8F 88     	jp RESPAWN_GHOST		; spawn Ghost Red 2									;8871	c3 8f 88
1796  8874              RESPAWN_GHOST_R1:
1797  8874 E5           	push hl					; save hl - current VRAM address					;8874	e5
1798  8875 21 22 80     	ld hl,GHOST_R1.VADR		; VRAM address of Ghost Red 1						;8875	21 22 80
1799  8878 11 CE 73     	ld de,VRAM+(30*32)+14	; screen coord (56,30)px (14,30)bytes [$73ce]		;8878	11 ce 73
1800  887B C3 8F 88     	jp RESPAWN_GHOST		; spawn Ghost Red 1									;887b	c3 8f 88
1801  887E              RESPAN_GHOST_B2:
1802  887E E5           	push hl					; save hl - current VRAM address					;887e	e5
1803  887F 21 1D 80     	ld hl,GHOST_B2.VADR		; VRAM address of Ghost Blue 2						;887f	21 1d 80
1804  8882 11 CC 73     	ld de,VRAM+(30*32)+12	; screen coord (48,30)px (12,30)bytes [$73cc]		;8882	11 cc 73
1805  8885 C3 8F 88     	jp RESPAWN_GHOST		; spawn Ghost Blue 2								;8885	c3 8f 88
1806  8888              RESPAWN_GHOST_B1:
1807  8888 E5           	push hl					; save hl - current VRAM address					;8888	e5
1808  8889 21 18 80     	ld hl,GHOST_B1.VADR		; VRAM address of Ghost Blue 1						;8889	21 18 80
1809  888C 11 CA 73     	ld de,VRAM+(30*32)+10	; screen coord (40,30)px (10,30)bytes [$73ca]		;888c	11 ca 73
1810  888F
1811  888F              ; -- hl - Ghost VRAM address variable, de - VRAM address where Ghost will be drawn
1812  888F              RESPAWN_GHOST:
1813  888F              ; -- fill GHOST variable structure to initial values
1814  888F 73           	ld (hl),e				; store low byte of spawn new VRAM address			;888f	73
1815  8890 23           	inc hl					; address GHOST_xx.VRAM + 1							;8890	23
1816  8891 72           	ld (hl),d				; store high byte of spawn new VRAM address			;8891	72
1817  8892 23           	inc hl					; address GHOST_xx.PROPS (Move Direction)			;8892	23
1818  8893 36 00        	ld (hl),0				; reset value to 0 									;8893	36 00
1819  8895 23           	inc hl					; address GHOST_xx.PROPS + 1 (Sprite Shift Flag)	;8895	23
1820  8896 36 00        	ld (hl),0				; reset value to 0 									;8896	36 00
1821  8898 23           	inc hl					; address GHOST_xx.FREEZE							;8898	23
1822  8899 CD 03 84     	call RANDOM_32_63		; a - Random Value in range 32..63					;8899	cd 03 84
1823  889C 77           	ld (hl),a				; init Freeze Timer with Random value 				;889c	77
1824  889D              ; -- remove Ghost sprite from screen at old position
1825  889D D1           	pop de					; de - current (old) VRAM addres of Ghost			;889d	d1
1826  889E D5           	push de					; save de											;889e	d5
1827  889F 21 F1 8E     	ld hl,SPR.EMPTY			; Sprite Empty (8x4)px (2x4) bytes					;889f	21 f1 8e
1828  88A2 01 02 00     	ld bc,2					; bc - 2 bytes (8px) - sprite width					;88a2	01 02 00
1829  88A5 3E 04        	ld a,4					; a - 4 lines (4px) - sprite height					;88a5	3e 04
1830  88A7 CD 75 89     	call DRAW_SPRITE		; draw sprite on screen								;88a7	cd 75 89
1831  88AA              ; -- restore Collision Map byte
1832  88AA E1           	pop hl					; hl - current (old) VRAM addres of Ghost			;88aa	e1
1833  88AB D1           	pop de					; restore de - CMap address where Ghost was KIlled	;88ab	d1
1834  88AC F1           	pop af					; restore af - previous CMap byte value				;88ac	f1
1835  88AD 12           	ld (de),a				; replace Ghost Killed Flag ($ff) with prev value	;88ad	12
1836  88AE              ; -- remove Ghost Bit (4) from Collision Map where Ghost was
1837  88AE CD E9 89     	call CMAP_GET_BYTE		; de - address in Collision Map						;88ae	cd e9 89
1838  88B1 06 EF        	ld b,%11101111			; bitmask to clear Ghost Bit (4)					;88b1	06 ef
1839  88B3 CD 78 86     	call CMAP_CLEAR_2X4		; clear Ghost Bit (4) in Collision Map				;88b3	cd 78 86
1840  88B6              ; -- add Points to Score and play Sound
1841  88B6 CD 94 80     	call SCORE_ADD_100		; add 100 points to Score							;88b6	cd 94 80
1842  88B9 CD 94 80     	call SCORE_ADD_100		; add 100 points to Score (200 in total)			;88b9	cd 94 80
1843  88BC CD 34 80     	call SND.PLAY_LowShort	; generate Sound (low/short)						;88bc	cd 34 80
1844  88BF D1           	pop de					; restore de - address in Collision Map				;88bf	d1
1845  88C0 E1           	pop hl					; restore hl - Player VRAM address					;88c0	e1
1846  88C1 C9           	ret						; --------------- End of Proc ---------------------	;88c1	c9
1847  88C2
1848  88C2              ;***********************************************************************************************
1849  88C2              ; Checks if Ghost is marked with Killed Flag ($ff)
1850  88C2              ; IN: hl - VRAM address of Ghost
1851  88C2              ; OUT: a - 0 if Ghost is marked, $ff if not
1852  88C2              ;      Flag Z - 1 if Ghost is marked, 0 if not
1853  88C2              GHOST_HAS_KILL_FLAG:
1854  88C2 E5           	push hl						; save hl - VRAM Ghost address					;88c2	e5
1855  88C3 CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;88c3	cd e9 89
1856  88C6 EB           	ex de,hl					; hl - address in Collision Map					;88c6	eb
1857  88C7 11 20 00     	ld de,32					; 32 bytes per screen line						;88c7	11 20 00
1858  88CA 3E FF        	ld a,$ff					; a - value to compare							;88ca	3e ff
1859  88CC BE           	cp (hl)						; check if byte in buffer = $ff					;88cc	be
1860  88CD CA E0 88     	jp z,.EXIT_YES				; yes - return with 0 value						;88cd	ca e0 88
1861  88D0 19           	add hl,de					; hl - address in next line						;88d0	19
1862  88D1 BE           	cp (hl)						; check if byte in buffer = $ff					;88d1	be
1863  88D2 CA E0 88     	jp z,.EXIT_YES				; yes - return with 0 value						;88d2	ca e0 88
1864  88D5              ; -- strange code ??? - (selfmodify???)
1865  88D5              ; 16 bit add will never change Z flag, so if we're here than Z=0 and below jumps will never occour
1866  88D5 19           	add hl,de					; hl - address in next line (2 lines below)		;88d5	19
1867  88D6 CA E0 88     	jp z,.EXIT_YES				; ?? flag Z is unaffected - never will jump		;88d6	ca e0 88
1868  88D9 19           	add hl,de					; hl - address in next line (3 lines below)		;88d9	19 	.
1869  88DA CA E0 88     	jp z,.EXIT_YES				; ?? flag Z is unaffected - never will jump		;88da	ca e0 88
1870  88DD              ; -- pop hl will discard additions above (no point of above code!)
1871  88DD E1           	pop hl						; restore hl - VRAM Ghost address				;88dd	e1
1872  88DE B7           	or a						; set flags (a = -1)							;88de	b7
1873  88DF C9           	ret							; --------- End of Proc (-1) -------------		;88df	c9
1874  88E0              .EXIT_YES:
1875  88E0 AF           	xor a						; set a to 0 and flags							;88e0	af
1876  88E1 E1           	pop hl						; restore hl - VRAM Ghost address				;88e1	e1
1877  88E2 C9           	ret							; --------- End of Proc (0) --------------		;88e2	c9
1878  88E3
1879  88E3
1880  88E3              ;***********************************************************************************************
1881  88E3              ; Test Player collision with Dots, Power Pills or Heart (Bonus)
1882  88E3              ; IN: de - address in Collision Map
1883  88E3              TEST_EAT_STUFF:
1884  88E3              ; -- update Player position in Collision Map
1885  88E3 06 20        	ld b,%00100000				; Player Bit (5) to set in Colision Map			;88e3	06 20
1886  88E5 CD 8F 86     	call CMAP_SET_2X4			; set Player Bit (5) in CMap (8x4)px (2x4)bytes	;88e5	cd 8f 86
1887  88E8
1888  88E8              ; -- check collision with Dot, Power Pill or Heart
1889  88E8 21 20 00     	ld hl,32					; 32 bytes per line								;88e8	21 20 00
1890  88EB 19           	add hl,de					; CMap address in line where Stuff is marked	;88eb	19
1891  88EC CD F4 88     	call TRY_EAT_STUFF			; check collision with sprite "left" byte		;88ec	cd f4 88
1892  88EF 23           	inc hl						; next CMap address - sprite "right" byte		;88ef	23
1893  88F0 CD F4 88     	call TRY_EAT_STUFF			; check collision with sprite "right" byte		;88f0	cd f4 88
1894  88F3 C9           	ret							; ------------End of Proc --------------------- ;88f3	c9
1895  88F4
1896  88F4
1897  88F4              ;***********************************************************************************************
1898  88F4              ; Try Eat Dots, Power Pills or Heart (Bonus) if it is at Player position
1899  88F4              ; IN: hl - address in Collision Map to test
1900  88F4              TRY_EAT_STUFF:
1901  88F4 7E           	ld a,(hl)					; a - byte from Collision Map					;88f4	7e
1902  88F5 CB 7F        	bit 7,a						; is there Dot or Heart (bit 7 is set)			;88f5	cb 7f
1903  88F7 C2 15 89     	jp nz,TRY_EAT_DOT_OR_HEART	; yes - check if it is Heart or Dot				;88f7	c2 15 89
1904  88FA
1905  88FA              ; -- no Dot here - check if is there Power Pill
1906  88FA CB 77        	bit 6,a						; is there Power Pill (bit 6 is set)			;88fa	cb 77
1907  88FC C8           	ret z						; no -------- End of Proc ---------------------	;88fc	c8
1908  88FD
1909  88FD              ;***********************************************************************************************
1910  88FD              ; Eat Power Pill
1911  88FD              ; Remove Power Pill from screen and Collision Map and add 100 Points to Score
1912  88FD              ; Also turn ON Ghost Chase Mode when Player can kill Ghost when catch it
1913  88FD              EAT_POWER_PILL
1914  88FD              ; -- remove mark from Collision Map
1915  88FD CB B7        	res 6,a						; clear Power Pill Bit (6)						;88fd	cb b7
1916  88FF 77           	ld (hl),a					; update byte in Collision Map					;88ff	77
1917  8900              ; -- set Ghost Chase Mode - Player can Eat Ghosts and they run away
1918  8900 3A 09 80     	ld a,(LEVEL_CMODE_TIME)		; Ghost Chase Mode Time 						;8900	3a 09 80
1919  8903 32 2C 80     	ld (CMODE_ON_TIMER),a		; set Ghost Chase Mode Timer					;8903	32 2c 80
1920  8906
1921  8906              ; -- change screen colors
1922  8906 3E 18        	ld a,VDG_GFX_COLORS_1		; alternate colors (Mode 1)						;8906	3e 18
1923  8908 32 00 68     	ld (IOLATCH),a				; change screen									;8908	32 00 68
1924  890B 32 6F 80     	ld (IOLATCH_SHADOW),a		; store into shadow register					;890b	32 6f 80
1925  890E
1926  890E              ; -- add 100 points to Score and play Sound
1927  890E CD 94 80     	call SCORE_ADD_100			; add 100 points to Player Score				;890e	cd 94 80
1928  8911 CD 40 80     	call SND.PLAY_MiddleLong	; play middle-long sound						;8911	cd 40 80
1929  8914 C9           	ret							; ----------- End of Proc ---------------------	;8914	c9
1930  8915
1931  8915              ;***********************************************************************************************
1932  8915              ; Try Eat Dots, Power Pills or Heart (Bonus) if it is at Player position
1933  8915              ; IN: hl - address in Collision Map to test
1934  8915              ;     a - byte from Colission Map
1935  8915              ;-----------------------------------------------------------------------------------------------
1936  8915              ; -- bit 7 is set in Collision Map - could be Heart or Dot
1937  8915              TRY_EAT_DOT_OR_HEART:
1938  8915 CB 77        	bit 6,a						; is there Heart (bit 7 and 6 set)				;8915	cb 77
1939  8917 C2 49 89     	jp nz,EAT_HEART				; yes - add 300 points and remove Heart			;8917	c2 49 89
1940  891A
1941  891A              ; -- only 7 bit is set - it is regular Dot
1942  891A
1943  891A              ;***********************************************************************************************
1944  891A              ; Eat Dot
1945  891A              ; Remove Dot from Colission Map and add 10 Points to Score
1946  891A              ; Game counts dots eaten. If this is 25th, 50th or 75th dot than it raise difficulty
1947  891A              ; by speed up moves of Ghost Red 2 (A).
1948  891A              ; IN: hl - address in Collision Map
1949  891A              ;     a - byte from Colission Map
1950  891A              EAT_DOT
1951  891A              ; -- remove Dot Bit (6) from Collision Map
1952  891A CB BF        	res 7,a						; clear Dot Bit (6)								;891a	cb bf
1953  891C 77           	ld (hl),a					; update byte in Collision Map					;891c	77
1954  891D              ; -- add 1 Dot Eaten to counter
1955  891D 3A 06 80     	ld a,(DOTS_EATEN)			; a - Dots Eaten Counter						;891d	3a 06 80
1956  8920 3C           	inc a						; add 1 Dot										;8920	3c
1957  8921 32 06 80     	ld (DOTS_EATEN),a			; save new value								;8921	32 06 80
1958  8924              ; -- when Player has eaten 25th, 50th or 75th Dot we will speed up Ghost Red A moves
1959  8924 FE 19        	cp 25						; is this 25th Dot?								;8924	fe 19
1960  8926 CA 3A 89     	jp z,.EXIT_SPEEDUP			; yes - speed up Ghost Red 2					;8926	ca 3a 89
1961  8929 FE 32        	cp 50						; is this 50th Dot?								;8929	fe 32
1962  892B CA 3A 89     	jp z,.EXIT_SPEEDUP			; yes - speed up Ghost Red 2					;892b	ca 3a 89
1963  892E FE 4B        	cp 75						; is this 75th Dot?								;892e	fe 4b
1964  8930 CA 3A 89     	jp z,.EXIT_SPEEDUP			; yes - speed up Ghost Red 2					;8930	ca 3a 89
1965  8933
1966  8933              ; -- none of above - just add 10 points to Score and play Sound
1967  8933 CD 82 80     	call SCORE_ADD_10			; add 10 points to Player Score					;8933	cd 82 80
1968  8936 CD 3A 80     	call SND.PLAY_HighShort		; play middle-short sound						;8936	cd 3a 80
1969  8939 C9           	ret							; ----------- End of Proc ---------------------	;8939	c9
1970  893A
1971  893A              .EXIT_SPEEDUP:
1972  893A 3A 0A 80     	ld a,(LEVEL_GA_SPEEDUP)		; value to decrement Ghost Red A Update Timer	;893a	3a 0a 80
1973  893D 5F           	ld e,a						; e - value 									;893d	5f
1974  893E 3A 08 80     	ld a,(LEVEL_GA_UPD_TIMER)	; a - Ghost Red A Update Timer for this Level	;893e	3a 08 80
1975  8941 93           	sub e						; lower Timer value by Speedup value			;8941	93
1976  8942 32 08 80     	ld (LEVEL_GA_UPD_TIMER),a	; store new initial value for Timer				;8942	32 08 80
1977  8945              ; -- add 10 points to Score
1978  8945 CD 82 80     	call SCORE_ADD_10			; add 10 points to Player Score					;8945	cd 82 80
1979  8948 C9           	ret							; ----------- End of Proc ---------------------	;8948	c9
1980  8949
1981  8949              ;***********************************************************************************************
1982  8949              ; Eat Heart
1983  8949              ; Add 300 Points to Score, remove Heart from screen and Colission MapTry Eat Dots,
1984  8949              ; reinitialize Heart parameters (Timer and LifeTime) and decrement Heart counter for this Level
1985  8949              EAT_HEART:
1986  8949              ; -- add 300 points to Score
1987  8949 CD 94 80     	call SCORE_ADD_100			; add 100 points to Score						;8949	cd 94 80
1988  894C CD 94 80     	call SCORE_ADD_100			; add 100 points to Score						;894c	cd 94 80
1989  894F CD 94 80     	call SCORE_ADD_100			; add 100 points to Score (300 in total)		;894f	cd 94 80
1990  8952              ; -- clear area on screen
1991  8952 21 F1 8E     	ld hl,SPR.EMPTY				; Sprite Empty (8x4)px (2x4) bytes				;8952	21 f1 8e
1992  8955 11 AD 74     	ld de,VRAM+(37*32)+13		; screen coord (52,37)px (13,37) [$74ad]		;8955	11 ad 74
1993  8958 D5           	push de						; save de - screeen coords						;8958	d5
1994  8959 01 02 00     	ld bc,2						; bc - 2 bytes (8px) - sprite width				;8959	01 02 00
1995  895C 3E 04        	ld a,4						; a - 4 lines (4px) - sprite height				;895c	3e 04
1996  895E CD 75 89     	call DRAW_SPRITE			; clear area on screen							;895e	cd 75 89
1997  8961              ; -- clear marks in Collision Map (remove Heart from CMap)
1998  8961 E1           	pop hl						; hl - VRAM address								;8961	e1
1999  8962 CD E9 89     	call CMAP_GET_BYTE			; de - address in Collision Map					;8962	cd e9 89
2000  8965 06 3F        	ld b,%00111111				; Heart Bits (7,6)								;8965	06 3f
2001  8967 CD 78 86     	call CMAP_CLEAR_2X4			; clear Heart Bits (7,6) in Collision Map		;8967	cd 78 86
2002  896A              ; -- initialize Heart parameters (Timer and LifeTime)
2003  896A CD 7E 82     	call INIT_HEART_PROPS		; set initial values for Heart					;896a	cd 7e 82
2004  896D              ; -- decrement 1 Heart Counter for this Level
2005  896D 3A 31 80     	ld a,(HEARTS_PER_LEVEL)		; number of Hearts for this Level				;896d	3a 31 80
2006  8970 3D           	dec a						; decrement Hearts left							;8970	3d
2007  8971 32 31 80     	ld (HEARTS_PER_LEVEL),a		; store new value								;8971	32 31 80
2008  8974 C9           	ret							; ---------------- End of Proc ------------		;8974	c9
2009  8975
2010  8975              ;***********************************************************************************************
2011  8975              ; Draw Sprite
2012  8975              ; IN: hl - source - sprite data
2013  8975              ;     de - destination - VRAM address (top-left pixel)
2014  8975              ;     bc - sprite width in bytes
2015  8975              ; 	  a  - sprite height in pixels (lines)
2016  8975              DRAW_SPRITE:
2017  8975 C5           	push bc						; save bc - sprite width (in bytes)				;8975	c5
2018  8976 D5           	push de						; save de - destination VRAM address			;8976	d5
2019  8977 ED B0        	ldir						; copy to screen one sprite line				;8977	ed b0
2020  8979 D1           	pop de						; restore de - VRAM address of left pixel		;8979	d1
2021  897A E5           	push hl						; save hl - current source data					;897a	e5
2022  897B 21 20 00     	ld hl,32					; 32 bytes per screen line						;897b	21 20 00
2023  897E 19           	add hl,de					; add one screen line 							;897e	19
2024  897F EB           	ex de,hl					; de - sprite left edge, one line below 		;897f	eb
2025  8980 E1           	pop hl						; restore hl - current source byte				;8980	e1
2026  8981 C1           	pop bc						; restore bc - sprite width (in bytes)			;8981	c1
2027  8982 3D           	dec a						; decrement line counter (check if 0)			;8982	3d
2028  8983 C2 75 89     	jp nz,DRAW_SPRITE			; no - draw next sprite line					;8983	c2 75 89
2029  8986 C9           	ret							; --------------- End of Proc -----------------	;8986	c9
2030  8987
2031  8987
2032  8987              PLAYER_MOVE_UP:
2033  8987 11 D9 8E     	ld de,SPR.PLAYER_U			; Sprite Player (facing Up)						;8987	11 d9 8e
2034  898A ED 53 0B 80  	ld (PLAYER_SADR),de			; store as address of current Sprite Variant	;898a	ed 53 0b 80
2035  898E CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;898e	cd e9 89
2036  8991 CB 47        	bit 0,a						; is wall 1 byte above 							;8991	cb 47
2037  8993 C8           	ret z						; yes - can't move ---- Return to PLAYER_UPDATE	;8993	c8
2038  8994              ; -- no wall above - calculate new VRAM position for Player
2039  8994 11 20 00     	ld de,32					; 32 bytes per screen line						;8994	11 20 00
2040  8997 B7           	or a						; clear Carry flag								;8997	b7
2041  8998 ED 52        	sbc hl,de					; hl address of pixel 1 line above				;8998	ed 52
2042  899A C9           	ret							; ---- Return to PLAYER_UPDATE routine --------	;899a	c9
2043  899B
2044  899B              PLAYER_MOVE_DOWN:
2045  899B 11 E1 8E     	ld de,SPR.PLAYER_D			; Sprite Player (facing Down)					;899b	11 e1 8e
2046  899E ED 53 0B 80  	ld (PLAYER_SADR),de			; store as address of current Sprite Variant	;899e	ed 53 0b 80
2047  89A2 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;89a2	cd e9 89
2048  89A5 CB 57        	bit 2,a						; is wall 1 byte below							;89a5	cb 57
2049  89A7 C8           	ret z						; yes - can't move ---- Return to PLAYER_UPDATE	;89a7	c8
2050  89A8              ; -- no wall below - calculate new VRAM position for Player
2051  89A8 11 20 00     	ld de,32					; 32 bytes per screen line						;89a8	11 20 00
2052  89AB 19           	add hl,de					; hl address of pixel 1 line below				;89ab	19
2053  89AC C9           	ret							; ---- Return to PLAYER_UPDATE routine --------	;89ac	c9
2054  89AD
2055  89AD              PLAYER_MOVE_RIGHT:
2056  89AD              ; -- reset Timer to initial value 170
2057  89AD 3E AA        	ld a,170					; initial value for Player Update Timer			;89ad	3e aa
2058  89AF 32 12 80     	ld (PLAYER_UPD_TIMER),a		; set new value									;89af	32 12 80
2059  89B2              ; -- change Player Sprite for use from now on
2060  89B2 11 FA 8E     	ld de,SPR.PLAYER_R			; Sprite Player (facing Right)  				;89b2	11 fa 8e
2061  89B5 ED 53 0B 80  	ld (PLAYER_SADR),de			; store as address of current Sprite Variant	;89b5	ed 53 0b 80
2062  89B9              ; -- do we have to move Sprite to next VRAM address or only change Sprite variant
2063  89B9 79           	ld a,c						; Sprite Shifted Flag 							;89b9	79
2064  89BA B7           	or a						; check if sprite is Shifted 2px right			;89ba	b7
2065  89BB CA C2 89     	jp z,.ONLY_SHIFT			; no - use shifted sprite - VRAM won't change	;89bb	ca c2 89
2066  89BE              ; -- Player position was already shifted 2px right - move to next VRAM byte
2067  89BE 0E 00        	ld c,0						; reset Sprite Shifted Flag						;89be	0e 00
2068  89C0 23           	inc hl						; hl address of next right byte					;89c0	23
2069  89C1 C9           	ret							; ---- Return to PLAYER_UPDATE routine --------	;89c1	c9
2070  89C2              .ONLY_SHIFT:
2071  89C2 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;89c2	cd e9 89
2072  89C5 CB 4F        	bit 1,a						; is wall 1 byte right							;89c5	cb 4f
2073  89C7 C8           	ret z						; yes - can't move ---- Return to PLAYER_UPDATE	;89c7	c8
2074  89C8              ; -- no wall on right - Player position wasn't shifted - switch to shifted (2px right) sprite - no VRAM change
2075  89C8 0E 01        	ld c,1						; set Sprite Shifted Flag						;89c8	0e 01
2076  89CA C9           	ret							; ---- Return to PLAYER_UPDATE routine --------	;89ca	c9
2077  89CB
2078  89CB              PLAYER_MOVE_LEFT:
2079  89CB              ; -- reset Timer to initial value 170
2080  89CB 3E AA        	ld a,170					; initial value for Player Update Timer			;89cb	3e aa
2081  89CD 32 12 80     	ld (PLAYER_UPD_TIMER),a		; set new value									;89cd	32 12 80
2082  89D0              ; -- change Player Sprite for use from now on
2083  89D0 11 02 8F     	ld de,SPR.PLAYER_L			; Sprite Player (facing Left) 					;89d0	11 02 8f
2084  89D3 ED 53 0B 80  	ld (PLAYER_SADR),de			; store as address of current Sprite Variant	;89d3	ed 53 0b 80
2085  89D7              ; -- do we have to move Sprite to next VRAM address or only change Sprite variant to nonshifted
2086  89D7 79           	ld a,c						; Sprite Shifted Flag 							;89d7	79
2087  89D8 B7           	or a						; check if sprite is Shifted 2px right			;89d8	b7
2088  89D9 CA DF 89     	jp z,.CHANGE_VADR			; no - change VRAM address to previous byte		;89d9	ca df 89
2089  89DC              ; -- Player position was already shifted 2px right - switch to nonshifted sprite - no VRAM change
2090  89DC 0E 00        	ld c,0						; clear Sprite Shifted Flag						;89dc	0e 00
2091  89DE C9           	ret							; ---- Return to PLAYER_UPDATE routine --------	;89de	c9
2092  89DF              .CHANGE_VADR:
2093  89DF CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;89df	cd e9 89
2094  89E2 CB 5F        	bit 3,a						; is wall 1 byte left							;89e2	cb 5f
2095  89E4 C8           	ret z						; yes - can't move ---- Return to PLAYER_UPDATE	;89e4	c8
2096  89E5              ; -- no wall on left - Player position wasn't shifted - switch to shifted (2px right) sprite and change VRAM address
2097  89E5 0E 01        	ld c,1						; set Sprite Shifted Flag						;89e5	0e 01
2098  89E7 2B           	dec hl						; hl address of next left byte					;89e7	2b
2099  89E8 C9           	ret							; ---- Return to PLAYER_UPDATE routine --------	;89e8	c9
2100  89E9
2101  89E9
2102  89E9              ;***********************************************************************************************
2103  89E9              ; Get Byte from Collision Map for specified VRAM Address
2104  89E9              ; IN:  hl - adres in VRAM
2105  89E9              ; OUT: de - address in Collision Map
2106  89E9              ;      a - byte from Collision Map
2107  89E9              CMAP_GET_BYTE:
2108  89E9 E5           	push hl						; save hl - VRAM address						;89e9	e5
2109  89EA 11 00 08     	ld de,$0800					; offset beetween VRAM and Collision Map Data	;89ea	11 00 08
2110  89ED 19           	add hl,de					; hl - addres in CMap for this VRAM 			;89ed	19
2111  89EE 7E           	ld a,(hl)					; a - byte from Collision Map					;89ee	7e
2112  89EF EB           	ex de,hl					; de - addres in CMap for this VRAM				;89ef	eb
2113  89F0 E1           	pop hl						; hl - addres in VRAM							;89f0	e1
2114  89F1 C9           	ret							; ----------- End of Proc ---------------------	;89f1	c9
2115  89F2
2116  89F2              ;***********************************************************************************************
2117  89F2              ; Test if Player can Move Up
2118  89F2              ; Player can move up if no wall is above current position and player sprite is not shifted (2px)
2119  89F2              ; IN: c - 1 if shifted (2px) sprite is used
2120  89F2              ; OUT: b - move direction (0 if Playar CAN move Up, unchanged if CAN'T)
2121  89F2              TEST_MOVE_UP:
2122  89F2 79           	ld a,c						; a - Sprite Shifted Flag						;89f2	79
2123  89F3 B7           	or a						; is Player in shifted position					;89f3	b7
2124  89F4 C0           	ret nz						; yes - cant't move UP	-----------------------	;89f4	c0
2125  89F5              ; -- non-shifted Player sprite - Player can move UP or DOWN if no Wall there
2126  89F5 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;89f5	cd e9 89
2127  89F8 CB 47        	bit 0,a						; is Wall above ?								;89f8	cb 47
2128  89FA C8           	ret z						; yes - can't move UP							;89fa	c8
2129  89FB              ; -- no Wall above - Player can move UP
2130  89FB 06 00        	ld b,0						; set Player Move Direction Up					;89fb	06 00
2131  89FD C9           	ret							; -------- End of Proc (b=0) ------------------	;89fd	c9
2132  89FE
2133  89FE              ;***********************************************************************************************
2134  89FE              ; Test if Player can Move Down
2135  89FE              ; Player can move down if no wall is below current position and player sprite is not shifted (2px)
2136  89FE              ; IN: c - 1 if shifted (2px) sprite is used
2137  89FE              ; OUT: b - move direction (2 if Playar CAN move Down, unchanged if CAN'T)
2138  89FE              TEST_MOVE_DOWN:
2139  89FE 79           	ld a,c						; a - Sprite Shifted Flag						;89fe	79
2140  89FF B7           	or a						; is Player in shifted position					;89ff	b7
2141  8A00 C0           	ret nz						; yes - cant't move UP							;8a00	c0
2142  8A01              ; -- non-shifted Player sprite - Player can move UP or DOWN if no Wall there
2143  8A01 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8a01	cd e9 89
2144  8A04 CB 57        	bit 2,a						; is Wall below ?								;8a04	cb 57
2145  8A06 C8           	ret z						; yes - can't move UP -------------------------	;8a06	c8
2146  8A07              ; -- no Wall below - Player can move DOWN
2147  8A07 06 02        	ld b,2						; set Player Move Direction Down				;8a07	06 02
2148  8A09 C9           	ret							; -------- End of Proc (b=2) ------------------	;8a09	c9
2149  8A0A
2150  8A0A
2151  8A0A              ;***********************************************************************************************
2152  8A0A              ; Test if Player can Move Right
2153  8A0A              ; Player can move Right if no wall is on right side from current position and player sprite is not shifted (2px)
2154  8A0A              ; IN: c - 1 if shifted (2px) sprite is used
2155  8A0A              ; OUT: b - move direction (1 if Playar CAN move Right, unchanged if CAN'T)
2156  8A0A              TEST_MOVE_RIGHT:
2157  8A0A 79           	ld a,c						; a - Sprite Shifted Flag						;8a0a	79
2158  8A0B B7           	or a						; is Player in shifted position					;8a0b	b7
2159  8A0C C0           	ret nz						; yes - cant't move RIGHT						;8a0c	c0
2160  8A0D              ; -- non-shifted Player sprite - Player can move LEFT or RIGHT if no Wall there
2161  8A0D CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8a0d	cd e9 89
2162  8A10 CB 4F        	bit 1,a						; is Wall on the right ?						;8a10	cb 4f
2163  8A12 C8           	ret z						; yes - can't move RIHGT ----------------------	;8a12	c8
2164  8A13              ; -- no Wall on the right - Player can move RIGHT
2165  8A13 06 01        	ld b,1						; set Player Move Direction Right				;8a13	06 01
2166  8A15 C9           	ret							; -------- End of Proc (b=1) ------------------	;8a15	c9
2167  8A16
2168  8A16              ;***********************************************************************************************
2169  8A16              ; Test if Player can Move Left
2170  8A16              ; Player can move Left if no wall is on left side from current position and player sprite is not shifted (2px)
2171  8A16              ; IN: c - 1 if shifted (2px) sprite is used
2172  8A16              ; OUT: b - move direction (3 if Playar CAN move Left, unchanged if CAN'T)
2173  8A16              TEST_MOVE_LEFT:
2174  8A16 79           	ld a,c						; a - Sprite Shifted Flag						;8a16	79
2175  8A17 B7           	or a						; is Player in shifted position					;8a17	b7
2176  8A18 C0           	ret nz						; yes - cant't move LEFT ----------------------	;8a18	c0
2177  8A19              ; -- non-shifted Player sprite - Player can move LEFT or RIGHT if no Wall there
2178  8A19 CD E9 89     	call CMAP_GET_BYTE			; a - byte from Collision Map					;8a19	cd e9 89
2179  8A1C CB 5F        	bit 3,a						; is Wall on the left ?							;8a1c	cb 5f
2180  8A1E C8           	ret z						; yes - can't move LEFT							;8a1e	c8
2181  8A1F              ; -- no Wall on the right - Player can move RIGHT
2182  8A1F 06 03        	ld b,3						; set Player Move Direction Left				;8a1f	06 03
2183  8A21 C9           	ret							; -------- End of Proc (b=3) ------------------	;8a21	c9
2184  8A22
2185  8A22
2186  8A22
2187  8A22              ;***********************************************************************************************
2188  8A22              ;
2189  8A22              ;   G A M E    L O O P  -  D R A W   F R E E Z E D   G H O S T S
2190  8A22              ;
2191  8A22              ;***********************************************************************************************
2192  8A22              GL_DRAW_FREEZED_GHOSTS
2193  8A22              ; --
2194  8A22 3A 16 80     	ld a,(GHOSTS_DRAW_TIMER)	; Ghosts Redraw Timer value						;8a22	3a 16 80
2195  8A25 3D           	dec a						; decrement value and check if 0				;8a25	3d
2196  8A26 32 16 80     	ld (GHOSTS_DRAW_TIMER),a	; store new value								;8a26	32 16 80
2197  8A29 C0           	ret nz						; no - don't draw in this Game Loop iteration	;8a29	c0
2198  8A2A              .BLUE1
2199  8A2A              ; -- check if Ghost Blue 1 is Freezed
2200  8A2A 3A 1C 80     	ld a,(GHOST_B1.FREEZE)		; Ghost Blue 1 Freeze Timer						;8a2a	3a 1c 80
2201  8A2D B7           	or a						; check if timer > 0 - Ghost is Freezed			;8a2d	b7
2202  8A2E CA 37 8A     	jp z,.BLUE2					; no - check Ghost Blue 2						;8a2e	ca 37 8a
2203  8A31              ; -- Ghost Blue 1 is Freezed - draw it on screen
2204  8A31 2A 18 80     	ld hl,(GHOST_B1.VADR)		; hl - destination VRAM address of Ghost Blue 1	;8a31	2a 18 80
2205  8A34 CD EA 83     	call DRAW_GHOST_BLUE		; draw Ghost Blue sprite on screen				;8a34	cd ea 83
2206  8A37              .BLUE2
2207  8A37              ; -- check if Ghost Blue 2 is alive
2208  8A37 3A 21 80     	ld a,(GHOST_B2.FREEZE)		; Ghost Blue 2 Freeze Timer						;8a37	3a 21 80
2209  8A3A B7           	or a						; check if timer > 0 - Ghost is Freezed			;8a3a	b7
2210  8A3B CA 44 8A     	jp z,.RED1					; no - check Ghost Red 1						;8a3b	ca 44 8a
2211  8A3E              ; -- Ghost Blue 2 is Freezed - draw it on screen
2212  8A3E 2A 1D 80     	ld hl,(GHOST_B2.VADR)		; hl - destination VRAM address	Ghost Blue 2	;8a3e	2a 1d 80
2213  8A41 CD EA 83     	call DRAW_GHOST_BLUE		; draw Ghost Blue sprite on screen				;8a41	cd ea 83
2214  8A44              .RED1
2215  8A44              ; -- check if Ghost Red 1 is alive
2216  8A44 3A 26 80     	ld a,(GHOST_R1.FREEZE)		; Ghost Red 1 Freeze Timer						;8a44	3a 26 80
2217  8A47 B7           	or a						; check if timer > 0 - Ghost is Freezed			;8a47	b7
2218  8A48 CA 51 8A     	jp z,.RED2					; no - check Ghost Red 2						;8a48	ca 51 8a
2219  8A4B              ; -- Ghost Red 1 is Freezed - draw it on screen
2220  8A4B 2A 22 80     	ld hl,(GHOST_R1.VADR)		; hl - destination VRAM address Ghost Red 1		;8a4b	2a 22 80
2221  8A4E CD F7 83     	call DRAW_GHOST_RED			; draw Ghost Red sprite on screen				;8a4e	cd f7 83
2222  8A51              .RED2
2223  8A51              ; -- check if Ghost Red 2 (A) is alive
2224  8A51 3A 2B 80     	ld a,(GHOST_R2.FREEZE)		; Ghost Red 2 Freeze Timer						;8a51	3a 2b 80
2225  8A54 B7           	or a						; check if timer > 0 - Ghost is Freezed			;8a54	b7
2226  8A55 C8           	ret z						; no - -------- End of Proc ---------------		;8a55	c8
2227  8A56              ; -- Ghost Red 2 is Freezed - draw it on screen
2228  8A56 2A 27 80     	ld hl,(GHOST_R2.VADR)		; hl - destination VRAM address Ghost Red 2		;8a56	2a 27 80
2229  8A59 CD FD 83     	call DRAW_GHOST_REDA		; draw Ghost Red A variant sprite on screen		;8a59	cd fd 83
2230  8A5C C9           	ret							; ------------- End of Proc ---------------		;8a5c	c9
2231  8A5D
2232  8A5D
2233  8A5D
2234  8A5D
2235  8A5D              ;***********************************************************************************************
2236  8A5D              ;
2237  8A5D              ;   G A M E    L O O P  -  D R A W   D O T S   A N D   P I L L S
2238  8A5D              ;
2239  8A5D              ;***********************************************************************************************
2240  8A5D              GL_DRAW_DOTS_PILLS
2241  8A5D 3A 15 80     	ld a,(DOTS_DRAW_TIMER)		; Dots and Pills Update Timer value				;8a5d	3a 15 80
2242  8A60 3D           	dec a						; decrement value and check if 0				;8a60	3d
2243  8A61 32 15 80     	ld (DOTS_DRAW_TIMER),a		; store new value								;8a61	32 15 80
2244  8A64 C0           	ret nz						; no - don't update in this Game Loop iteration	;8a64	c0
2245  8A65
2246  8A65              DRAW_DOTS_PILLS:
2247  8A65 21 60 70     	ld hl,VRAM+(3*32)+0			; screen coord (0,3) [$7060]					;8a65	21 60 70
2248  8A68 AF           	xor a						; initialy clear flag - none of Dots left		;8a68	af
2249  8A69 32 EC 8A     	ld (DOTS_LEFT_FLAG),a		; clear flag - 0 means Level Completed			;8a69	32 ec 8a
2250  8A6C 11 60 78     	ld de,CMAP_ADR+(3*32)+0		; address in Collision Map for (0,3)px [$7860]	;8a6c	11 60 78
2251  8A6F 3E 09        	ld a,9						; a - number of rows to check/draw Dots, Pills	;8a6f	3e 09
2252  8A71              DDP_NEXT_ROW
2253  8A71 F5           	push af						; save af 										;8a71	f5
2254  8A72 E5           	push hl						; save hl - screen coord						;8a72	e5
2255  8A73 D5           	push de						; save de - CMap coord							;8a73	d5
2256  8A74 06 1F        	ld b,31						; 31 bytes in line to process/draw				;8a74	06 1f
2257  8A76              DDP_NEXT_BYTE
2258  8A76              ; -- test byte from Collision Map
2259  8A76 1A           	ld a,(de)					; byte from Collision Map						;8a76	1a
2260  8A77 E6 C0        	and %11000000				; check any Dot, Power Pills or Heart is here	;8a77	e6 c0
2261  8A79 CA BB 8A     	jp z,DDP_NEXT				; no - move on to next byte						;8a79	ca bb 8a
2262  8A7C              ; -- some bits are set - check if it is Heart (both bits 7 and 6 are set)
2263  8A7C FE C0        	cp  %11000000				; check if this is Heart						;8a7c	fe c0
2264  8A7E C2 84 8A     	jp nz,DDP_TEST_DOT			; no - check if is Dot or Power Pill			;8a7e	c2 84 8a
2265  8A81 C3 BB 8A     	jp DDP_NEXT					; yes - move on to next byte					;8a81	c3 bb 8a
2266  8A84
2267  8A84              ; -- there is Dot or Power Pill - check if it's Dot
2268  8A84              DDP_TEST_DOT:
2269  8A84 CB 7F        	bit 7,a						; check Dot Bit (7) is set						;8a84	cb 7f
2270  8A86 CA 90 8A     	jp z,DDP_TEST_PILL			; no - check if it's Power Pill					;8a86	ca 90 8a
2271  8A89
2272  8A89              DDP_DRAW_DOT
2273  8A89              ; -- found Dot at these coordinates, hl - VRAM address
2274  8A89 7E           	ld a,(hl)					; a - byte from screen							;8a89	7e
2275  8A8A F6 01        	or %00000001				; add Yellow pixel [-][-][-][X]					;8a8a	f6 01
2276  8A8C 77           	ld (hl),a					; draw back on screen							;8a8c	77
2277  8A8D C3 B6 8A     	jp DDP_NEXT_SETFLAG			; set Dots Left Flag and move on 				;8a8d	c3 b6 8a
2278  8A90
2279  8A90              ; -- there is Power Pill - make sure it is
2280  8A90              DDP_TEST_PILL:
2281  8A90 CB 77        	bit 6,a						; check Power Pill Bit (6) is set				;8a90	cb 77
2282  8A92 CA B6 8A     	jp z,DDP_NEXT_SETFLAG		; no - set Dots Left Flag and move on 	 		;8a92	ca b6 8a
2283  8A95
2284  8A95              ; -- found Power Pill at these coordinates
2285  8A95 E5           	push hl						; save hl - VRAM address						;8a95	e5
2286  8A96 D5           	push de						; save de - CMap address						;8a96	d5
2287  8A97 C5           	push bc						; save bc - b is byte-in-line counter			;8a97	c5
2288  8A98              ; -- check Pill Animate Flag to determine which Pattern use in this Game Loop iteration
2289  8A98 3A ED 8A     	ld a,(PILLS_ANIM_FLAG)		; Pills Animate Flag 							;8a98	3a ed 8a
2290  8A9B B7           	or a						; should draw alternate Pattern					;8a9b	b7
2291  8A9C CA A5 8A     	jp z,DRAW_POWER_PILL_BASE	; no - draw Base Pattern in this Game Loop 		;8a9c	ca a5 8a
2292  8A9F
2293  8A9F              DRAW_POWER_PILL_ALT
2294  8A9F              ; -- set alternate pattern to use and draw Power Pill
2295  8A9F 01 04 11     	ld bc,$1104					; b = [-][X][-][X], c = [-][-][X][-]			;8a9f	01 04 11
2296  8AA2 C3 A8 8A     	jp DRAW_POWER_PILL			; draw Power Pill								;8aa2	c3 a8 8a
2297  8AA5              DRAW_POWER_PILL_BASE:
2298  8AA5              ; -- set base pattern to use and draw Power Pill
2299  8AA5 01 11 04     	ld bc,$0411					; b = [-][-][X][-], c = [-][X][-][X]			;8aa5	01 11 04
2300  8AA8
2301  8AA8              ;***********************************************************************************************
2302  8AA8              ; Draw Power Pill
2303  8AA8              ; IN: hl - VRAM address (in base line)						[X][ ][X]			[ ][X][ ]
2304  8AA8              ;     b - pattern for 1st and 3rd line to draw				[ ][X][ ]			[X][ ][X]
2305  8AA8              ;     c - pattern for 2nd (base) line to draw				[X][ ][X]			[ ][X][ ]
2306  8AA8              DRAW_POWER_PILL:
2307  8AA8 11 20 00     	ld de,32					; 32 bytes per screen line						;8aa8	11 20 00
2308  8AAB B7           	or a						; clear Carry flag								;8aab	b7
2309  8AAC ED 52        	sbc hl,de					; move VRAM pointer 1 line up					;8aac	ed 52
2310  8AAE 70           	ld (hl),b					; draw b pattern on screen 						;8aae	70
2311  8AAF 19           	add hl,de					; move VRAM pointer to base line				;8aaf	19
2312  8AB0 71           	ld (hl),c					; draw c pattern on screen						;8ab0	71
2313  8AB1 19           	add hl,de					; move VRAM pointer 1 line down					;8ab1	19
2314  8AB2 70           	ld (hl),b					; draw b pattern on screen 						;8ab2	70
2315  8AB3 C1           	pop bc						; restore bc - b is byte-in-line counter		;8ab3	c1
2316  8AB4 D1           	pop de						; restore de - CMap address						;8ab4	d1
2317  8AB5 E1           	pop hl						; restore hl - VRAM address						;8ab5	e1
2318  8AB6
2319  8AB6              DDP_NEXT_SETFLAG:
2320  8AB6 3E 01        	ld a,1						; at least 1 Dot left 							;8ab6	3e 01
2321  8AB8 32 EC 8A     	ld (DOTS_LEFT_FLAG),a		; set Dots Left Flag - Level NOT Completed yet	;8ab8	32 ec 8a
2322  8ABB
2323  8ABB              ; -- move to next line
2324  8ABB              DDP_NEXT
2325  8ABB 23           	inc hl						; next VRAM address								;8abb	23
2326  8ABC 13           	inc de						; next offscreen buffer address					;8abc	13
2327  8ABD 05           	dec b						; check if all 31 bytes processed				;8abd	05
2328  8ABE C2 76 8A     	jp nz,DDP_NEXT_BYTE			; no - process next byte						;8abe	c2 76 8a
2329  8AC1
2330  8AC1              ; -- 1 line processed - calculate next line coordinates
2331  8AC1 E1           	pop hl						; hl - address in Collision Map					;8ac1	e1
2332  8AC2 11 E0 00     	ld de,7*32					; 7 lines * 32 bytes per line					;8ac2	11 e0 00
2333  8AC5 19           	add hl,de					; hl - 7 lines below in CMap					;8ac5	19
2334  8AC6 EB           	ex de,hl					; de - new address in Collision Map, hl - 7*32	;8ac6	eb
2335  8AC7 C1           	pop bc						; bc - VRAM address								;8ac7	c1
2336  8AC8 09           	add hl,bc					; hl - 7 lines below in VRAM					;8ac8	09
2337  8AC9 F1           	pop af						; a - number of rows to draw					;8ac9	f1
2338  8ACA 3D           	dec a						; check if all 9 rows already drawn				;8aca	3d
2339  8ACB C2 71 8A     	jp nz,DDP_NEXT_ROW			; no - draw next row at new coordinates			;8acb	c2 71 8a
2340  8ACE
2341  8ACE              ; -- toggle Pill Animate Flag to draw alternate Pattern in next Game Loop iteration
2342  8ACE 3A ED 8A     	ld a,(PILLS_ANIM_FLAG)		; Pill Animate Flag 							;8ace	3a ed 8a
2343  8AD1 B7           	or a						; is flag set?									;8ad1	b7
2344  8AD2 CA D9 8A     	jp z,DDP_SET_ANIM_FLAG		; no - set Pill Animate Flag					;8ad2	ca d9 8a
2345  8AD5              ; -- flag is set so clear it
2346  8AD5              DDP_CLEAR_ANIM_FLAG
2347  8AD5 AF           	xor a						; 0 value for Pill Animate Flag 				;8ad5	af
2348  8AD6 C3 DA 8A     	jp DDP_STORE_ANIM_FLAG		; store new value								;8ad6	c3 da 8a
2349  8AD9              DDP_SET_ANIM_FLAG
2350  8AD9 3C           	inc a						; 1 value for Pill Animate Flag					;8ad9	3c
2351  8ADA              DDP_STORE_ANIM_FLAG
2352  8ADA 32 ED 8A     	ld (PILLS_ANIM_FLAG),a		; store new Flag value							;8ada	32 ed 8a
2353  8ADD
2354  8ADD              ; -- check if any Dots left to Eat - if none then Level is Completed
2355  8ADD 3A EC 8A     	ld a,(DOTS_LEFT_FLAG)		; Dots Left Flag 								;8add	3a ec 8a
2356  8AE0 B7           	or a						; has all Dots been Eaten ?						;8ae0	b7
2357  8AE1 C0           	ret nz						; no ---------- End of Proc -------------------	;8ae1	c0
2358  8AE2
2359  8AE2              ; -- All Dots has been Eaten - Level Up
2360  8AE2              LEVEL_UP
2361  8AE2 3A 03 80     	ld a,(LEVEL)				; current Game Level 							;8ae2	3a 03 80
2362  8AE5 3C           	inc a						; increment - next Level to Play				;8ae5	3c
2363  8AE6 32 03 80     	ld (LEVEL),a				; store as new Level to Play					;8ae6	32 03 80
2364  8AE9 C3 32 81     	jp GAME_LEVEL_INIT			; start over and Play new Level					;8ae9	c3 32 81
2365  8AEC
2366  8AEC              ;***********************************************************************************************
2367  8AEC              ; -- local variables
2368  8AEC 00           DOTS_LEFT_FLAG	defb	0		; 0 - all Dots are Eaten, 1 - some Dots left	;8aec	00
2369  8AED 00           PILLS_ANIM_FLAG	defb	0		; 0 - use Base Pattern, 1 - use Alt Pattern		;8aed	00
2370  8AEE
2371  8AEE
2372  8AEE              ;***********************************************************************************************
2373  8AEE              ; Clear screen and draw static graphics - Walls, Dots and Pills
2374  8AEE              DRAW_LEVEL_SCREEN:
2375  8AEE CD C5 8B     	call DRAW_MAZE_WALLS_CLS	; clear screen and draw Maze Walls				;8aee	cd c5 8b
2376  8AF1 CD 65 8A     	call DRAW_DOTS_PILLS		; draw Dots and Pills							;8af1	cd 65 8a
2377  8AF4 C9           	ret							; ------------- End of Proc -------------------	;8af4	c9
2378  8AF5
2379  8AF5              ;***********************************************************************************************
2380  8AF5              ; Mark Walls/Passages in Collision Map
2381  8AF5              ; 4 low bits of byte in Collision Map defines if Player/Ghost can move in any direction.
2382  8AF5              ; Bit 0 - Up direction
2383  8AF5              ; Bit 1 - Right direction
2384  8AF5              ; Bit 2 - Down direction
2385  8AF5              ; Bit 3 - Left direction
2386  8AF5              ; If bit is set (1) Player/Ghost CAN move in that direction
2387  8AF5              ; If bit is not set (0) there is a Wall and Player/Ghost CAN'T move in that direction
2388  8AF5              CMAP_MARK_PASSAGES
2389  8AF5              ; -- mark Horizontal Passages (player can move Left and Right)
2390  8AF5 21 A9 8D     	ld hl,SDB_H_PASSAGES		; Screen Data Block - Horizontal Passages		;8af5	21 a9 8d
2391  8AF8              .NEXT_LINE:
2392  8AF8 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8af8	cd 26 8c
2393  8AFB 7E           	ld a,(hl)					; a - passage width (in bytes)					;8afb	7e
2394  8AFC 23           	inc hl						; address of next Line VRAM address 			;8afc	23
2395  8AFD B7           	or a						; check if length = 0 (end of data)				;8afd	b7
2396  8AFE CA 11 8B     	jp z,CMAP_MARK_V_PASS		; yes - mark next Screen Data Block				;8afe	ca 11 8b
2397  8B01 E5           	push hl						; address of next Line VRAM address in SDB 		;8b01	e5
2398  8B02 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8b02	21 00 08
2399  8B05 19           	add hl,de					; hl - destination adress in CMap buffer		;8b05	19
2400  8B06              .NEXT_BYTE:
2401  8B06 36 0A        	ld (hl),%00001010			; mark allowed Move Left (bit 1) and Right (bit 3)	;8b06	36 0a
2402  8B08 23           	inc hl						; address of next byte in CMap buffer			;8b08	23
2403  8B09 3D           	dec a						; check if all bytes marked already				;8b09	3d
2404  8B0A C2 06 8B     	jp nz,.NEXT_BYTE			; no - mark next byte in this passage			;8b0a	c2 06 8b
2405  8B0D E1           	pop hl						; address of next Line VRAM address in SDB 		;8b0d	e1
2406  8B0E C3 F8 8A     	jp .NEXT_LINE				; repeat for all passages defined in SDB		;8b0e	c3 f8 8a
2407  8B11
2408  8B11              ; -- mark Vertical Passages (60px height) by adding Passage Bits Up and Down
2409  8B11              CMAP_MARK_V_PASS
2410  8B11 21 91 8D     	ld hl,SDB_V_PASSAGES		; Screen Data Block - Vertical Passages			;8b11	21 91 8d
2411  8B14              .NEXT_COLUMN
2412  8B14 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8b14	cd 26 8c
2413  8B17 7A           	ld a,d						; check if 0 - end of Screen Data Block			;8b17	7a
2414  8B18 B7           	or a																		;8b18	b7
2415  8B19 CA 39 8B     	jp z,CMAP_MARK_OTHER		; yes - mark next Screen Data Block				;8b19	ca 39 8b
2416  8B1C E5           	push hl						; address of next column VRAM address 			;8b1c	e5
2417  8B1D 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8b1d	21 00 08
2418  8B20 19           	add hl,de					; hl - destination adress in CMap buffer				;8b20	19
2419  8B21 11 20 00     	ld de,32					; 32 bytes per screen line						;8b21	11 20 00
2420  8B24 06 3C        	ld b,60						; 60px - Vertical Passage Height				;8b24	06 3c
2421  8B26              .NEXT_BYTE
2422  8B26              ; -- if byte in Collision Map already has set bit 1 or 3 by above routine
2423  8B26              ; it means that there were set Walls Up and Down so we will skip such byte
2424  8B26 7E           	ld a,(hl)					; a - definition already in Collision Map		;8b26	7e
2425  8B27 E6 3F        	and %00111111				; is defined (Left & Right) already? 			;8b27	e6 3f
2426  8B29 C2 30 8B     	jp nz,.SKIP					; yes - skip this screen line					;8b29	c2 30 8b
2427  8B2C              ; -- no direction bits are set - can be Dot (Bit 7) or Power Pill (Bit 6)
2428  8B2C 7E           	ld a,(hl)					; a - existing definition from Collision Map	;8b2c	7e
2429  8B2D F6 05        	or %00000101				; mark allowed Move Up (bit 0) and Down (bit 2)	;8b2d	f6 05
2430  8B2F 77           	ld (hl),a					; store definition into Collision Map			;8b2f	77
2431  8B30              .SKIP
2432  8B30 19           	add hl,de					; add 32 bytes per line - new screen line		;8b30	19
2433  8B31 05           	dec b						; check if all 60 lines in column processed 	;8b31	05
2434  8B32 C2 26 8B     	jp nz,.NEXT_BYTE			; no - process next screen line in this column	;8b32	c2 26 8b
2435  8B35 E1           	pop hl						; address of next column VRAM address 			;8b35	e1
2436  8B36 C3 14 8B     	jp .NEXT_COLUMN				; repeat for all columns defined in SDB 		;8b36	c3 14 8b
2437  8B39
2438  8B39              ; Routines above defined only those coordinates where it was clear Passage (Horizontal or Vertical).
2439  8B39              ; Horizontal passages were defined as allowed moves Left & Right and not allowed moves (Walls) Up & Down
2440  8B39              ; Similarly Vertical Passages allowed moves Up & Down and set Walls Left & Right at the same time
2441  8B39              ; This routine marks in Collision Map bytes with definitions different than above
2442  8B39              CMAP_MARK_OTHER
2443  8B39 21 F4 8D     	ld hl,SDB_OTHER_PASSAGES	; Screen Data Block - Other Passages			;8b39	21 f4 8d
2444  8B3C              .NEXT_BYTE
2445  8B3C CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8b3c	cd 26 8c
2446  8B3F 7E           	ld a,(hl)					; a - Passage/Wall definition					;8b3f	7e
2447  8B40 23           	inc hl						; address of next data VRAM address 			;8b40	23
2448  8B41 B7           	or a						; check if 0 - end of Screen Data Block			;8b41	b7
2449  8B42 C8           	ret z						; yes ------------- End of Proc	-----------		;8b42	c8
2450  8B43 E5           	push hl						; address of next data VRAM address 			;8b43	e5
2451  8B44 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8b44	21 00 08
2452  8B47 19           	add hl,de					; hl - destination adress in CMap Buffer		;8b47	19
2453  8B48 47           	ld b,a						; b - byte data with new definitions			;8b48	47
2454  8B49 7E           	ld a,(hl)					; a - existing data from CMap buffer			;8b49	7e
2455  8B4A E6 C0        	and %11000000				; preserve Dots and Pills (clear Pass/Walls)	;8b4a	e6 c0
2456  8B4C B0           	or b						; add definitions from SDB						;8b4c	b0
2457  8B4D 77           	ld (hl),a					; store new data into Collision Map				;8b4d	77
2458  8B4E E1           	pop hl						; address of next data VRAM address 			;8b4e	e1
2459  8B4F C3 3C 8B     	jp .NEXT_BYTE				; repeat for all address+byte defined in SDB	;8b4f	c3 3c 8b
2460  8B52
2461  8B52              ;***********************************************************************************************
2462  8B52              ; Fill Collision Map with predefined Dots and Power Pills
2463  8B52              ; Clear data in Collision Map and mark all Dots and Power Pills
2464  8B52              CMAP_DOTS_PILLS
2465  8B52              ; -- clear CMap buffer	7800 .. 7fff
2466  8B52 21 00 78     	ld hl,CMAP_ADR				; src - Collision Map buffer					;8b52	21 00 78
2467  8B55 11 01 78     	ld de,CMAP_ADR+1			; dst - next byte in buffer						;8b55	11 01 78
2468  8B58 01 FF 07     	ld bc,2047					; cnt - 2047 bytes to clear						;8b58	01 ff 07
2469  8B5B 36 00        	ld (hl),$00					; clear Collision Map byte						;8b5b	36 00
2470  8B5D ED B0        	ldir						; fill buffer with 0 value						;8b5d	ed b0
2471  8B5F
2472  8B5F              ; -- mark Grid of Dots which Payer will Eat in game - 9 roww by 12 columns (108 in total)
2473  8B5F              CMAP_MARK_DOTS
2474  8B5F 21 41 8D     	ld hl,SDB_DOTS_GRID			; Screen Data Block - Dots' Grid				;8b5f	21 41 8d
2475  8B62 01 E0 00     	ld bc,7*32					; vertical space beetween Dots - 7 lines 		;8b62	01 e0 00
2476  8B65              .NEXT_COLUMN
2477  8B65 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8b65	cd 26 8c
2478  8B68 7A           	ld a,d						; check if 0 - end of Screen Data Block			;8b68	7a
2479  8B69 B7           	or a																		;8b69	b7
2480  8B6A CA 80 8B     	jp z,CMAP_CLEAR_DOTS		; yes - mark next Screen Data Block				;8b6a	ca 80 8b
2481  8B6D E5           	push hl						; address of next Dot VRAM address 				;8b6d	e5
2482  8B6E 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8b6e	21 00 08
2483  8B71 19           	add hl,de					; hl - destination adress in CMap				;8b71	19
2484  8B72 D1           	pop de						; de - address of next Dot to mark				;8b72	d1
2485  8B73 3E 09        	ld a,9						; number of Dot rows to mark 					;8b73	3e 09
2486  8B75              .NEXT_DOT
2487  8B75 36 80        	ld (hl),%10000000			; Dot Bit (7) - mark Dot is here 				;8b75	36 80
2488  8B77 09           	add hl,bc					; add 7 lines to destination address			;8b77	09
2489  8B78 3D           	dec a						; check if all 9 Dots marked already			;8b78	3d
2490  8B79 C2 75 8B     	jp nz,.NEXT_DOT				; no - mark next Dot in this column				;8b79	c2 75 8b
2491  8B7C EB           	ex de,hl					; hl - address of next Dot data 				;8b7c	eb
2492  8B7D C3 65 8B     	jp .NEXT_COLUMN				; repeat for all columns defined in SDB			;8b7d	c3 65 8b
2493  8B80
2494  8B80              ; -- clear 14 unwanted Dots marked by above routine
2495  8B80              CMAP_CLEAR_DOTS:
2496  8B80 21 5B 8D     	ld hl,SDB_DOTS_CLR			; Screen Data Block - Dots Unwanted				;8b80	21 5b 8d
2497  8B83              .NEXT:
2498  8B83 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8b83	cd 26 8c
2499  8B86 7A           	ld a,d						; check if 0 - end of Screen Data Block			;8b86	7a
2500  8B87 B7           	or a																		;8b87	b7
2501  8B88 CA 97 8B     	jp z,CMAP_MARK_DOTS_EX		; yes - mark next Screen Data Block				;8b88	ca 97 8b
2502  8B8B E5           	push hl						; address of next VRAM address to clear			;8b8b	e5
2503  8B8C 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8b8c	21 00 08
2504  8B8F 19           	add hl,de					; hl - destination adress in CMap buffer		;8b8f	19
2505  8B90 EB           	ex de,hl					; de - destination adress in buffer				;8b90	eb
2506  8B91 E1           	pop hl						; address of next VRAM address to clear			;8b91	e1
2507  8B92 AF           	xor a						; clear all Bits - nothing is here				;8b92	af
2508  8B93 12           	ld (de),a					; clear all Bits in Collision Map				;8b93	12
2509  8B94 C3 83 8B     	jp .NEXT					; clear next byte defined in SDB				;8b94	c3 83 8b
2510  8B97
2511  8B97              ; -- mark Extra 6 Dots placed outside of Grid constrained coordinates
2512  8B97              CMAP_MARK_DOTS_EX:
2513  8B97 21 79 8D     	ld hl,SDB_DOTS_EXTRA		; Screen Data Block - Dots Extra				;8b97	21 79 8d
2514  8B9A              .NEXT
2515  8B9A CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8b9a	cd 26 8c
2516  8B9D 7A           	ld a,d						; check if 0 - end of Screen Data Block			;8b9d	7a
2517  8B9E B7           	or a																		;8b9e	b7
2518  8B9F CA AF 8B     	jp z,CMAP_MARK_PILLS		; yes - mark next Screen Data Block				;8b9f	ca af 8b
2519  8BA2 E5           	push hl						; address of next Dot VRAM address 				;8ba2	e5
2520  8BA3 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8ba3	21 00 08
2521  8BA6 19           	add hl,de					; hl - destination adress in CMap buffer		;8ba6	19
2522  8BA7 EB           	ex de,hl					; de - destination adress in buffer				;8ba7	eb
2523  8BA8 E1           	pop hl						; hl - address of next Dot to draw				;8ba8	e1
2524  8BA9 3E 80        	ld a,%10000000				; Dot Bit (7) - mark Dot is here 				;8ba9	3e 80
2525  8BAB 12           	ld (de),a					; mark Dot in Collision Map						;8bab	12
2526  8BAC C3 9A 8B     	jp .NEXT					; mark next Dot defined in SDB					;8bac	c3 9a 8b
2527  8BAF
2528  8BAF              ; -- mark 4 Power Pills placed at each edge of maze
2529  8BAF              CMAP_MARK_PILLS
2530  8BAF 21 87 8D     	ld hl,SDB_POWER_PILLS		; Screen Data Block - Power Pills				;8baf	21 87 8d
2531  8BB2              .NEXT
2532  8BB2 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8bb2	cd 26 8c
2533  8BB5 7A           	ld a,d						; check if 0 - end of Screen Data Block			;8bb5	7a
2534  8BB6 B7           	or a																		;8bb6	b7
2535  8BB7 C8           	ret z						; yes ------------ End of Proc -------------	;8bb7	c8
2536  8BB8 E5           	push hl						; address of next Power Pill VRAM address 			;8bb8	e5
2537  8BB9 21 00 08     	ld hl,$0800					; offset beetween VRAM and Collision Map		;8bb9	21 00 08
2538  8BBC 19           	add hl,de					; hl - destination adress in CMap buffer		;8bbc	19
2539  8BBD EB           	ex de,hl					; de - destination adress in buffer				;8bbd	eb
2540  8BBE E1           	pop hl						; hl - address of next Power Pill to draw		;8bbe	e1
2541  8BBF 3E 40        	ld a,%01000000				; Power Pill Bit (6) - mark Power Pill is here	;8bbf	3e 40
2542  8BC1 12           	ld (de),a					; mark Power Pill in Collision Map				;8bc1	12
2543  8BC2 C3 B2 8B     	jp .NEXT					; mark next Dot defined in SDB					;8bc2	c3 b2 8b
2544  8BC5
2545  8BC5
2546  8BC5              ;***********************************************************************************************
2547  8BC5              ; Clear Screen and draw Horizontal and Verital Walls of Maze defined in Screen Data Blocks
2548  8BC5              DRAW_MAZE_WALLS_CLS:
2549  8BC5 CD 34 8C     	call CLEAR_SCREEN_GFX	; Clear Screen, set MODE 1, Colors 0 				;8bc5	cd 34 8c
2550  8BC8
2551  8BC8              ;***********************************************************************************************
2552  8BC8              ; Draw Horizontal and Verital Walls of Maze defined in Screen Data Blocks
2553  8BC8              DRAW_MAZE_WALLS
2554  8BC8 21 5F 8C     	ld hl,SDB_H_LINES			; Screen Data Block - Horizontal Lines			;8bc8	21 5f 8c
2555  8BCB              .NEXT_LINE
2556  8BCB CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8bcb	cd 26 8c
2557  8BCE 7E           	ld a,(hl)					; a - line length (in bytes)					;8bce	7e
2558  8BCF 23           	inc hl						; address of next Line VRAM address 			;8bcf	23
2559  8BD0 B7           	or a						; check if length = 0 (end of data)				;8bd0	b7
2560  8BD1 CA E0 8B     	jp z,DRAW_H_4PX_LINES		; yes - draw next Screen Data Block				;8bd1	ca e0 8b
2561  8BD4 EB           	ex de,hl					; de - address in SDB, hl - VRAM address		;8bd4	eb
2562  8BD5              .NEXT_BYTE
2563  8BD5 36 55        	ld (hl),$55					; [X][X][X][X] - draw 4 yellow pixels			;8bd5	36 55
2564  8BD7 23           	inc hl						; next VRAM address								;8bd7	23
2565  8BD8 3D           	dec a						; check if all bytes of this line were drawn	;8bd8	3d
2566  8BD9 C2 D5 8B     	jp nz,.NEXT_BYTE			; no - draw next 4 pixels						;8bd9	c2 d5 8b
2567  8BDC EB           	ex de,hl					; hl - address of next Line VRAM address		;8bdc	eb
2568  8BDD C3 CB 8B     	jp .NEXT_LINE				; read and draw next line from SDB				;8bdd	c3 cb 8b
2569  8BE0
2570  8BE0              ;-- draw Horizontal Short (4px) Lines
2571  8BE0              DRAW_H_4PX_LINES:
2572  8BE0 21 98 8C     	ld hl,SDB_H_4PX_LINES		; Screen Data Block - Horizontal Short Lines	;8be0	21 98 8c
2573  8BE3              .NEXT_LINE
2574  8BE3 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8be3	cd 26 8c
2575  8BE6 7A           	ld a,d						; check if 0 - end of Screen Data Block			;8be6	7a
2576  8BE7 B7           	or a																		;8be7	b7
2577  8BE8 CA F1 8B     	jp z,DRAW_V_LINES			; yes - draw next Screen Data Block				;8be8	ca f1 8b
2578  8BEB 3E 55        	ld a,$55					; [X][X][X][X] - 4 yellow pixels				;8beb	3e 55
2579  8BED 12           	ld (de),a					; draw on screen								;8bed	12
2580  8BEE C3 E3 8B     	jp .NEXT_LINE				; read and draw next SHort Line					;8bee	c3 e3 8b
2581  8BF1
2582  8BF1              ; -- draw Vertical Lines
2583  8BF1              DRAW_V_LINES:
2584  8BF1 21 F0 8C     	ld hl,SDB_V_LINES			; Screen Data Block - Vertical Lines			;8bf1	21 f0 8c
2585  8BF4 01 20 00     	ld bc,32					; 32 bytes per screen line						;8bf4	01 20 00
2586  8BF7              .NEXT_LINE
2587  8BF7 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8bf7	cd 26 8c
2588  8BFA 7E           	ld a,(hl)					; line height in pixels							;8bfa	7e
2589  8BFB 23           	inc hl						; address of next Line VRAM address 			;8bfb	23
2590  8BFC B7           	or a						; check if 0 - end of Screen Data Block			;8bfc	b7
2591  8BFD CA 0C 8C     	jp z,DRAW_V_DBL_LINES		; yes - draw next Screen Data Block				;8bfd	ca 0c 8c
2592  8C00 EB           	ex de,hl					; de - address in SDB, hl - VRAM address		;8c00	eb
2593  8C01              .NEXT_BYTE
2594  8C01 36 41        	ld (hl),$41					; [X][-][-][X] - 2 yellow pixels				;8c01	36 41
2595  8C03 09           	add hl,bc					; add 32 bytes per line - next line				;8c03	09
2596  8C04 3D           	dec a						; check if all pixels of this line were drawn	;8c04	3d
2597  8C05 C2 01 8C     	jp nz,.NEXT_BYTE			; no - draw next 2 pixels						;8c05	c2 01 8c
2598  8C08 EB           	ex de,hl					; hl - address of next Line VRAM address		;8c08	eb
2599  8C09 C3 F7 8B     	jp .NEXT_LINE				; read and draw next line from SDB				;8c09	c3 f7 8b
2600  8C0C
2601  8C0C              ; -- draw Double Vertical Lines
2602  8C0C              DRAW_V_DBL_LINES:
2603  8C0C 21 2C 8D     	ld hl,SDB_V_DBL_LINES		; Screen Data Block - Vertical Lines			;8c0c	21 2c 8d
2604  8C0F 0B           	dec bc						; 31 bytes per screen line (1 covered in loop)	;8c0f	0b
2605  8C10              .NEXT_LINE:
2606  8C10 CD 26 8C     	call READ_SDB_VADR			; de - VRAM destination address 				;8c10	cd 26 8c
2607  8C13 7E           	ld a,(hl)					; line height in pixels							;8c13	7e
2608  8C14 23           	inc hl						; address of next Line VRAM address 			;8c14	23
2609  8C15 B7           	or a						; check if 0 - end of Screen Data Block			;8c15	b7
2610  8C16 C8           	ret z						; yes ------------ End of Proc -------------	;8c16	c8
2611  8C17 EB           	ex de,hl					; de - address in SDB, hl - VRAM address		;8c17	eb
2612  8C18              .NEXT_BYTE:
2613  8C18 36 40        	ld (hl),$40					; [X][-][-][-] - draw 1 of 2 yellow pixels		;8c18	36 40
2614  8C1A 23           	inc hl						; next VRAM address								;8c1a	23
2615  8C1B 36 01        	ld (hl),$01					; [-][-][-][X] - draw 2 of 2 yellow pixels		;8c1b	36 01
2616  8C1D 09           	add hl,bc					; add 31 bytes per line - next line				;8c1d	09
2617  8C1E 3D           	dec a						; check if all pixels of this line were drawn	;8c1e	3d
2618  8C1F C2 18 8C     	jp nz,.NEXT_BYTE			; no - draw next 2 pixels						;8c1f	c2 18 8c
2619  8C22 EB           	ex de,hl					; hl - address of next Line VRAM address		;8c22	eb
2620  8C23 C3 10 8C     	jp .NEXT_LINE				; read and draw next line from SDB				;8c23	c3 10 8c
2621  8C26
2622  8C26              ;***********************************************************************************************
2623  8C26              ; Read VRAM address form curent item in Screen Data Block
2624  8C26              ; IN: hl - address of current SDB item
2625  8C26              READ_SDB_VADR
2626  8C26 5E           	ld e,(hl)					; e - low byte from memory pointed by hl		;8c26	5e
2627  8C27 23           	inc hl						; hl - address of high byte						;8c27	23
2628  8C28 56           	ld d,(hl)					; d - high byte from memory pointed by hl		;8c28	56
2629  8C29 23           	inc hl						; hl - address of next byte						;8c29	23
2630  8C2A C9           	ret							; ------------ End of Proc --------------------	;8c2a	c9
2631  8C2B
2632  8C2B              ;***********************************************************************************************
2633  8C2B              UPDATE_SHOW_WALLS
2634  8C2B 3A 03 80     	ld a,(LEVEL)				; current Game Level to play					;8c2b	3a 03 80
2635  8C2E FE 03        	cp 3						; check if less than 3 (0, 1 or 2)				;8c2e	fe 03
2636  8C30 F8           	ret m						; yes - ------------- End of Proc -----------	;8c30	f8
2637  8C31              ; -- Level greater than equel to 3
2638  8C31 32 30 80     	ld (SHOW_WALLS_FLAG),a		; set non zero value - hide Maze Walls 			;8c31	32 30 80
2639  8C34
2640  8C34              ;***********************************************************************************************
2641  8C34              ; Clear Screen and set Graphics MODE 1 with default Color Palette
2642  8C34              CLEAR_SCREEN_GFX:
2643  8C34 21 00 70     	ld hl,VRAM					; src - video memory start						;8c34	21 00 70
2644  8C37 11 01 70     	ld de,VRAM+1				; dst - next byte								;8c37	11 01 70
2645  8C3A 01 FF 07     	ld bc,$07ff					; ctn - size of video memory in MODE 1 (gfx)	;8c3a	01 ff 07
2646  8C3D 36 00        	ld (hl),0					; 4 green (background) pixels					;8c3d	36 00
2647  8C3F ED B0        	ldir						; fill VRAM with green pixels					;8c3f	ed b0
2648  8C41              ; -- set VIdeo Graphics Mode 1, Color Palette 0
2649  8C41 3E 08        	ld a,VDG_GFX_COLORS_0		; VDG Gfx MODE 1 Colors (Green/Yellow/Blue/Red)	;8c41	3e 08
2650  8C43 32 00 68     	ld (IOLATCH),a				; store to hardware register					;8c43	32 00 68
2651  8C46 32 6F 80     	ld (IOLATCH_SHADOW),a		; save to shadow register fo future use			;8c46	32 6f 80
2652  8C49 C9           	ret							; ----------------- End of Proc ---------------	;8c49	c9
2653  8C4A
2654  8C4A
2655  8C4A              ;***********************************************************************************************
2656  8C4A              ; Levels Data Definitions
2657  8C4A              ; Parameter for every Level has four values each
2658  8C4A              ; GH_TIMER - Ghosts move in speed inverse proportional to this value
2659  8C4A              ; GA_TIMER - Gost Red A moves in speed inverse proportional to this value
2660  8C4A              ; CMODE_TIME - Duration time of Chase Mode
2661  8C4A              ; GA_SPEEDUP - Value substracted from GA_TIMER in certain time in game - efectively speed up Ghost A move
2662  8C4A              DATA_LEVEL1:
2663  8C4A FF FF 6E 0A  	defb	255, 255, 110, 10			;8c4a	ff ff 6e 0a
2664  8C4E              DATA_LEVEL2:
2665  8C4E DC DC 50 0A  	defb	220, 220,  80, 10			;8c4e	dc dc 50 0a
2666  8C52              DATA_LEVEL3:
2667  8C52 C8 C8 3C 0F  	defb	200, 200,  60, 15			;8c52	c8 c8 3c 0f
2668  8C56              DATA_LEVEL4:
2669  8C56 B4 B4 28 14  	defb	180, 180,  40, 20			;8c56	b4 b4 28 14
2670  8C5A              DATA_LEVEL5:
2671  8C5A 96 96 14 19  	defb	150, 150,  20, 25			;8c5a	96 96 14 19
2672  8C5E
2673  8C5E              ;***********************************************************************************************
2674  8C5E C9           	ret							; Not used code									;8c5e	c9
2675  8C5F              ;***********************************************************************************************
2676  8C5F              ; Screen Data Block - Horizontal Lines
2677  8C5F              ; Every line definition contains 2 members: 16bit VRAM address and 8bit width of line (in bytes)
2678  8C5F              ; Line width in pixels equals 4 * number of bytes.
2679  8C5F              ; Width equals 0 means end of Screen Block Data
2680  8C5F              SDB_H_LINES:
2681  8C5F 00 70        	defw		$7000			; screen coord (0,0)px (0,0)bytes				;8c5f	00 70
2682  8C61 20           	defb		32				; width 128px (32 bytes)						;8c61	20
2683  8C62 E6 70        	defw		$70e6			; screen coord (24,7)px (6,7)bytes				;8c62	e6 70
2684  8C64 05           	defb		5				; width 20px (5 bytes)							;8c64	05
2685  8C65 C9 71        	defw 		$71c9			; screen coord (36,14)px (9,14)bytes			;8c65	c9 71
2686  8C67 0A           	defb		10				; width 40px (10 bytes)							;8c67	0a
2687  8C68 D6 71        	defw		$71d6			; screen coord (88,14)px (22,14)bytes			;8c68	d6 71
2688  8C6A 04           	defb		4				; width 16px (4 bytes)							;8c6a	04
2689  8C6B A7 72        	defw		$72a7			; screen coord (28,21)px (7,21)bytes			;8c6b	a7 72
2690  8C6D 04           	defb		4				; width 16px (4 bytes)							;8c6d	04
2691  8C6E B1 72        	defw		$72b1			; screen coord (68,21)px (17,21)bytes			;8c6e	b1 72
2692  8C70 04           	defb		4				; width 16px (4 bytes)							;8c70	04
2693  8C71 89 73        	defw		$7389			; screen coord (36,28)px (9,28)bytes			;8c71	89 73
2694  8C73 04           	defb		4				; width 16px (4 bytes)							;8c73	04
2695  8C74 8F 73        	defw		$738f			; screen coord (60,28)px (15,28)bytes			;8c74	8f 73
2696  8C76 04           	defb		4				; width 16px (4 bytes)							;8c76	04
2697  8C77 60 74        	defw		$7460			; screen coord (0,35)px (0,35)bytes				;8c77	60 74
2698  8C79 04           	defb		4				; width 16px (4 bytes)							;8c79	04
2699  8C7A 69 74        	defw		$7469			; screen coord (36,35)px (9,35)bytes			;8c7a	69 74
2700  8C7C 0A           	defb		10				; width 40px (10 bytes)							;8c7c	0a
2701  8C7D 49 75        	defw		$7549			; screen coord (36,42)px (9,42)bytes			;8c7d	49 75
2702  8C7F 0A           	defb		10				; width 40px (10 bytes)							;8c7f	0a
2703  8C80 58 75        	defw		$7558			; screen coord (96,42)px (24,42)bytes			;8c80	58 75
2704  8C82 05           	defb		5				; width 20px (5 bytes)							;8c82	05
2705  8C83 21 76        	defw		$7621			; screen coord (4,49)px (1,49)bytes				;8c83	21 76
2706  8C85 03           	defb		3				; width 12px (3 bytes)							;8c85	03
2707  8C86 29 76        	defw		$7629			; screen coord (36,49)px (9,49)bytes			;8c86	29 76
2708  8C88 0A           	defb		10				; width 40px (10 bytes)							;8c88	0a
2709  8C89 03 77        	defw		$7703			; screen coord (12,56)px (3,56)bytes			;8c89	03 77
2710  8C8B 08           	defb		8				; width 32px (8 bytes)							;8c8b	08
2711  8C8C 11 77        	defw		$7711			; screen coord (68,56)px (17,56)bytes			;8c8c	11 77
2712  8C8E 05           	defb		5				; width 20px (5 bytes)							;8c8e	05
2713  8C8F 18 77        	defw		$7718			; screen coord (96,56)px (24,56)bytes			;8c8f	18 77
2714  8C91 05           	defb		5				; width 20px (5 bytes)							;8c91	05
2715  8C92 E0 77        	defw		$77e0			; screen coord (0,63)px (0,63)bytes				;8c92	e0 77
2716  8C94 20           	defb		32				; width 128px (32 bytes)						;8c94	20
2717  8C95 00 00        	defw		$0000			; null address									;8c95	00 00
2718  8C97 00           	defb		0				; ----------- End of Data -----------			;8c97	00
2719  8C98
2720  8C98              ;***********************************************************************************************
2721  8C98              ; Screen Data Block - Horizontal Short (4px) Lines
2722  8C98              ; Every line definition contains 16bit VRAM address where we draw 4 yellow pixels
2723  8C98              ; Address equals 0 means end of Screen Block Data
2724  8C98              SDB_H_4PX_LINES:
2725  8C98
2726  8C98 E3 70        	defw		$70e3			; screen coord (12,7)px (3,7)bytes				;8c98	e3 70
2727  8C9A ED 70        	defw 		$70ed			; screen coord (52,7)px (13,7)bytes				;8c9a	ed 70
2728  8C9C EE 70        	defw		$70ee			; screen coord (56,7)px (14,7)bytes				;8c9c	ee 70
2729  8C9E F1 70        	defw		$70f1			; screen coord (68,7)px (17,7)bytes				;8c9e	f1 70
2730  8CA0 F2 70        	defw		$70f2			; screen coord (72,7)px (18,7)bytes				;8ca0	f2 70
2731  8CA2 F5 70        	defw		$70f5			; screen coord (84,7)px (21,7)bytes				;8ca2	f5 70
2732  8CA4 F9 70        	defw		$70f9			; screen coord (100,7)px (25,7)bytes			;8ca4	f9 70
2733  8CA6 FC 70        	defw		$70fc			; screen coord (112,7)px (28,7)bytes			;8ca6	fc 70
2734  8CA8 C3 71        	defw		$71c3			; screen coord (12,14)px (3,14)bytes			;8ca8	c3 71
2735  8CAA C6 71        	defw		$71c6			; screen coord (24,14)px (6,14)bytes			;8caa	c6 71
2736  8CAC DC 71        	defw		$71dc			; screen coord (112,14)px (28,14)bytes			;8cac	dc 71
2737  8CAE A3 72        	defw		$72a3			; screen coord (12,21)px (3,21)bytes			;8cae	a3 72
2738  8CB0 AD 72        	defw		$72ad			; screen coord (52,21)px (13,21)bytes			;8cb0	ad 72
2739  8CB2 AE 72        	defw		$72ae			; screen coord (56,21)px (14,21)bytes			;8cb2	ae 72
2740  8CB4 B8 72        	defw		$72b8			; screen coord (96,21)px (24,21)bytes			;8cb4	b8 72
2741  8CB6 BB 72        	defw		$72bb			; screen coord (108,21)px (27,21)bytes			;8cb6	bb 72
2742  8CB8 BE 72        	defw		$72be			; screen coord (120,21)px (30,21)bytes			;8cb8	be 72
2743  8CBA 80 73        	defw		$7380			; screen coord (0,28)px (0,28)bytes				;8cba	80 73
2744  8CBC 83 73        	defw		$7383			; screen coord (12,28)px (3,28)bytes			;8cbc	83 73
2745  8CBE 86 73        	defw		$7386			; screen coord (24,28)px (6,28)bytes			;8cbe	86 73
2746  8CC0 95 73        	defw		$7395			; screen coord (84,28)px (21,28)bytes			;8cc0	95 73
2747  8CC2 98 73        	defw		$7398			; screen coord (96,28)px (24,28)bytes			;8cc2	98 73
2748  8CC4 7E 73        	defw		$737e			; screen coord (120,27)px (30,27)bytes			;8cc4	7e 73
2749  8CC6 7F 73        	defw		$737f			; screen coord (124,27)px (31,27)bytes			;8cc6	7f 73
2750  8CC8 5E 74        	defw		$745e			; screen coord (120,34)px (30,34)bytes			;8cc8	5e 74
2751  8CCA 5F 74        	defw		$745f			; screen coord (124,34)px (31,34)bytes			;8cca	5f 74
2752  8CCC 66 74        	defw		$7466			; screen coord (24,35)px (6,35)bytes			;8ccc	66 74
2753  8CCE 75 74        	defw		$7475			; screen coord (84,35)px (21,35)bytes			;8cce	75 74
2754  8CD0 78 74        	defw		$7478			; screen coord (96,35)px (24,35)bytes			;8cd0	78 74
2755  8CD2 7B 74        	defw		$747b			; screen coord (108,35)px (27,35)bytes			;8cd2	7b 74
2756  8CD4 7E 74        	defw		$747e			; screen coord (120,35)px (30,35)bytes			;8cd4	7e 74
2757  8CD6 7F 74        	defw		$747f			; screen coord (124,35)px (31,35)bytes			;8cd6	7f 74
2758  8CD8 43 75        	defw		$7543			; screen coord (12,42)px (3,42)bytes			;8cd8	43 75
2759  8CDA 46 75        	defw		$7546			; screen coord (24,42)px (6,42)bytes			;8cda	46 75
2760  8CDC 55 75        	defw		$7555			; screen coord (84,42)px (21,42)bytes			;8cdc	55 75
2761  8CDE 26 76        	defw		$7626			; screen coord (24,49)px (6,49)bytes			;8cde	26 76
2762  8CE0 35 76        	defw		$7635			; screen coord (84,49)px (21,49)bytes			;8ce0	35 76
2763  8CE2 38 76        	defw 		$7638			; screen coord (96,49)px (24,49)bytes			;8ce2	38 76
2764  8CE4 39 76        	defw		$7639			; screen coord (100,49)px (25,49)bytes			;8ce4	39 76
2765  8CE6 3C 76        	defw		$763c			; screen coord (112,49)px (28,49)bytes			;8ce6	3c 76
2766  8CE8 0D 77        	defw		$770d			; screen coord (52,56)px (13,56)bytes			;8ce8	0d 77
2767  8CEA 0E 77        	defw		$770e			; screen coord (56,56)px (14,56)bytes			;8cea	0e 77
2768  8CEC F8 70        	defw		$70f8			; screen coord (96,7)px (24,7)bytes				;8cec	f8 70
2769  8CEE 00 00        	defw		0				; ----------- End of Data -----------			;8cee	00 00
2770  8CF0
2771  8CF0              ;***********************************************************************************************
2772  8CF0              ; Screen Data Block - Vertical Lines - pattern [X][-][-][X]
2773  8CF0              ; Every line definition contains 2 members: 16bit VRAM address (line start) and 8bit height of line
2774  8CF0              ; Length equals 0 means end of Screen Block Data
2775  8CF0              SDB_V_LINES:
2776  8CF0 20 70        	defw		$7020			; screen coord (0,1)px (0,1)bytes				;8cf0	20 70
2777  8CF2 1B           	defb		27				; height 27px									;8cf2	1b
2778  8CF3 3F 70        	defw		$703f			; screen coord (124,1)px (31,1)bytes			;8cf3	3f 70
2779  8CF5 15           	defb		21				; height 21px									;8cf5	15
2780  8CF6 03 71        	defw		$7103			; screen coord (12,8)px (3,8)bytes				;8cf6	03 71
2781  8CF8 06           	defb		6				; height 6px									;8cf8	06
2782  8CF9 15 71        	defw		$7115			; screen coord (84,8)px (21,8)bytes				;8cf9	15 71
2783  8CFB 14           	defb		20				; height 20px									;8cfb	14
2784  8CFC 1C 71        	defw		$711c			; screen coord (112,8)px (28,8)bytes			;8cfc	1c 71
2785  8CFE 06           	defb		6				; height 6px									;8cfe	06
2786  8CFF E6 71        	defw		$71e6			; screen coord (24,15)px (6,15)bytes			;8cff	e6 71
2787  8D01 0D           	defb		13				; height 13px									;8d01	0d
2788  8D02 C3 72        	defw		$72c3			; screen coord (12,22)px (3,22)bytes			;8d02	c3 72
2789  8D04 06           	defb		6				; height 6px									;8d04	06
2790  8D05 D8 72        	defw		$72d8			; screen coord (96,22)px (24,22)bytes			;8d05	d8 72
2791  8D07 06           	defb		6				; height 6px									;8d07	06
2792  8D08 DB 72        	defw		$72db			; screen coord (108,22)px (27,22)bytes			;8d08	db 72
2793  8D0A 0D           	defb		13				; height 13px									;8d0a	0d
2794  8D0B A9 73        	defw		$73a9			; screen coord (36,29)px (9,29)bytes			;8d0b	a9 73
2795  8D0D 06           	defb		6				; height 6px									;8d0d	06
2796  8D0E B2 73        	defw 		$73b2			; screen coord (72,29)px (18,29)bytes			;8d0e	b2 73
2797  8D10 06           	defb		6				; height 6px									;8d10	06
2798  8D11 80 74        	defw		$7480			; screen coord (0,36)px (0,36)bytes				;8d11	80 74
2799  8D13 1B           	defb		27				; height 27px									;8d13	1b
2800  8D14 86 74        	defw		$7486			; screen coord (24,36)px (6,36)bytes			;8d14	86 74
2801  8D16 06           	defb		6				; height 6px									;8d16	06
2802  8D17 95 74        	defw		$7495			; screen coord (84,36)px (21,36)bytes			;8d17	95 74
2803  8D19 06           	defb		6				; height 6px									;8d19	06
2804  8D1A 98 74        	defw		$7498			; screen coord (96,36)px (24,36)bytes			;8d1a	98 74
2805  8D1C 06           	defb		6				; height 6px									;8d1c	06
2806  8D1D 9F 74        	defw		$749f			; screen coord (124,36)px (31,36)bytes			;8d1d	9f 74
2807  8D1F 1B           	defb		27				; height 27px									;8d1f	1b
2808  8D20 7C 75        	defw		$757c			; screen coord (112,43)px (28,43)bytes			;8d20	7c 75
2809  8D22 06           	defb		6				; height 6px									;8d22	06
2810  8D23 46 76        	defw		$7646			; screen coord (24,50)px (6,50)bytes			;8d23	46 76
2811  8D25 06           	defb		6				; height 6px									;8d25	06
2812  8D26 55 76        	defw		$7655			; screen coord (84,50)px (21,50)bytes			;8d26	55 76
2813  8D28 06           	defb		6				; height 6px									;8d28	06
2814  8D29 00 00        	defw		$0000			; null address									;8d29	00 00
2815  8D2B 00           	defb		0				; ----------- End of Data -----------			;8d2b	00
2816  8D2C
2817  8D2C              ;***********************************************************************************************
2818  8D2C              ; Screen Data Block - Vertical Double Lines - pattern [X][-][-][-][-][-][-][X]
2819  8D2C              ; Every line definition contains 2 members: 16bit VRAM address (line start) and 8bit height of line
2820  8D2C              ; Length equals 0 means end of Screen Block Data
2821  8D2C              SDB_V_DBL_LINES:
2822  8D2C 2D 70        	defw		$702d			; screen coord (52,1)px (13,1)bytes				;8d2c	2d 70
2823  8D2E 06           	defb		6				; height 6px									;8d2e	06
2824  8D2F 38 70        	defw		$7038			; screen coord (96,1)px (24,1)bytes				;8d2f	38 70
2825  8D31 06           	defb		6				; height 6px									;8d31	06
2826  8D32 ED 71        	defw		$71ed			; screen coord (52,15)px (13,15)bytes			;8d32	ed 71
2827  8D34 06           	defb		6				; height 6px									;8d34	06
2828  8D35 DE 72        	defw		$72de			; screen coord (120,22)px (30,22)bytes			;8d35	de 72
2829  8D37 05           	defb		5				; height 5px									;8d37	05
2830  8D38 4D 76        	defw		$764d			; screen coord (52,50)px (13,50)bytes			;8d38	4d 76
2831  8D3A 06           	defb		6				; height 6px									;8d3a	06
2832  8D3B 58 76        	defw		$7658			; screen coord (96,50)px (24,50)bytes			;8d3b	58 76
2833  8D3D 06           	defb		6				; height 6px									;8d3d	06
2834  8D3E 00 00        	defw		$0000			; null address									;8d3e	00 00
2835  8D40 00           	defb		0				; ----------- End of Data -----------			;8d40	00
2836  8D41
2837  8D41              ;***********************************************************************************************
2838  8D41              ; Screen Data Block - Dots Grid
2839  8D41              ; VRAM addresses of Dots to Eat by Player. Every address determines 1st of 9 Dots drawn
2840  8D41              ; in column with 7 lines space beetween them.
2841  8D41              ; Address $0000 marks end of data.
2842  8D41              SDB_DOTS_GRID:
2843  8D41
2844  8D41 61 70        	defw		$7061			; screen coord (4,3)px (1,3)bytes				;8d41	61 70
2845  8D43 64 70        	defw		$7064			; screen coord (16,3)px (4,3)bytes				;8d43	64 70
2846  8D45 67 70        	defw		$7067			; screen coord (28,3)px (7,3)bytes				;8d45	67 70
2847  8D47 69 70        	defw		$7069			; screen coord (36,3)px (9,3)bytes				;8d47	69 70
2848  8D49 6B 70        	defw		$706b			; screen coord (44,3)px (11,3)bytes				;8d49	6b 70
2849  8D4B 6D 70        	defw		$706d			; screen coord (52,3)px (13,3)bytes				;8d4b	6d 70
2850  8D4D 6F 70        	defw		$706f			; screen coord (60,3)px (15,3)bytes				;8d4d	6f 70
2851  8D4F 71 70        	defw		$7071			; screen coord (68,3)px (17,3)bytes				;8d4f	71 70
2852  8D51 73 70        	defw		$7073			; screen coord (76,3)px (19,3)bytes				;8d51	73 70
2853  8D53 76 70        	defw		$7076			; screen coord (88,3)px (22,3)bytes				;8d53	76 70
2854  8D55 7A 70        	defw		$707a			; screen coord (104,3)px (26,3)bytes			;8d55	7a 70
2855  8D57 7D 70        	defw		$707d			; screen coord (116,3)px (29,3)bytes			;8d57	7d 70
2856  8D59 00 00        	defw		0				; ----------- End of Data -----------			;8d59	00 00
2857  8D5B
2858  8D5B              ;***********************************************************************************************
2859  8D5B              ; Screen Data Block - Dots Unwanted
2860  8D5B              ; VRAM addresses of Dots to remove from screen.
2861  8D5B              ; This routine is needed beacuse SDB_DOTS_GRID routine draws every dots in defined grid w/o skipping unwanted
2862  8D5B              SDB_DOTS_CLR:
2863  8D5B
2864  8D5B 6D 70        	defw		$706d			; screen coord (52,3)px (13,3)bytes				;8d5b	6d 70
2865  8D5D 2D 72        	defw		$722d			; screen coord (52,17)px (13,17)bytes			;8d5d	2d 72
2866  8D5F E9 73        	defw		$73e9			; screen coord (36,31)px (9,31)bytes			;8d5f	e9 73
2867  8D61 EB 73        	defw		$73eb			; screen coord (44,31)px (11,31)bytes			;8d61	eb 73
2868  8D63 ED 73        	defw 		$73ed			; screen coord (52,31)px (13,31)bytes			;8d63	ed 73
2869  8D65 EF 73        	defw		$73ef			; screen coord (60,31)px (15,31)bytes			;8d65	ef 73
2870  8D67 F1 73        	defw		$73f1			; screen coord (68,31)px (17,31)bytes			;8d67	f1 73
2871  8D69 1A 73        	defw		$731a			; screen coord (104,24)px (26,24)bytes			;8d69	1a 73
2872  8D6B 1D 73        	defw		$731d			; screen coord (116,24)px (29,24)bytes			;8d6b	1d 73
2873  8D6D FA 73        	defw		$73fa			; screen coord (104,31)px (26,31)bytes			;8d6d	fa 73
2874  8D6F FD 73        	defw		$73fd			; screen coord (116,31)px (29,31)bytes			;8d6f	fd 73
2875  8D71 8D 76        	defw		$768d			; screen coord (52,52)px (13,52)bytes			;8d71	8d 76
2876  8D73 AD 75        	defw		$75ad			; screen coord (52,45)px (13,45)bytes			;8d73	ad 75
2877  8D75 CD 74        	defw		$74cd			; screen coord (52,38)px (13,38)bytes			;8d75	cd 74
2878  8D77 00 00        	defw		0				; ----------- End of Data -----------			;8d77	00 00
2879  8D79
2880  8D79              ;***********************************************************************************************
2881  8D79              ; Screen Data Block - Dots Extra
2882  8D79              ; Extra 6 Dots placed outside of Grid constrained coordinates
2883  8D79              SDB_DOTS_EXTRA:
2884  8D79 58 71        	defw		$7158			; screen coord (96,10)px (24,10)bytes			;8d79	58 71
2885  8D7B 38 72        	defw		$7238			; screen coord (96,17)px (24,17)bytes			;8d7b	38 72
2886  8D7D 19 73        	defw		$7319			; screen coord (100,24)px (25,24)bytes			;8d7d	19 73
2887  8D7F F9 73        	defw		$73f9			; screen coord (100,31)px (25,31)bytes			;8d7f	f9 73
2888  8D81 B8 75        	defw		$75b8			; screen coord (96,45)px (24,45)bytes			;8d81	b8 75
2889  8D83 78 77        	defw		$7778			; screen coord (96,59)px (24,59)bytes			;8d83	78 77
2890  8D85 00 00        	defw		0				; ----------- End of Data -----------			;8d85	00 00
2891  8D87
2892  8D87              ;***********************************************************************************************
2893  8D87              ; Screen Data Block - Power Pills
2894  8D87              ; Four Power Pills placed at 4 places
2895  8D87              SDB_POWER_PILLS:
2896  8D87 41 71        	defw		$7141			; screen coord (4,10)px (1,10)bytes				;8d87	41 71
2897  8D89 5D 71        	defw		$715d			; screen coord (116,10)px (29,10)bytes			;8d89	5d 71
2898  8D8B A1 75        	defw		$75a1			; screen coord (4,45)px (1,45)bytes				;8d8b	a1 75
2899  8D8D BD 75        	defw		$75bd			; screen coord (116,45)px (29,45)bytes			;8d8d	bd 75
2900  8D8F 00 00        	defw		0				; ----------- End of Data -----------			;8d8f	00 00
2901  8D91
2902  8D91
2903  8D91              ;***********************************************************************************************
2904  8D91              ; Screen Data Block - Vertical Passages
2905  8D91              ; Every line definition contains 16bit VRAM address of top byte where starts 60px hight Passage
2906  8D91              SDB_V_PASSAGES:
2907  8D91 01 70        	defw		$7001			; screen coord (4,0)px (1,0)bytes				;8d91	01 70
2908  8D93 04 70        	defw		$7004			; screen coord (16,0)px (4,0)bytes				;8d93	04 70
2909  8D95 07 70        	defw		$7007			; screen coord (28,0)px (7,0)bytes				;8d95	07 70
2910  8D97 0B 70        	defw		$700b			; screen coord (44,0)px (11,0)bytes				;8d97	0b 70
2911  8D99 0F 70        	defw		$700f			; screen coord (60,0)px (15,0)bytes				;8d99	0f 70
2912  8D9B 13 70        	defw		$7013			; screen coord (76,0)px (19,0)bytes				;8d9b	13 70
2913  8D9D 16 70        	defw		$7016			; screen coord (88,0)px (22,0)bytes				;8d9d	16 70
2914  8D9F 1A 70        	defw		$701a			; screen coord (104,0)px (26,0)bytes			;8d9f	1a 70
2915  8DA1 1C 70        	defw		$701c			; screen coord (112,0)px (28,0)bytes			;8da1	1c 70
2916  8DA3 1D 70        	defw		$701d			; screen coord (116,0)px (29,0)bytes			;8da3	1d 70
2917  8DA5 19 70        	defw		$7019			; screen coord (100,0)px (25,0)bytes			;8da5	19 70
2918  8DA7 00 00        	defw		0				; ----------- End of Data -----------			;8da7	00 00
2919  8DA9
2920  8DA9              ;***********************************************************************************************
2921  8DA9              ; Screen Data Block - Horizontal Passages
2922  8DA9              ; Every line definition contains 2 members: 16bit VRAM address and 8bit width of passage (in bytes)
2923  8DA9              ; When Player or Ghost is at this position, can move Left and Right only
2924  8DA9              ; Width equals 0 means end of Screen Block Data
2925  8DA9              SDB_H_PASSAGES:
2926  8DA9
2927  8DA9 42 70        	defw		$7042			; screen coord (8,2)px (2,2)bytes				;8da9	42 70
2928  8DAB 09           	defb		9				; width 36px (9 bytes)							;8dab	09
2929  8DAC 50 70        	defw		$7050			; screen coord (64,2)px (16,2)bytes				;8dac	50 70
2930  8DAE 06           	defb		6				; width 24px (6 bytes)							;8dae	06
2931  8DAF 5B 70        	defw		$705b			; screen coord (108,2)px (27,2)bytes			;8daf	5b 70
2932  8DB1 02           	defb		2				; width 8px (2 bytes)							;8db1	02
2933  8DB2 25 71        	defw		$7125			; screen coord (20,9)px (5,9)bytes				;8db2	25 71
2934  8DB4 0E           	defb		14				; width 56px (14 bytes)							;8db4	0e
2935  8DB5 37 71        	defw		$7137			; screen coord (92,9)px (23,9)bytes				;8db5	37 71
2936  8DB7 03           	defb		3				; width 12px (3 bytes)							;8db7	03
2937  8DB8 02 72        	defw		$7202			; screen coord (8,10)px (2,10)bytes				;8db8	02 72
2938  8DBA 02           	defb		2				; width 8px (2 bytes)							;8dba	02
2939  8DBB 08 72        	defw		$7208			; screen coord (32,10)px (8,10)bytes			;8dbb	08 72
2940  8DBD 03           	defb		3				; width 12px (3 bytes)							;8dbd	03
2941  8DBE 10 72        	defw		$7210			; screen coord (64,10)px (16,10)bytes			;8dbe	10 72
2942  8DC0 03           	defb		3				; width 12px (3 bytes)							;8dc0	03
2943  8DC1 17 72        	defw		$7217			; screen coord (92,10)px (23,10)bytes			;8dc1	17 72
2944  8DC3 06           	defb		6				; width 24px (6 bytes)							;8dc3	06
2945  8DC4 E8 72        	defw		$72e8			; screen coord (32,23)px (8,23)bytes			;8dc4	e8 72
2946  8DC6 0B           	defb		11				; width 44px (11 bytes)							;8dc6	0b
2947  8DC7 BD 73        	defw		$73bd			; screen coord (116,23)px (29,23)bytes			;8dc7	bd 73
2948  8DC9 04           	defb		4				; width 16px (4 bytes)							;8dc9	04
2949  8DCA C2 73        	defw		$73c2			; screen coord (8,30)px (2,30)bytes				;8dca	c2 73
2950  8DCC 02           	defb		2				; width 8px (2 bytes)							;8dcd	02
2951  8DCD C5 73        	defw		$73c5			; screen coord (20,30)px (5,30)bytes			;8dcd	c5 73
2952  8DCF 02           	defb		2				; width 8px (2 bytes)							;8dcf	02
2953  8DD0 D4 73        	defw		$73d4			; screen coord (80,30)px (20,30)bytes			;8dd0	d4 73
2954  8DD2 02           	defb		2				; width 8px (2 bytes)							;8dd2	02
2955  8DD3 D7 73        	defw		$73d7			; screen coord (92,30)px (23,30)bytes			;8dd3	d7 73
2956  8DD5 02           	defb		2				; width 8px (2 bytes)							;8dd5	02
2957  8DD6 A2 74        	defw		$74a2			; screen coord (8,37)px (2,37)bytes				;8dd6	a2 74
2958  8DD8 02           	defb		2				; width 8px (2 bytes)							;8dd8	02
2959  8DD9 A8 74        	defw		$74a8			; screen coord (32,37)px (8,37)bytes			;8dd9	a8 74
2960  8DDB 0B           	defb		11				; width 44px (11 bytes)							;8ddb	0b
2961  8DDC BA 74        	defw		$74ba			; screen coord (104,37)px (26,37)bytes			;8ddc	ba 74
2962  8DDE 02           	defb		2				; width 8px (2 bytes)							;8dde	02
2963  8DDF 82 75        	defw		$7582			; screen coord (8,44)px (2,44)bytes				;8ddf	82 75
2964  8DE1 18           	defb		24				; width 96px (24 bytes)							;8de1	18
2965  8DE2 62 76        	defw		$7662			; screen coord (8,51)px (2,51)bytes				;8de2	62 76
2966  8DE4 02           	defb		2				; width 8px (2 bytes)							;8de4	02
2967  8DE5 68 76        	defw		$7668			; screen coord (32,51)px (8,51)bytes			;8de5	68 76
2968  8DE7 03           	defb		3				; width 12px (3 bytes)							;8de7	03
2969  8DE8 70 76        	defw		$7670			; screen coord (64,51)px (16,51)bytes			;8de8	70 76
2970  8DEA 03           	defb		3				; width 12px (3 bytes)							;8dea	03
2971  8DEB 7B 76        	defw		$767b			; screen coord (108,51)px (27,51)bytes			;8deb	7b 76
2972  8DED 02           	defb		2				; width 8px (2 bytes)							;8ded	02
2973  8DEE 42 77        	defw		$7742			; screen coord (8,58)px (2,58)bytes				;8dee	42 77
2974  8DF0 1B           	defb		27				; width 108px (27 bytes)						;8df0	1b
2975  8DF1 00 00        	defw		$0000			; null address									;8df1	00 00
2976  8DF3 00           	defb		0				; ----------- End of Data -----------			;8df3	00
2977  8DF4
2978  8DF4              ;***********************************************************************************************
2979  8DF4              ; Screen Data Block - Other Passages
2980  8DF4              ; Every line definition contains 2 members: 16bit VRAM address and 4 bit data
2981  8DF4              ; Data equals 0 means end of Screen Block Data.
2982  8DF4              SDB_OTHER_PASSAGES
2983  8DF4 41 70        	defw		$7041			; screen coord (4,2)px (1,2)bytes				;8df4	41 70
2984  8DF6 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8df6	06
2985  8DF7 44 70        	defw		$7044			; screen coord (16,2)px (4,2)bytes				;8df7	44 70
2986  8DF9 0E           	defb		%00001110		; PASS: Right/Down/Left WALL: Up				;8df9	0e
2987  8DFA 4F 70        	defw		$704f			; screen coord (60,2)px (15,2)bytes				;8dfa	4f 70
2988  8DFC 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8dfc	06
2989  8DFD 4B 70        	defw		$704b			; screen coord (44,2)px (11,2)bytes				;8dfd	4b 70
2990  8DFF 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8dff	0c
2991  8E00 53 70        	defw		$7053			; screen coord (76,2)px (19,2)bytes				;8e00	53 70
2992  8E02 0E           	defb		%00001110		; PASS: Right/Down/Left WALL: Up				;8e02	0e
2993  8E03 56 70        	defw		$7056			; screen coord (88,2)px (22,2)bytes				;8e03	56 70
2994  8E05 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e05	0c
2995  8E06 5A 70        	defw		$705a			; screen coord (104,2)px (26,2)bytes			;8e06	5a 70
2996  8E08 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e08	06
2997  8E09 5D 70        	defw		$705d			; screen coord (116,2)px (29,2)bytes			;8e09	5d 70
2998  8E0B 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e0b	0c
2999  8E0C 24 71        	defw		$7124			; screen coord (16,9)px (4,9)bytes				;8e0c	24 71
3000  8E0E 07           	defb		%00000111		; PASS: Up/Right/Down WALL: Left				;8e0e	07
3001  8E0F 27 71        	defw		$7127			; screen coord (28,9)px (7,9)bytes				;8e0f	27 71
3002  8E11 0E           	defb		%00001110		; PASS: Right/Down/Left WALL: Up				;8e11	0e
3003  8E12 2B 71        	defw		$712b			; screen coord (44,9)px (11,9)bytes				;8e12	2b 71
3004  8E14 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e14	0b
3005  8E15 2F 71        	defw		$712f			; screen coord (60,9)px (15,9)bytes				;8e15	2f 71
3006  8E17 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e17	0b
3007  8E18 33 71        	defw		$7133			; screen coord (76,9)px (19,9)bytes				;8e18	33 71
3008  8E1A 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e1a	0d
3009  8E1B 36 71        	defw		$7136			; screen coord (88,9)px (22,9)bytes				;8e1b	36 71
3010  8E1D 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8e1d	03
3011  8E1E 3A 71        	defw		$713a			; screen coord (104,9)px (26,9)bytes			;8e1e	3a 71
3012  8E20 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e20	0d
3013  8E21 01 72        	defw		$7201			; screen coord (4,16)px (1,16)bytes				;8e21	01 72
3014  8E23 07           	defb		%00000111		; PASS: Up/Right/Down WALL: Left				;8e23	07
3015  8E24 04 72        	defw		$7204			; screen coord (16,16)px (4,16)bytes			;8e24	04 72
3016  8E26 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e26	0d
3017  8E27 07 72        	defw		$7207			; screen coord (28,16)px (7,16)bytes			;8e27	07 72
3018  8E29 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8e29	03
3019  8E2A 0B 72        	defw		$720b			; screen coord (44,16)px (11,16)bytes			;8e2a	0b 72
3020  8E2C 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e2c	0c
3021  8E2D 0F 72        	defw		$720f			; screen coord (60,16)px (15,16)bytes			;8e2d	0f 72
3022  8E2F 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e2f	06
3023  8E30 13 72        	defw		$7213			; screen coord (76,16)px (19,16)bytes			;8e30	13 72
3024  8E32 09           	defb		%00001001		; PASS: Up/Left WALL: Right/Down				;8e32	09
3025  8E33 16 72        	defw		$7216			; screen coord (88,16)px (22,16)bytes			;8e33	16 72
3026  8E35 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e35	06
3027  8E36 19 72        	defw		$7219			; screen coord (100,16)px (25,16)bytes			;8e36	19 72
3028  8E38 0E           	defb		%00001110		; PASS: Right/Down/Left WALL: Up				;8e38	0e
3029  8E39 1A 72        	defw		$721a			; screen coord (104,16)px (26,16)bytes			;8e39	1a 72
3030  8E3B 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e3b	0b
3031  8E3C 1C 72        	defw		$721c			; screen coord (112,16)px (28,16)bytes			;8e3c	1c 72
3032  8E3E 0E           	defb		%00001110		; PASS: Right/Down/Left WALL: Up				;8e3e	0e
3033  8E3F 1D 72        	defw		$721d			; screen coord (116,16)px (29,16)bytes			;8e3f	1d 72
3034  8E41 09           	defb		%00001001		; PASS: Up/Left WALL: Right/Down				;8e41	09
3035  8E42 E7 72        	defw		$72e7			; screen coord (28,23)px (7,23)bytes			;8e42	e7 72
3036  8E44 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e44	06
3037  8E45 EB 72        	defw		$72eb			; screen coord (44,23)px (11,23)bytes			;8e45	eb 72
3038  8E47 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e47	0b
3039  8E48 EF 72        	defw		$72ef			; screen coord (60,23)px (15,23)bytes			;8e48	ef 72
3040  8E4A 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e4a	0b
3041  8E4B F3 72        	defw		$72f3			; screen coord (76,23)px (19,23)bytes			;8e4b	f3 72
3042  8E4D 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e4d	0c
3043  8E4E C1 73        	defw		$73c1			; screen coord (4,30)px (1,30)bytes				;8e4e	c1 73
3044  8E50 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e50	0b
3045  8E51 C4 73        	defw		$73c4			; screen coord (16,30)px (4,30)bytes			;8e51	c4 73
3046  8E53 0F           	defb		%00001111		; PASS: Up/Right/Down/Left						;8e53	0f
3047  8E54 C7 73        	defw		$73c7			; screen coord (28,30)px (7,30)bytes			;8e54	c7 73
3048  8E56 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e56	0d
3049  8E57 D3 73        	defw		$73d3			; screen coord (76,30)px (19,30)bytes			;8e57	d3 73
3050  8E59 07           	defb		%00000111		; PASS: Up/Right/Down WALL: Left				;8e59	07
3051  8E5A D6 73        	defw		$73d6			; screen coord (88,30)px (22,30)bytes			;8e5a	d6 73
3052  8E5C 0F           	defb		%00001111		; PASS: Up/Right/Down/Left						;8e5c	0f
3053  8E5D D9 73        	defw		$73d9			; screen coord (100,30)px (25,30)bytes			;8e5d	d9 73
3054  8E5F 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e5f	0d
3055  8E60 BC 73        	defw		$73bc			; screen coord (112,29)px (28,29)bytes			;8e60	bc 73
3056  8E62 07           	defb		%00000111		; PASS: Up/Right/Down WALL: Left				;8e62	07
3057  8E63 A1 74        	defw		$74a1			; screen coord (4,37)px (1,37)bytes				;8e63	a1 74
3058  8E65 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e65	06
3059  8E66 A4 74        	defw		$74a4			; screen coord (16,37)px (4,37)bytes			;8e66	a4 74
3060  8E68 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e68	0d
3061  8E69 A7 74        	defw		$74a7			; screen coord (28,37)px (7,37)bytes			;8e69	a7 74
3062  8E6B 07           	defb		%00000111		; PASS: Up/Right/Down WALL: Left				;8e6b	07
3063  8E6C B3 74        	defw		$74b3			; screen coord (76,37)px (19,37)bytes			;8e6c	b3 74
3064  8E6E 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8e6e	0d
3065  8E6F B9 74        	defw		$74b9			; screen coord (100,37)px (25,37)bytes			;8e6f	b9 74
3066  8E71 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8e71	03
3067  8E72 BC 74        	defw		$74bc			; screen coord (112,37)px (28,37)bytes			;8e72	bc 74
3068  8E74 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8e74	0b
3069  8E75 BD 74        	defw		$74bd 			; screen coord (116,37)px (29,37)bytes			;8e75	bd 74
3070  8E77 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e77	0c
3071  8E78 81 75        	defw		$7581			; screen coord (4,44)px (1,44)bytes				;8e78	81 75
3072  8E7A 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8e7a	03
3073  8E7B 84 75        	defw		$7584			; screen coord (16,44)px (4,44)bytes			;8e7b	84 75
3074  8E7D 0F           	defb		%00001111		; PASS: Up/Right/Down/Left						;8e7d	0f
3075  8E7E 87 75        	defw		$7587			; screen coord (28,44)px (7,44)bytes			;8e7e	87 75
3076  8E80 0F           	defb		%00001111		; PASS: Up/Right/Down/Left						;8e80	0f
3077  8E81 93 75        	defw		$7593			; screen coord (76,44)px (19,44)bytes			;8e81	93 75
3078  8E83 0F           	defb		%00001111		; PASS: Up/Right/Down/Left						;8e83	0f
3079  8E84 96 75        	defw		$7596			; screen coord (88,44)px (22,44)bytes			;8e84	96 75
3080  8E86 0F           	defb		%00001111		; PASS: Up/Right/Down/Left						;8e86	0f
3081  8E87 9A 75        	defw		$759a			; screen coord (104,44)px (26,44)bytes			;8e87	9a 75
3082  8E89 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e89	0c
3083  8E8A 61 76        	defw		$7661			; screen coord (4,51)px (1,51)bytes				;8e8a	61 76
3084  8E8C 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e8c	06
3085  8E8D 64 76        	defw		$7664			; screen coord (16,51)px (4,51)bytes			;8e8d	64 76
3086  8E8F 09           	defb		%00001001		; PASS: Up/Left WALL: Right/Down				;8e8f	09
3087  8E90 67 76        	defw		$7667			; screen coord (28,51)px (7,51)bytes			;8e90	67 76
3088  8E92 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8e92	03
3089  8E93 6B 76        	defw		$766b			; screen coord (44,51)px (11,51)bytes			;8e93	6b 76
3090  8E95 0C           	defb		%00001100		; PASS: Down/Left WALL: Up/Right				;8e95	0c
3091  8E96 6F 76        	defw 		$766f			; screen coord (60,51)px (15,51)bytes			;8e96	6f 76
3092  8E98 06           	defb		%00000110		; PASS: Right/Down WALL: Up/Left				;8e98	06
3093  8E99 73 76        	defw		$7673			; screen coord (76,51)px (19,51)bytes			;8e99	73 76
3094  8E9B 09           	defb		%00001001		; PASS: Up/Left WALL: Right/Down				;8e9b	09
3095  8E9C 7A 76        	defw		$767a			; screen coord (104,51)px (26,51)bytes			;8e9c	7a 76
3096  8E9E 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8e9e	03
3097  8E9F 7D 76        	defw		$767d			; screen coord (116,51)px (29,51)bytes			;8e9f	7d 76
3098  8EA1 0D           	defb		%00001101		; PASS: Up/Down/Left WALL: Right				;8ea1	0d
3099  8EA2 41 77        	defw		$7741			; screen coord (4,58)px (1,58)bytes				;8ea2	41 77
3100  8EA4 03           	defb		%00000011		; PASS: Up/Right WALL: Down/Left				;8ea4	03
3101  8EA5 4B 77        	defw		$774b			; screen coord (44,58)px (11,58)bytes			;8ea5	4b 77
3102  8EA7 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8ea7	0b
3103  8EA8 4F 77        	defw		$774f			; screen coord (60,58)px (15,58)bytes			;8ea8	4f 77
3104  8EAA 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8eaa	0b
3105  8EAB 56 77        	defw 		$7756			; screen coord (88,58)px (22,58)bytes			;8eab	56 77
3106  8EAD 0B           	defb		%00001011		; PASS: Up/Right/Left WALL: Down				;8ead	0b
3107  8EAE 5D 77        	defw		$775d			; screen coord (116,58)px (29,58)bytes			;8eae	5d 77
3108  8EB0 09           	defb		%00001001		; PASS: Up/Left WALL: Right/Down				;8eb0	09
3109  8EB1 CD 73        	defw		$73cd			; screen coord (52,30)px (13,30)bytes			;8eb1	cd 73
3110  8EB3 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8eb3	01
3111  8EB4 AD 73        	defw		$73ad			; screen coord (52,29)px (13,29)bytes			;8eb4	ad 73
3112  8EB6 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8eb6	01
3113  8EB7 8D 73        	defw		$738d			; screen coord (52,28)px (13,28)bytes			;8eb7	8d 73
3114  8EB9 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8eb9	01
3115  8EBA 6D 73        	defw		$736d			; screen coord (52,27)px (13,27)bytes			;8eba	6d 73
3116  8EBC 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8ebc	01
3117  8EBD 4D 73        	defw		$734d			; screen coord (52,26)px (13,26)bytes			;8ebd	4d 73
3118  8EBF 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8ebf	01
3119  8EC0 2D 73        	defw		$732d			; screen coord (52,25)px (13,25)bytes			;8ec0	2d 73
3120  8EC2 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8ec2	01
3121  8EC3 0D 73        	defw		$730d			; screen coord (52,24)px (13,24)bytes			;8ec3	0d 73
3122  8EC5 01           	defb		%00000001		; PASS: Up WALL: Right/Down/Left				;8ec5	01
3123  8EC6 00 00        	defw		$0000			; null address									;8ec6	00 00
3124  8EC8 00           	defb		0				; ----------- End of Data -----------			;8ec8	00
3125  8EC9
3126  8EC9
3127  8EC9
3128  8EC9              ;================================================================================================
3129  8EC9              ;================================================================================================
3130  8EC9              ;================================================================================================
3131  8EC9              ;
3132  8EC9              ;   Sprites Data Module
3133  8EC9              ;   -------------------
3134  8EC9              ;	All sprites used in this game have dimension 8x4 px
3135  8EC9              ;   Sprites are moved in 2px steps horizontal and 1px step vertical
3136  8EC9              ;   Because 2px step Sprites for Player and Ghosts have defined second
3137  8EC9              ;   variant shifted 2px right in order to draw them moved in the same VRAM address
3138  8EC9              ;
3139  8EC9              	MODULE	SPR
3140  8EC9              ;
3141  8EC9              ;
3142  8EC9              ;***********************************************************************************************
3143  8EC9              ; Sprite Player (facing Right) (8x4)px (2x4) bytes - shifted 2px right
3144  8EC9              PLAYER_R_SH:
3145  8EC9
3146  8EC9 00 55        	defb		$00,$55			;8ec9	00 55		----XXXX
3147  8ECB 01 50        	defb		$01,$50			;8ecb	01 50		---XXX--
3148  8ECD 01 50        	defb		$01,$50			;8ecd	01 50		---XXX--
3149  8ECF 00 55        	defb		$00,$55			;8ecf	00 55 		----XXXX
3150  8ED1
3151  8ED1              ;***********************************************************************************************
3152  8ED1              ; Sprite Player (facing Left) (8x4)px (2x4) bytes - shifted 2px right
3153  8ED1              PLAYER_L_SH:
3154  8ED1
3155  8ED1 01 54        	defb		$01,$54			;8ed1	01 54		---XXXX-
3156  8ED3 00 15        	defb		$00,$15			;8ed4	00 15 		-----XXX
3157  8ED5 00 15        	defb		$00,$15			;8ed5	00 15 		-----XXX
3158  8ED7 01 54        	defb		$01,$54			;8ed7	01 54		---XXXX-
3159  8ED9
3160  8ED9              ;***********************************************************************************************
3161  8ED9              ; Sprite Player (facing Up) (8x4)px (2x4) bytes
3162  8ED9              PLAYER_U
3163  8ED9
3164  8ED9 10 10        	defb 		$10,$10			;8ed9	10 10		-X---X--
3165  8EDB 14 50        	defb		$14,$50			;8edb	14 50		-XX-XX--
3166  8EDD 15 50        	defb		$15,$50			;8edd	15 50 		-XXXXX--
3167  8EDF 05 40        	defb		$05,$40			;8edf	05 40 		--XXX---
3168  8EE1
3169  8EE1              ;***********************************************************************************************
3170  8EE1              ; Sprite Player (facing Down) (8x4)px (2x4) bytes
3171  8EE1              PLAYER_D:
3172  8EE1
3173  8EE1 05 40        	defb		$05,$40			;8ee1	05 40 		--XXX---
3174  8EE3 15 50        	defb		$15,$50			;8ee3	15 50 		-XXXXX--
3175  8EE5 14 50        	defb		$14,$50			;8ee5	14 50 		-XX-XX--
3176  8EE7 10 10        	defb		$10,$10			;8ee7	10 10 		-X---X--
3177  8EE9
3178  8EE9              ;***********************************************************************************************
3179  8EE9              ; Sprite Player (8x4)px (2x4) bytes - for animation frames
3180  8EE9              PLAYER_ANIM:
3181  8EE9
3182  8EE9 05 40        	defb		$05,$40			;8ee9	05 40		--XXX---
3183  8EEB 15 50        	defb		$15,$50			;8eeb	15 50 		-XXXXX--
3184  8EED 15 50        	defb		$15,$50			;8eed	15 50 		-XXXXX--
3185  8EEF 05 40        	defb		$05,$40			;8eef	05 40 		--XXX---
3186  8EF1
3187  8EF1              ;***********************************************************************************************
3188  8EF1              ; Sprite Empty (all pixels background) (8x4)px (2x4) bytes
3189  8EF1              ; Used to remove other sprite (Ghost,Player,etc) from screen at old position
3190  8EF1              EMPTY:
3191  8EF1
3192  8EF1 00 00        	defb		$00,$00			;8ef1	00 00 		--------
3193  8EF3 00 00        	defb		$00,$00			;8ef3	00 00		--------
3194  8EF5 00 00        	defb		$00,$00			;8ef5	00 00 		--------
3195  8EF7 00 00        	defb		$00,$00			;8ef7	00 00 		--------
3196  8EF9
3197  8EF9              ;***********************************************************************************************
3198  8EF9              ; Dummy data
3199  8EF9 00           	defb		0				;8ef9	00 	.
3200  8EFA
3201  8EFA              ;***********************************************************************************************
3202  8EFA              ; Sprite Player (facing Right) (8x4)px (2x4) bytes
3203  8EFA              PLAYER_R:
3204  8EFA
3205  8EFA 05 50        	defb		$05,$50			;8efa	05 50 		--XXXX--
3206  8EFC 15 00        	defb		$15,$00			;8efc	15 00 		-XXX----
3207  8EFE 15 00        	defb		$15,$00			;8efe	15 00 		-XXX----
3208  8F00 05 50        	defb		$05,$50			;8f00	05 50 		--XXXX--
3209  8F02
3210  8F02              ;***********************************************************************************************
3211  8F02              ; Sprite Player (facing Left) (8x4)px (2x4) bytes
3212  8F02              PLAYER_L:
3213  8F02
3214  8F02 15 40        	defb		$15,$40			;8f02	15 40 		-XXXX---
3215  8F04 01 50        	defb		$01,$50			;8f04	01 50		---XXX--
3216  8F06 01 50        	defb		$01,$50			;8f06	01 50 		---XXX--
3217  8F08 15 40        	defb		$15,$40			;8f08	15 40 		-XXXX---
3218  8F0A
3219  8F0A              ;***********************************************************************************************
3220  8F0A              ; Sprite Ghost Blue data (8x4)px (2x4) bytes
3221  8F0A              GHOST_BLUE:
3222  8F0A
3223  8F0A 0A 80        	defb		$0a,$80			;8f0a	0a 80		--XXX---
3224  8F0C 22 20        	defb		$22,$20			;8f0c	22 20		-X-X-X--
3225  8F0E 2A A0        	defb		$2a,$a0			;8f0e	2a a0  		-XXXXX--
3226  8F10 22 20        	defb		$22,$20			;8f10	22 20 		-X-X-X--
3227  8F12
3228  8F12              ;***********************************************************************************************
3229  8F12              ; Sprite Ghost Blue data (8x4)px (2x4) bytes - shifted 2px to the right
3230  8F12              GHOST_BLUE_2R
3231  8F12
3232  8F12 00 A8        	defb		$00,$a8			;8f12	00 a8 		----XXX-
3233  8F14 02 22        	defb		$02,$22			;8f14	02 22 		---X-X-X
3234  8F16 02 AA        	defb		$02,$aa 		;8f16	02 aa 		---XXXXX
3235  8F18 02 22        	defb 		$02,$22			;8f18	02 22 		---X-X-X
3236  8F1A
3237  8F1A              ;***********************************************************************************************
3238  8F1A              ; Sprite Ghost Red data (8x4)px (2x4) bytes
3239  8F1A              GHOST_RED
3240  8F1A
3241  8F1A 0F C0        	defb		$0f,$c0			;8f1a	0f c0		--XXX---
3242  8F1C 33 30        	defb		$33,$30			;8f1c	33 30 		-X-X-X--
3243  8F1E 3F F0        	defb 		$3f,$f0			;8f1e	3f f0 		-XXXXX--
3244  8F20 33 30        	defb		$33,$30			;8f20	33 30 		-X-X-X--
3245  8F22
3246  8F22              ;***********************************************************************************************
3247  8F22              ; Sprite Ghost Red data (8x4)px (2x4) bytes - shifted 2px to the right
3248  8F22              GHOST_RED_2R
3249  8F22
3250  8F22 00 FC        	defb 		$00,$fc			;8f22	00 fc 		----XXX-
3251  8F24 03 33        	defb		$03,$33			;8f24	03 33  		---X-X-X
3252  8F26 03 FF        	defb		$03,$ff			;8f26	03 ff 		---XXXXX
3253  8F28 03 33        	defb		$03,$33			;8f28	03 33 		---X-X-X
3254  8F2A
3255  8F2A              ;***********************************************************************************************
3256  8F2A              ; Sprite Ghost Red A variant data (8x4)px (2x4) bytes
3257  8F2A              GHOST_REDA
3258  8F2A
3259  8F2A 0F C0        	defb		$0f,$c0			;8f2a	0f c0 		--XXX---
3260  8F2C 30 F0        	defb		$30,$f0			;8f2c	30 f0 		-X--XX--
3261  8F2E 3F F0        	defb		$3f,$f0			;8f2e	3f f0 		-XXXXX--
3262  8F30 33 30        	defb		$33,$30			;8f30	33 30 		-X-X-X--
3263  8F32
3264  8F32              ;***********************************************************************************************
3265  8F32              ; Sprite Ghost Red A variant data (8x4)px (2x4) bytes - shifted 2px to the right
3266  8F32              GHOST_REDA_2R
3267  8F32 00 FC        	defb		$00,$fc			;8f32	00 fc 		----XXX-
3268  8F34 03 0F        	defb		$03,$0f			;8f34	03 0f 		---X--XX
3269  8F36 03 FF        	defb		$03,$ff			;8f36	03 ff 		---XXXXX
3270  8F38 03 33        	defb		$03,$33			;8f38	03 33		--_X-X-X
3271  8F3A
3272  8F3A              ;***********************************************************************************************
3273  8F3A              ; Sprite S001 (8x4) px (2x4) bytes
3274  8F3A              HEART
3275  8F3A 3C 3C        	defb		$3c,$3c			;8f3a	3c 3c 		-XX--XX-
3276  8F3C FF FF        	defb		$ff,$ff			;8f3c	ff ff 		XXXXXXXX
3277  8F3E 3E FC        	defb		$3e,$fc			;8f3e	3e fc 		-XX*XXX-
3278  8F40 0F F0        	defb		$0f,$f0			;8f40	0f f0 		--XXXX--
3279  8F42
3280  8F42              	ENDMODULE		; ================ End SPR module ===========================================
3281  8F42
3282  8F42
3283  8F42
3284  8F42
3285  8F42
3286  8F42
3287  8F42
3288  8F42              ;================================================================================================
3289  8F42              ;================================================================================================
3290  8F42              ;================================================================================================
3291  8F42              ;
3292  8F42              ;
3293  8F42              	MODULE 	INPUT
3294  8F42              ;
3295  8F42              ;
3296  8F42              ;************************************************************************
3297  8F42              ; Keyboard Map              ADRES   |   D5  D4      D3  D2      D1  D0  |
3298  8F42              ;-----------------------------------|-----------------------------------|
3299  8F42              KEYS_ROW_0  		equ     $6ffe   ;   R   Q       E           W   T   |
3300  8F42              KEYS_ROW_1  		equ     $6ffd   ;   F   A       D   CTRL    S   G   |
3301  8F42              KEYS_ROW_2  		equ     $6ffb   ;   V   Z       C   SHIFT   X   B   |
3302  8F42              KEYS_ROW_4  		equ     $6fef   ;   M   SPACE   ,           .   N   |
3303  8F42              KEYS_ROW_6  		equ     $6fbf   ;   U   P       I   RETURN  O   Y   |
3304  8F42
3305  8F42              JOYSTICK_PORT		equ		$20			; (RD) Joystick Input IO Port
3306  8F42
3307  8F42              UP					equ		0		; bit 0 in input bitmask variable
3308  8F42              DOWN				equ		1		; bit 1 in input bitmask variable
3309  8F42              LEFT				equ		2		; bit 2 in input bitmask variable
3310  8F42              RIGHT				equ		3		; bit 3 in input bitmask variable
3311  8F42              FIRE				equ		4		; bit 4 in input bitmask variable
3312  8F42
3313  8F42
3314  8F42              ;***********************************************************************************************
3315  8F42              ; Read keys and joystick (if allowed by player)
3316  8F42              ; OUT: a - bitmask with input events (keys or joystick)
3317  8F42              ;          bit 0 - UP, bit 1 - DOWN, bit 2 - LEFT, bit 3 - RIGHT, bit 4 - FIRE
3318  8F42              READ_INPUT:
3319  8F42 C5           	push bc					; save bc											;8f42	c5
3320  8F43 0E 00        	ld c,%00000000			; initial empty bitmask - no input detected			;8f43	0e 00
3321  8F45              TEST_KEY_Q
3322  8F45 3A FE 6F     	ld a,(KEYS_ROW_0)		; select Keyboard row 0 							;8f45	3a fe 6f
3323  8F48 CB 67        	bit 4,a					; check if key 'Q' is pressed						;8f48	cb 67
3324  8F4A C2 4F 8F     	jp nz,TEST_KEY_A		; no - check next key								;8f4a	c2 4f 8f
3325  8F4D              ; -- set bit UP in input bitmask variable
3326  8F4D CB C1        	set UP,c				; set bit for UP key pressed						;8f4d	cb c1
3327  8F4F              TEST_KEY_A:
3328  8F4F 3A FD 6F     	ld a,(KEYS_ROW_1)		; select Keyboard row 1 							;8f4f	3a fd 6f
3329  8F52 CB 67        	bit 4,a					; check if key 'A' is pressed						;8f52	cb 67
3330  8F54 C2 59 8F     	jp nz,TEST_KEY_M		; no - check next key								;8f54	c2 59 8f
3331  8F57              ; -- set bit DOWN in input bitmask variable
3332  8F57 CB C9        	set DOWN,c				; set bit for DOWN key pressed						;8f57	cb c9
3333  8F59              TEST_KEY_M:
3334  8F59 3A EF 6F     	ld a,(KEYS_ROW_4)		; select Keyboard row 4 							;8f59	3a ef 6f
3335  8F5C CB 6F        	bit 5,a					; check if key 'M' pressed							;8f5c	cb 6f
3336  8F5E C2 63 8F     	jp nz,TEST_KEY_COMMA	; no - check next key								;8f5e	c2 63 8f
3337  8F61              ; -- set bit LEFT in input bitmask variable
3338  8F61 CB D1        	set LEFT,c				; set bit for LEFT key pressed						;8f61	cb d1
3339  8F63              TEST_KEY_COMMA:
3340  8F63 2F           	cpl						; invert bits - 1 means key pressed	 				;8f63	2f
3341  8F64 E6 18        	and %00011000			; mask keys ',' (RIGHT) and SPACE (FIRE)			;8f64	e6 18
3342  8F66 B1           	or c					; a - bitmask with inputs detected					;8f66	b1
3343  8F67 4F           	ld c,a					; store to local variable							;8f67	4f
3344  8F68              TEST_KEY_Z
3345  8F68 3A FB 6F     	ld a,(KEYS_ROW_2)		; select Keyboard row 2								;8f68	3a fb 6f
3346  8F6B 2F           	cpl						; invert bits - 1 means key pressed					;8f6b	2f
3347  8F6C E6 10        	and %00010000			; mask on key 'Z' (bit FIRE)						;8f6c	e6 10
3348  8F6E B1           	or c					; a - all detected keys								;8f6e	b1
3349  8F6F C1           	pop bc					; restore bc										;8f6f	c1
3350  8F70 C0           	ret nz					; ----- return if any checked key pressed			;8f70	c0
3351  8F71              ; -- no keys pressed detected - check joystick if enabled
3352  8F71 3A 7C 8F     	ld a,(JOY_ENABLE)		; Input flag - 0-keys, 1-joystick					;8f71	3a 7c 8f
3353  8F74 B7           	or a					; check if joystick is enabled						;8f74	b7
3354  8F75 C8           	ret z					; no -  return with a=0 - no key pressed			;8f75	c8
3355  8F76              ; -- check joistick
3356  8F76 DB 20        	in a,(JOYSTICK_PORT)	; read Joystick										;8f76	db 20
3357  8F78 2F           	cpl						; invert bits - 1 means joystick move/fire			;8f78	2f
3358  8F79 E6 1F        	and %00011111			; mask UP/DOWN/LEFT/RIGHT/FIRE						;8f79	e6 1f
3359  8F7B C9           	ret						; -------- End of Proc ------ a - input bitmask 	;8f7b	c9
3360  8F7C
3361  8F7C              ;***********************************************************************************************
3362  8F7C              ; Game Variables
3363  8F7C              JOY_ENABLE:
3364  8F7C 00           	defb	$00				; 1-joystick enabled, 0-keys only					;8f7c	00
3365  8F7D
3366  8F7D
3367  8F7D
3368  8F7D              	ENDMODULE	; ================ End INPUT module ==========================================
3369  8F7D
3370  8F7D
3371  8F7D              ;***********************************************************************************************
3372  8F7D              ; Dummy Data
3373  8F7D 00 00 00     	defb	0,0,0			;Not used											;8f7d	00 00 00
3374  8F80
# file closed: l:\vz-dis-games\GhostHunter\ghost-hunter.asm
